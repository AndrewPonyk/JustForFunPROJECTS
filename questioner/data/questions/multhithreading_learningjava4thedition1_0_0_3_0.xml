<?xml version="1.0" encoding="UTF-8"?>
<questions id="1_0_0_3_0" name="Multhithreading_LearningJava4thEdition" nofquestions="31" nofsubcategories="0" filename="multhithreading_learningjava4thedition1_0_0_3_0.xml">
  <question id="1_0_0_3_0:0" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Threads&amp;nbsp;:&amp;nbsp;what&amp;nbsp;is&amp;nbsp;thread&amp;nbsp;in&amp;nbsp;Java?&amp;nbsp;Provide&amp;nbsp;Hello&amp;nbsp;World&amp;nbsp;example.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>To&amp;nbsp;the&amp;nbsp;OS,&amp;nbsp;a&amp;nbsp;process&amp;nbsp;was&amp;nbsp;more&amp;nbsp;or&amp;nbsp;less&amp;nbsp;a&amp;nbsp;black&amp;nbsp;box&amp;nbsp;that&lt;br&gt;
decided&amp;nbsp;what&amp;nbsp;to&amp;nbsp;do&amp;nbsp;on&amp;nbsp;its&amp;nbsp;own.&amp;nbsp;If&amp;nbsp;an&amp;nbsp;application&amp;nbsp;required&lt;br&gt;
greater&amp;nbsp;concurrency,&amp;nbsp;it&amp;nbsp;could&amp;nbsp;get&amp;nbsp;it&amp;nbsp;only&amp;nbsp;by&amp;nbsp;running&lt;br&gt;
multiple&amp;nbsp;processes&amp;nbsp;and&amp;nbsp;communicating&amp;nbsp;between&amp;nbsp;them,&amp;nbsp;but&lt;br&gt;
this&amp;nbsp;was&amp;nbsp;a&amp;nbsp;heavyweight&amp;nbsp;approach&amp;nbsp;and&amp;nbsp;not&amp;nbsp;very&amp;nbsp;elegant.&lt;br&gt;
Later,&amp;nbsp;the&amp;nbsp;concept&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;was&amp;nbsp;introduced.&amp;nbsp;Threads&amp;nbsp;provide&lt;br&gt;
fine-grained&amp;nbsp;concurrency&amp;nbsp;within&amp;nbsp;a&amp;nbsp;process&amp;nbsp;under&amp;nbsp;the&amp;nbsp;application’s&amp;nbsp;own&lt;br&gt;
control.&amp;nbsp;Threads&amp;nbsp;have&amp;nbsp;existed&amp;nbsp;for&amp;nbsp;a&amp;nbsp;long&amp;nbsp;time,&amp;nbsp;but&amp;nbsp;have&amp;nbsp;historically&lt;br&gt;
been&amp;nbsp;tricky&amp;nbsp;to&amp;nbsp;use.&amp;nbsp;In&amp;nbsp;Java,&amp;nbsp;support&amp;nbsp;for&amp;nbsp;threading&amp;nbsp;is&amp;nbsp;__&amp;nbsp;built&amp;nbsp;into&lt;br&gt;
the&amp;nbsp;language,&amp;nbsp;making&amp;nbsp;it&amp;nbsp;easier&amp;nbsp;to&amp;nbsp;work&amp;nbsp;with&amp;nbsp;threads.&lt;br&gt;
The&amp;nbsp;Java&amp;nbsp;concurrency&amp;nbsp;utilities&amp;nbsp;address&amp;nbsp;common&amp;nbsp;patterns&amp;nbsp;and&amp;nbsp;practices&amp;nbsp;in&amp;nbsp;multithreaded&lt;br&gt;
applications&amp;nbsp;and&amp;nbsp;raise&amp;nbsp;them&amp;nbsp;to&amp;nbsp;the&amp;nbsp;level&amp;nbsp;of&amp;nbsp;tangible&amp;nbsp;Java&amp;nbsp;APIs.&lt;br&gt;
&lt;br&gt;
DEF:&amp;nbsp;&lt;br&gt;
Conceptually,&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;a&amp;nbsp;flow&amp;nbsp;of&amp;nbsp;control&amp;nbsp;within&amp;nbsp;a&amp;nbsp;program.&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;similar&amp;nbsp;to&amp;nbsp;the&amp;nbsp;more&amp;nbsp;familiar&amp;nbsp;notion&amp;nbsp;of&amp;nbsp;a&amp;nbsp;process,&amp;nbsp;except&lt;br&gt;
that&amp;nbsp;threads&amp;nbsp;within&amp;nbsp;the&amp;nbsp;same&amp;nbsp;application&amp;nbsp;are&amp;nbsp;much&amp;nbsp;more&amp;nbsp;closely&lt;br&gt;
related&amp;nbsp;and&amp;nbsp;share&amp;nbsp;much&amp;nbsp;of&amp;nbsp;the&amp;nbsp;same&amp;nbsp;state&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;threads&amp;nbsp;cooperate&amp;nbsp;to&amp;nbsp;share&amp;nbsp;a&amp;nbsp;working&amp;nbsp;area.&lt;br&gt;
Multiple&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;an&amp;nbsp;application&amp;nbsp;have&amp;nbsp;the&amp;nbsp;same&amp;nbsp;problems&amp;nbsp;as&amp;nbsp;the&amp;nbsp;golfers—in&amp;nbsp;a&amp;nbsp;word,&lt;br&gt;
___&amp;nbsp;synchronization.&lt;br&gt;
&lt;br&gt;
Just&amp;nbsp;as&amp;nbsp;you&amp;nbsp;can’t&amp;nbsp;have&amp;nbsp;two&amp;nbsp;sets&amp;nbsp;of&amp;nbsp;players&amp;nbsp;blindly&amp;nbsp;playing&amp;nbsp;the&amp;nbsp;same&amp;nbsp;green&lt;br&gt;
at&amp;nbsp;the&amp;nbsp;same&amp;nbsp;time,&amp;nbsp;you&amp;nbsp;can’t&amp;nbsp;have&amp;nbsp;several&amp;nbsp;threads&amp;nbsp;trying&amp;nbsp;to&amp;nbsp;access&amp;nbsp;the&lt;br&gt;
same&amp;nbsp;variables&amp;nbsp;without&amp;nbsp;some&amp;nbsp;kind&amp;nbsp;of&amp;nbsp;coordination.&amp;nbsp;Someone&amp;nbsp;is&amp;nbsp;bound&amp;nbsp;to&amp;nbsp;get&lt;br&gt;
hurt.&amp;nbsp;A&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;reserve&amp;nbsp;the&amp;nbsp;right&amp;nbsp;to&amp;nbsp;use&amp;nbsp;an&amp;nbsp;object&amp;nbsp;until&amp;nbsp;it’s&amp;nbsp;finished&amp;nbsp;with&amp;nbsp;its&lt;br&gt;
task,&amp;nbsp;just&amp;nbsp;as&amp;nbsp;a&amp;nbsp;golf&amp;nbsp;party&amp;nbsp;gets&amp;nbsp;exclusive&amp;nbsp;rights&amp;nbsp;to&amp;nbsp;the&amp;nbsp;green&amp;nbsp;until&amp;nbsp;it’s&amp;nbsp;done.&lt;br&gt;
And&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;that&amp;nbsp;is&amp;nbsp;more&amp;nbsp;important&amp;nbsp;can&amp;nbsp;raise&amp;nbsp;its&amp;nbsp;priority,&amp;nbsp;asserting&amp;nbsp;its&lt;br&gt;
right&amp;nbsp;to&amp;nbsp;play&amp;nbsp;through.&lt;br&gt;
&lt;br&gt;
__&amp;nbsp;The&amp;nbsp;devil&amp;nbsp;is&amp;nbsp;in&amp;nbsp;the&amp;nbsp;details,&amp;nbsp;of&amp;nbsp;course,&amp;nbsp;and&amp;nbsp;those&amp;nbsp;details&amp;nbsp;have&amp;nbsp;historically&amp;nbsp;made&amp;nbsp;threads&lt;br&gt;
difficult&amp;nbsp;to&amp;nbsp;use.&amp;nbsp;Fortunately,&amp;nbsp;Java&amp;nbsp;makes&amp;nbsp;creating,&amp;nbsp;controlling,&amp;nbsp;and&amp;nbsp;coordinating&amp;nbsp;threads&lt;br&gt;
simpler&amp;nbsp;by&amp;nbsp;integrating&amp;nbsp;some&amp;nbsp;of&amp;nbsp;these&amp;nbsp;concepts&amp;nbsp;directly&amp;nbsp;into&amp;nbsp;the&amp;nbsp;language.&lt;br&gt;
&lt;br&gt;
=======================&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;The&amp;nbsp;Thread&amp;nbsp;Class&amp;nbsp;and&amp;nbsp;the&amp;nbsp;Runnable&amp;nbsp;Interface&lt;br&gt;
All&amp;nbsp;execution&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;is&amp;nbsp;associated&amp;nbsp;with&amp;nbsp;a&amp;nbsp;Thread&amp;nbsp;object,&amp;nbsp;beginning&amp;nbsp;with&amp;nbsp;a&lt;br&gt;
“main”&amp;nbsp;thread&amp;nbsp;that&amp;nbsp;is&amp;nbsp;started&amp;nbsp;by&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;VM&amp;nbsp;to&amp;nbsp;launch&amp;nbsp;your&amp;nbsp;application.&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;new&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;born&amp;nbsp;when&lt;br&gt;
we&amp;nbsp;create&amp;nbsp;an&amp;nbsp;instance&amp;nbsp;of&amp;nbsp;the&amp;nbsp;__&amp;nbsp;java.lang.Thread&amp;nbsp;__&amp;nbsp;class.&amp;nbsp;The&amp;nbsp;Thread&amp;nbsp;object&lt;br&gt;
represents&amp;nbsp;a&amp;nbsp;real&amp;nbsp;thread&amp;nbsp;in&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;interpreter&amp;nbsp;and&amp;nbsp;serves&amp;nbsp;as&amp;nbsp;a&lt;br&gt;
handle&amp;nbsp;for&amp;nbsp;controlling&amp;nbsp;and&amp;nbsp;coordinating&amp;nbsp;its&amp;nbsp;execution.&amp;nbsp;With&amp;nbsp;it,&amp;nbsp;we&amp;nbsp;can&amp;nbsp;start&lt;br&gt;
the&amp;nbsp;thread,&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;it&amp;nbsp;to&amp;nbsp;complete,&amp;nbsp;cause&amp;nbsp;it&amp;nbsp;to&amp;nbsp;sleep&amp;nbsp;for&amp;nbsp;a&amp;nbsp;time,&amp;nbsp;or&lt;br&gt;
interrupt&amp;nbsp;its&amp;nbsp;activity.&amp;nbsp;The&amp;nbsp;constructor&amp;nbsp;for&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;class&amp;nbsp;accepts&lt;br&gt;
information&amp;nbsp;about&amp;nbsp;where&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;should&amp;nbsp;begin&amp;nbsp;its&amp;nbsp;execution.&lt;br&gt;
Conceptually,&amp;nbsp;we&amp;nbsp;would&amp;nbsp;like&amp;nbsp;to&amp;nbsp;simply&amp;nbsp;tell&amp;nbsp;it&amp;nbsp;what&amp;nbsp;method&amp;nbsp;to&amp;nbsp;run,&amp;nbsp;but&lt;br&gt;
because&amp;nbsp;there&amp;nbsp;are&amp;nbsp;no&amp;nbsp;pointers&amp;nbsp;to&amp;nbsp;methods&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;(not&amp;nbsp;in&amp;nbsp;this&amp;nbsp;sense&lt;br&gt;
anyway),&amp;nbsp;we&amp;nbsp;can’t&amp;nbsp;specify&amp;nbsp;one&amp;nbsp;directly.&amp;nbsp;Instead,&amp;nbsp;we&amp;nbsp;have&amp;nbsp;to&lt;br&gt;
take&amp;nbsp;a&amp;nbsp;short&amp;nbsp;detour&amp;nbsp;and&amp;nbsp;use&amp;nbsp;the&amp;nbsp;java.lang.Runnable&amp;nbsp;interface&amp;nbsp;to&lt;br&gt;
create&amp;nbsp;or&amp;nbsp;mark&amp;nbsp;an&amp;nbsp;object&amp;nbsp;that&amp;nbsp;contains&amp;nbsp;a&amp;nbsp;“runnable”&amp;nbsp;method.&lt;br&gt;
Runnable&amp;nbsp;defines&amp;nbsp;a&amp;nbsp;single,&amp;nbsp;general-purpose&amp;nbsp;run()&amp;nbsp;method:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;interface&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;abstract&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
Every&amp;nbsp;thread&amp;nbsp;begins&amp;nbsp;its&amp;nbsp;life&amp;nbsp;by&amp;nbsp;executing&amp;nbsp;the&amp;nbsp;__&amp;nbsp;run()&amp;nbsp;__&amp;nbsp;method&amp;nbsp;in&amp;nbsp;a&lt;br&gt;
Runnable&amp;nbsp;object,&amp;nbsp;which&amp;nbsp;is&amp;nbsp;the&amp;nbsp;“target&amp;nbsp;object”&amp;nbsp;that&amp;nbsp;was&amp;nbsp;passed&lt;br&gt;
to&amp;nbsp;the&amp;nbsp;thread’s&amp;nbsp;constructor.&amp;nbsp;The&amp;nbsp;run()&amp;nbsp;method&amp;nbsp;can&amp;nbsp;contain&amp;nbsp;any&amp;nbsp;code,&lt;br&gt;
but&amp;nbsp;it&amp;nbsp;must&amp;nbsp;be&amp;nbsp;public,&amp;nbsp;take&amp;nbsp;no&amp;nbsp;arguments,&amp;nbsp;have&amp;nbsp;no&amp;nbsp;return&amp;nbsp;value,&amp;nbsp;and&lt;br&gt;
throw&amp;nbsp;no&amp;nbsp;checked&amp;nbsp;exceptions.&lt;br&gt;
&lt;br&gt;
=============&lt;br&gt;
Hello&amp;nbsp;World&amp;nbsp;Example&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;simplymultithreadexamples;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;HelloThreads&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Hello&amp;nbsp;threads");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;animation1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;Animation());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;animation2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;Animation());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;animation1.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;animation2.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Animation&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("animation&amp;nbsp;"&amp;nbsp;+&amp;nbsp;i);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(200);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;TODO&amp;nbsp;Auto-generated&amp;nbsp;catch&amp;nbsp;block&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
=================================&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;natural-born&amp;nbsp;thread&lt;br&gt;
The&amp;nbsp;Runnable&amp;nbsp;interface&amp;nbsp;lets&amp;nbsp;us&amp;nbsp;make&amp;nbsp;an&amp;nbsp;arbitrary&amp;nbsp;object&amp;nbsp;the&amp;nbsp;target&lt;br&gt;
of&amp;nbsp;a&amp;nbsp;thread,&amp;nbsp;as&amp;nbsp;we&amp;nbsp;did&amp;nbsp;in&amp;nbsp;the&amp;nbsp;previous&amp;nbsp;example.&amp;nbsp;This&amp;nbsp;is&amp;nbsp;the&lt;br&gt;
most&amp;nbsp;important&amp;nbsp;general&amp;nbsp;usage&amp;nbsp;of&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;class.&amp;nbsp;In&amp;nbsp;most&amp;nbsp;situations&lt;br&gt;
in&amp;nbsp;which&amp;nbsp;you&amp;nbsp;need&amp;nbsp;to&amp;nbsp;use&amp;nbsp;threads,&amp;nbsp;you’ll&amp;nbsp;create&amp;nbsp;a&amp;nbsp;class&amp;nbsp;(possibly&amp;nbsp;a&lt;br&gt;
simple&amp;nbsp;adapter&amp;nbsp;class)&amp;nbsp;that&amp;nbsp;implements&amp;nbsp;the&amp;nbsp;Runnable&amp;nbsp;interface.&lt;br&gt;
However,&amp;nbsp;we’d&amp;nbsp;be&amp;nbsp;remiss&amp;nbsp;not&amp;nbsp;to&amp;nbsp;show&amp;nbsp;you&amp;nbsp;the&amp;nbsp;other&amp;nbsp;technique&amp;nbsp;for&lt;br&gt;
creating&amp;nbsp;a&amp;nbsp;thread.&amp;nbsp;Another&amp;nbsp;design&amp;nbsp;option&amp;nbsp;is&amp;nbsp;to&amp;nbsp;make&amp;nbsp;our&amp;nbsp;target&lt;br&gt;
class&amp;nbsp;a&amp;nbsp;subclass&amp;nbsp;of&amp;nbsp;a&amp;nbsp;type&amp;nbsp;that&amp;nbsp;is&amp;nbsp;already&amp;nbsp;runnable.&amp;nbsp;As&amp;nbsp;it&amp;nbsp;turns&lt;br&gt;
out,&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;class&amp;nbsp;itself&amp;nbsp;conveniently&amp;nbsp;implements&amp;nbsp;the&amp;nbsp;Runna&lt;br&gt;
ble&amp;nbsp;interface;&amp;nbsp;it&amp;nbsp;has&amp;nbsp;its&amp;nbsp;own&amp;nbsp;run()&amp;nbsp;method,&amp;nbsp;which&amp;nbsp;we&amp;nbsp;can&amp;nbsp;override&lt;br&gt;
directly&amp;nbsp;to&amp;nbsp;do&amp;nbsp;our&amp;nbsp;bidding:&lt;br&gt;
class&amp;nbsp;Animation&amp;nbsp;extends&amp;nbsp;Thread&amp;nbsp;{&lt;br&gt;
boolean&amp;nbsp;animate&amp;nbsp;=&amp;nbsp;true;&lt;br&gt;
public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
while&amp;nbsp;(&amp;nbsp;animate&amp;nbsp;)&amp;nbsp;{&lt;br&gt;
//&amp;nbsp;draw&amp;nbsp;Frames&lt;br&gt;
...&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;skeleton&amp;nbsp;of&amp;nbsp;our&amp;nbsp;Animation&amp;nbsp;class&amp;nbsp;looks&amp;nbsp;much&amp;nbsp;the&amp;nbsp;same&amp;nbsp;as&amp;nbsp;before,&lt;br&gt;
except&amp;nbsp;that&amp;nbsp;our&amp;nbsp;class&amp;nbsp;is&amp;nbsp;now&amp;nbsp;a&amp;nbsp;subclass&amp;nbsp;of&amp;nbsp;Thread.&amp;nbsp;To&amp;nbsp;go&amp;nbsp;along&lt;br&gt;
with&amp;nbsp;this&amp;nbsp;scheme,&amp;nbsp;the&amp;nbsp;default&amp;nbsp;constructor&amp;nbsp;of&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;class&amp;nbsp;makes&lt;br&gt;
itself&amp;nbsp;the&amp;nbsp;default&amp;nbsp;target—that&amp;nbsp;is,&amp;nbsp;by&amp;nbsp;default,&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;executes&lt;br&gt;
its&amp;nbsp;own&amp;nbsp;run()&amp;nbsp;method&amp;nbsp;when&amp;nbsp;we&amp;nbsp;call&amp;nbsp;the&amp;nbsp;start()&amp;nbsp;method,&amp;nbsp;as&amp;nbsp;shown&amp;nbsp;in&lt;br&gt;
Figure&amp;nbsp;9-2.&amp;nbsp;Now&amp;nbsp;our&amp;nbsp;subclass&amp;nbsp;can&amp;nbsp;just&amp;nbsp;override&amp;nbsp;the&amp;nbsp;run()&amp;nbsp;method&amp;nbsp;in&amp;nbsp;the&lt;br&gt;
Thread&amp;nbsp;class.&amp;nbsp;(Thread&amp;nbsp;itself&amp;nbsp;defines&amp;nbsp;an&amp;nbsp;empty&amp;nbsp;run()&amp;nbsp;method.)&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:1" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Controlling&amp;nbsp;Threads&amp;nbsp;(start(),&amp;nbsp;sleep,&amp;nbsp;join,&amp;nbsp;wait&amp;nbsp;,&amp;nbsp;some&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;deprecated&amp;nbsp;methods,&lt;br&gt;
describe).&amp;nbsp;How&amp;nbsp;to&amp;nbsp;properly&amp;nbsp;stop&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;?&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;Daemon&amp;nbsp;Thread&amp;nbsp;?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>We&amp;nbsp;have&amp;nbsp;seen&amp;nbsp;the&amp;nbsp;start()&amp;nbsp;method&amp;nbsp;used&amp;nbsp;to&amp;nbsp;begin&amp;nbsp;execution&amp;nbsp;of&amp;nbsp;a&amp;nbsp;new&amp;nbsp;thread.&amp;nbsp;Several&lt;br&gt;
other&amp;nbsp;instance&amp;nbsp;methods&amp;nbsp;let&amp;nbsp;us&amp;nbsp;explicitly&amp;nbsp;control&amp;nbsp;a&amp;nbsp;thread’s&amp;nbsp;execution:&lt;br&gt;
-&amp;nbsp;The&amp;nbsp;static&amp;nbsp;Thread.sleep()&amp;nbsp;method&amp;nbsp;causes&amp;nbsp;the&amp;nbsp;currently&amp;nbsp;executing&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;wait&lt;br&gt;
for&amp;nbsp;a&amp;nbsp;designated&amp;nbsp;period&amp;nbsp;of&amp;nbsp;time,&amp;nbsp;without&amp;nbsp;consuming&amp;nbsp;much&amp;nbsp;(or&amp;nbsp;possibly&amp;nbsp;any)&amp;nbsp;CPU&lt;br&gt;
time.&lt;br&gt;
-&amp;nbsp;The&amp;nbsp;methods&amp;nbsp;wait()&amp;nbsp;and&amp;nbsp;join()&amp;nbsp;coordinate&amp;nbsp;the&amp;nbsp;execution&amp;nbsp;of&amp;nbsp;two&amp;nbsp;or&amp;nbsp;more&lt;br&gt;
threads.&amp;nbsp;We’ll&amp;nbsp;discuss&amp;nbsp;them&amp;nbsp;in&amp;nbsp;detail&amp;nbsp;when&amp;nbsp;we&amp;nbsp;talk&amp;nbsp;about&amp;nbsp;thread&lt;br&gt;
synchronization&amp;nbsp;later&amp;nbsp;in&amp;nbsp;this&amp;nbsp;chapter.&lt;br&gt;
-&amp;nbsp;The&amp;nbsp;interrupt()&amp;nbsp;method&amp;nbsp;wakes&amp;nbsp;up&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;that&amp;nbsp;is&amp;nbsp;sleeping&amp;nbsp;in&amp;nbsp;a&amp;nbsp;sleep()&lt;br&gt;
or&amp;nbsp;wait()&amp;nbsp;operation&amp;nbsp;or&amp;nbsp;is&amp;nbsp;otherwise&amp;nbsp;blocked&amp;nbsp;on&amp;nbsp;a&amp;nbsp;long&amp;nbsp;I/O&amp;nbsp;operation.1&lt;br&gt;
&lt;br&gt;
====================================&lt;br&gt;
&lt;br&gt;
Deprecated&amp;nbsp;methods&lt;br&gt;
We&amp;nbsp;should&amp;nbsp;also&amp;nbsp;mention&amp;nbsp;three&amp;nbsp;deprecated&amp;nbsp;thread&amp;nbsp;control&amp;nbsp;methods:&amp;nbsp;stop(),&lt;br&gt;
suspend(),&amp;nbsp;and&amp;nbsp;resume().&amp;nbsp;The&amp;nbsp;stop()&amp;nbsp;method&amp;nbsp;complements&amp;nbsp;start();&amp;nbsp;it&lt;br&gt;
destroys&amp;nbsp;the&amp;nbsp;thread.&amp;nbsp;start()&amp;nbsp;and&amp;nbsp;the&amp;nbsp;deprecated&amp;nbsp;stop()&amp;nbsp;method&amp;nbsp;can&amp;nbsp;be&lt;br&gt;
called&amp;nbsp;only&amp;nbsp;once&amp;nbsp;in&amp;nbsp;the&amp;nbsp;thread’s&amp;nbsp;lifecycle.&amp;nbsp;By&amp;nbsp;contrast,&amp;nbsp;the&amp;nbsp;deprecated&lt;br&gt;
suspend()&amp;nbsp;and&amp;nbsp;resume()&amp;nbsp;methods&amp;nbsp;were&amp;nbsp;used&amp;nbsp;to&amp;nbsp;arbitrarily&amp;nbsp;pause&lt;br&gt;
and&amp;nbsp;then&amp;nbsp;restart&amp;nbsp;the&amp;nbsp;execution&amp;nbsp;of&amp;nbsp;a&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
&amp;nbsp;The&amp;nbsp;problem&lt;br&gt;
with&amp;nbsp;both&amp;nbsp;stop()&amp;nbsp;and&amp;nbsp;suspend()&amp;nbsp;is&amp;nbsp;that&amp;nbsp;they&amp;nbsp;seize&amp;nbsp;control&amp;nbsp;of&amp;nbsp;a&amp;nbsp;thread’s&lt;br&gt;
execution&amp;nbsp;in&amp;nbsp;an&amp;nbsp;uncoordinated,&amp;nbsp;harsh&amp;nbsp;way.&amp;nbsp;This&amp;nbsp;makes&amp;nbsp;programming&lt;br&gt;
difficult;&amp;nbsp;it’s&amp;nbsp;not&amp;nbsp;always&amp;nbsp;easy&amp;nbsp;for&amp;nbsp;an&amp;nbsp;application&amp;nbsp;to&amp;nbsp;anticipate&amp;nbsp;and&amp;nbsp;properly&lt;br&gt;
recover&amp;nbsp;from&amp;nbsp;being&amp;nbsp;interrupted&amp;nbsp;at&amp;nbsp;an&amp;nbsp;arbitrary&amp;nbsp;point&amp;nbsp;in&amp;nbsp;its&amp;nbsp;execution.&lt;br&gt;
Moreover,&amp;nbsp;when&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;seized&amp;nbsp;using&amp;nbsp;one&amp;nbsp;of&amp;nbsp;these&amp;nbsp;methods,&amp;nbsp;the&lt;br&gt;
Java&amp;nbsp;runtime&amp;nbsp;system&amp;nbsp;must&amp;nbsp;release&amp;nbsp;all&amp;nbsp;its&amp;nbsp;internal&amp;nbsp;locks&amp;nbsp;used&amp;nbsp;for&amp;nbsp;thread&lt;br&gt;
synchronization.&amp;nbsp;This&amp;nbsp;can&amp;nbsp;cause&amp;nbsp;unexpected&amp;nbsp;behavior&amp;nbsp;and,&amp;nbsp;in&amp;nbsp;the&amp;nbsp;case&amp;nbsp;of&lt;br&gt;
suspend(),&amp;nbsp;can&amp;nbsp;easily&amp;nbsp;lead&amp;nbsp;to&amp;nbsp;deadlock.&amp;nbsp;A&amp;nbsp;better&amp;nbsp;way&amp;nbsp;to&amp;nbsp;affect&amp;nbsp;the&amp;nbsp;execution&lt;br&gt;
of&amp;nbsp;a&amp;nbsp;thread—which&amp;nbsp;requires&amp;nbsp;just&amp;nbsp;a&amp;nbsp;bit&amp;nbsp;more&amp;nbsp;work&amp;nbsp;on&amp;nbsp;your&amp;nbsp;part—is&amp;nbsp;by&lt;br&gt;
creating&amp;nbsp;some&amp;nbsp;simple&amp;nbsp;logic&amp;nbsp;in&amp;nbsp;your&amp;nbsp;thread’s&amp;nbsp;code&amp;nbsp;to&amp;nbsp;use&amp;nbsp;monitor&lt;br&gt;
variables&amp;nbsp;(flags),&amp;nbsp;possibly&amp;nbsp;in&amp;nbsp;conjunction&amp;nbsp;with&amp;nbsp;the&amp;nbsp;interrupt()&amp;nbsp;method,&lt;br&gt;
which&amp;nbsp;allows&amp;nbsp;you&amp;nbsp;to&amp;nbsp;wake&amp;nbsp;up&amp;nbsp;a&amp;nbsp;sleeping&amp;nbsp;thread.&amp;nbsp;In&amp;nbsp;other&amp;nbsp;words,&amp;nbsp;you&amp;nbsp;should&lt;br&gt;
cause&amp;nbsp;your&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;stop&amp;nbsp;or&amp;nbsp;resume&amp;nbsp;what&amp;nbsp;it&amp;nbsp;is&amp;nbsp;doing&amp;nbsp;by&amp;nbsp;asking&amp;nbsp;it&amp;nbsp;nicely&lt;br&gt;
rather&amp;nbsp;than&amp;nbsp;by&amp;nbsp;pulling&amp;nbsp;the&amp;nbsp;rug&amp;nbsp;out&amp;nbsp;from&amp;nbsp;under&amp;nbsp;it&amp;nbsp;unexpectedly.&amp;nbsp;The&amp;nbsp;thread&amp;nbsp;examples&lt;br&gt;
in&amp;nbsp;this&amp;nbsp;book&amp;nbsp;use&amp;nbsp;this&amp;nbsp;technique&amp;nbsp;in&amp;nbsp;one&amp;nbsp;way&amp;nbsp;or&amp;nbsp;another.&lt;br&gt;
&lt;br&gt;
===========================================&lt;br&gt;
The&amp;nbsp;sleep()&amp;nbsp;method&lt;br&gt;
We&amp;nbsp;often&amp;nbsp;need&amp;nbsp;to&amp;nbsp;tell&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;sit&amp;nbsp;idle,&amp;nbsp;or&amp;nbsp;“sleep,”&amp;nbsp;for&amp;nbsp;a&amp;nbsp;fixed&amp;nbsp;period&amp;nbsp;of&lt;br&gt;
time.&amp;nbsp;While&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;asleep,&amp;nbsp;or&amp;nbsp;otherwise&amp;nbsp;blocked&amp;nbsp;from&amp;nbsp;input&amp;nbsp;of&amp;nbsp;some&amp;nbsp;kind,&lt;br&gt;
it&amp;nbsp;doesn’t&amp;nbsp;consume&amp;nbsp;CPU&amp;nbsp;time&amp;nbsp;or&amp;nbsp;compete&amp;nbsp;with&amp;nbsp;other&amp;nbsp;threads&amp;nbsp;for&amp;nbsp;processing.&lt;br&gt;
For&amp;nbsp;this,&amp;nbsp;we&amp;nbsp;can&amp;nbsp;call&amp;nbsp;the&amp;nbsp;static&amp;nbsp;method&amp;nbsp;Thread.sleep(),&amp;nbsp;which&amp;nbsp;affects&amp;nbsp;the&amp;nbsp;currently&lt;br&gt;
executing&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;sleep()&amp;nbsp;method&amp;nbsp;may&amp;nbsp;throw&amp;nbsp;an&amp;nbsp;InterruptedException&amp;nbsp;if&amp;nbsp;it&amp;nbsp;is&amp;nbsp;interrupted&lt;br&gt;
by&amp;nbsp;&amp;nbsp;___&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;via&amp;nbsp;the&amp;nbsp;interrupt()&amp;nbsp;method.&amp;nbsp;As&amp;nbsp;you&amp;nbsp;see&amp;nbsp;in&amp;nbsp;the&amp;nbsp;previous&lt;br&gt;
code,&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;catch&amp;nbsp;this&amp;nbsp;exception&amp;nbsp;and&amp;nbsp;take&amp;nbsp;the&amp;nbsp;opportunity&amp;nbsp;to&lt;br&gt;
perform&amp;nbsp;some&amp;nbsp;action—such&amp;nbsp;as&amp;nbsp;checking&amp;nbsp;a&amp;nbsp;variable&amp;nbsp;to&amp;nbsp;determine&amp;nbsp;whether&amp;nbsp;or&amp;nbsp;not&amp;nbsp;it&lt;br&gt;
should&amp;nbsp;exit—or&amp;nbsp;perhaps&amp;nbsp;just&amp;nbsp;perform&amp;nbsp;some&amp;nbsp;housekeeping&amp;nbsp;and&amp;nbsp;then&amp;nbsp;go&amp;nbsp;back&amp;nbsp;to&amp;nbsp;sleep.&lt;br&gt;
&lt;br&gt;
===================================================&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;join()&amp;nbsp;method&lt;br&gt;
&lt;br&gt;
Finally,&amp;nbsp;if&amp;nbsp;you&amp;nbsp;need&amp;nbsp;to&amp;nbsp;coordinate&amp;nbsp;your&amp;nbsp;activities&amp;nbsp;with&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;by&lt;br&gt;
waiting&amp;nbsp;for&amp;nbsp;it&amp;nbsp;to&amp;nbsp;complete&amp;nbsp;its&amp;nbsp;task,&amp;nbsp;you&amp;nbsp;can&amp;nbsp;use&amp;nbsp;the&amp;nbsp;join()&amp;nbsp;method.&amp;nbsp;Calling&amp;nbsp;a&lt;br&gt;
thread’s&amp;nbsp;join()&amp;nbsp;method&amp;nbsp;causes&amp;nbsp;the&amp;nbsp;caller&amp;nbsp;to&amp;nbsp;block&amp;nbsp;until&amp;nbsp;the&amp;nbsp;target&amp;nbsp;thread&lt;br&gt;
completes.&amp;nbsp;Alternatively,&amp;nbsp;you&amp;nbsp;can&amp;nbsp;poll&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;by&amp;nbsp;calling&amp;nbsp;join()&amp;nbsp;with&amp;nbsp;a&lt;br&gt;
number&amp;nbsp;of&amp;nbsp;milliseconds&amp;nbsp;to&amp;nbsp;wait.&amp;nbsp;This&amp;nbsp;is&amp;nbsp;a&amp;nbsp;very&amp;nbsp;coarse&amp;nbsp;form&amp;nbsp;of&amp;nbsp;thread&amp;nbsp;synchronization.&lt;br&gt;
Later&amp;nbsp;in&amp;nbsp;this&amp;nbsp;chapter,&amp;nbsp;we’ll&amp;nbsp;look&amp;nbsp;at&amp;nbsp;a&amp;nbsp;much&amp;nbsp;more&amp;nbsp;general&amp;nbsp;and&amp;nbsp;powerful&lt;br&gt;
mechanism&amp;nbsp;for&amp;nbsp;coordinating&amp;nbsp;thread&amp;nbsp;activity:&amp;nbsp;wait(),&amp;nbsp;notify(),&amp;nbsp;and&amp;nbsp;even&lt;br&gt;
higher-level&amp;nbsp;APIs&amp;nbsp;in&amp;nbsp;the&amp;nbsp;java.util.concurrent&amp;nbsp;package.&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&lt;br&gt;
package&amp;nbsp;simplymultithreadexamples;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ControllingThreadsJoin&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;MyRunnable());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;MyRunnable());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.join();&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;main&amp;nbsp;method(Thread)&amp;nbsp;&amp;nbsp;&amp;nbsp;wait&amp;nbsp;until&amp;nbsp;t1&amp;nbsp;finish&amp;nbsp;it's&amp;nbsp;work&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.join();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("End&amp;nbsp;of&amp;nbsp;main");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;MyRunnable&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Thread&amp;nbsp;started:::"&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;Thread.currentThread().getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(4000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.println("Thread&amp;nbsp;ended:::"&amp;nbsp;+&amp;nbsp;Thread.currentThread().getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Thread&amp;nbsp;started:::Thread-0&lt;br&gt;
Thread&amp;nbsp;ended:::Thread-0&lt;br&gt;
Thread&amp;nbsp;started:::Thread-1&lt;br&gt;
Thread&amp;nbsp;ended:::Thread-1&lt;br&gt;
End&amp;nbsp;of&amp;nbsp;main&lt;br&gt;
&lt;br&gt;
====================================&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;interrupt()&amp;nbsp;method&lt;br&gt;
Earlier,&amp;nbsp;we&amp;nbsp;described&amp;nbsp;the&amp;nbsp;interrupt()&amp;nbsp;method&amp;nbsp;as&amp;nbsp;a&amp;nbsp;way&amp;nbsp;to&amp;nbsp;wake&amp;nbsp;up&amp;nbsp;a&amp;nbsp;thread&lt;br&gt;
that&amp;nbsp;is&amp;nbsp;idle&amp;nbsp;in&amp;nbsp;a&amp;nbsp;sleep(),&amp;nbsp;wait(),&amp;nbsp;or&amp;nbsp;lengthy&amp;nbsp;I/O&amp;nbsp;operation.&amp;nbsp;Any&amp;nbsp;thread&amp;nbsp;that&amp;nbsp;is&lt;br&gt;
not&amp;nbsp;running&amp;nbsp;continuously&amp;nbsp;(not&amp;nbsp;a&amp;nbsp;&amp;nbsp;____&amp;nbsp;“hard&amp;nbsp;loop”)&amp;nbsp;must&amp;nbsp;enter&amp;nbsp;one&amp;nbsp;of&amp;nbsp;these&amp;nbsp;states&lt;br&gt;
periodically&amp;nbsp;and&amp;nbsp;so&amp;nbsp;this&amp;nbsp;is&amp;nbsp;intended&amp;nbsp;to&amp;nbsp;be&amp;nbsp;a&amp;nbsp;point&amp;nbsp;where&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;be&amp;nbsp;flagged&lt;br&gt;
to&amp;nbsp;stop.&amp;nbsp;When&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;interrupted,&amp;nbsp;its&amp;nbsp;interrupt&amp;nbsp;status&amp;nbsp;flag&amp;nbsp;is&amp;nbsp;set.&amp;nbsp;This&amp;nbsp;can&lt;br&gt;
happen&amp;nbsp;at&amp;nbsp;any&amp;nbsp;time,&amp;nbsp;whether&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;idle&amp;nbsp;or&amp;nbsp;not.&amp;nbsp;The&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;test&amp;nbsp;this&lt;br&gt;
status&amp;nbsp;with&amp;nbsp;the&amp;nbsp;isInterrupted()&amp;nbsp;method.&amp;nbsp;is&amp;nbsp;Interrupted(boolean),&amp;nbsp;another&amp;nbsp;form,&lt;br&gt;
accepts&amp;nbsp;a&amp;nbsp;Boolean&amp;nbsp;value&amp;nbsp;indicating&amp;nbsp;whether&amp;nbsp;or&amp;nbsp;not&amp;nbsp;to&amp;nbsp;clear&amp;nbsp;the&amp;nbsp;interrupt&amp;nbsp;status.&lt;br&gt;
In&amp;nbsp;this&amp;nbsp;way,&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;use&amp;nbsp;the&amp;nbsp;interrupt&amp;nbsp;status&amp;nbsp;as&amp;nbsp;a&amp;nbsp;flag&amp;nbsp;and&amp;nbsp;a&amp;nbsp;signal.&lt;br&gt;
&lt;br&gt;
This&amp;nbsp;is&amp;nbsp;indeed&amp;nbsp;the&amp;nbsp;prescribed&amp;nbsp;functionality&amp;nbsp;of&amp;nbsp;the&amp;nbsp;method.&amp;nbsp;However,&amp;nbsp;historically,&lt;br&gt;
this&amp;nbsp;has&amp;nbsp;been&amp;nbsp;a&amp;nbsp;weak&amp;nbsp;spot,&amp;nbsp;and&amp;nbsp;Java&amp;nbsp;implementations&amp;nbsp;have&amp;nbsp;had&amp;nbsp;trouble&amp;nbsp;getting&lt;br&gt;
it&amp;nbsp;to&amp;nbsp;work&amp;nbsp;correctly&amp;nbsp;in&amp;nbsp;all&amp;nbsp;cases.&amp;nbsp;In&amp;nbsp;early&amp;nbsp;Java&amp;nbsp;VMs&amp;nbsp;(prior&amp;nbsp;to&amp;nbsp;version&amp;nbsp;1.1),&amp;nbsp;interrupt&amp;nbsp;did&lt;br&gt;
not&amp;nbsp;work&amp;nbsp;at&amp;nbsp;all.&amp;nbsp;More&amp;nbsp;recent&amp;nbsp;versions&amp;nbsp;still&amp;nbsp;have&amp;nbsp;problems&amp;nbsp;with&amp;nbsp;interrupting&amp;nbsp;I/O&amp;nbsp;calls.&lt;br&gt;
By&amp;nbsp;an&amp;nbsp;I/O&amp;nbsp;call,&amp;nbsp;we&amp;nbsp;mean&amp;nbsp;when&amp;nbsp;an&amp;nbsp;application&amp;nbsp;is&amp;nbsp;blocked&amp;nbsp;in&amp;nbsp;a&amp;nbsp;read()&amp;nbsp;or&amp;nbsp;write()&lt;br&gt;
method,&amp;nbsp;moving&amp;nbsp;bytes&amp;nbsp;to&amp;nbsp;or&amp;nbsp;from&amp;nbsp;a&amp;nbsp;source&amp;nbsp;such&amp;nbsp;as&amp;nbsp;a&amp;nbsp;file&amp;nbsp;or&amp;nbsp;the&amp;nbsp;network.&amp;nbsp;In&amp;nbsp;this&amp;nbsp;case,&lt;br&gt;
Java&amp;nbsp;is&amp;nbsp;supposed&amp;nbsp;to&amp;nbsp;throw&amp;nbsp;an&amp;nbsp;InterruptedIOException&amp;nbsp;when&amp;nbsp;the&amp;nbsp;interrupt()&amp;nbsp;is&amp;nbsp;performed.&lt;br&gt;
However,&amp;nbsp;this&amp;nbsp;has&amp;nbsp;never&amp;nbsp;been&amp;nbsp;reliable&amp;nbsp;across&amp;nbsp;all&amp;nbsp;Java&amp;nbsp;implementations.&amp;nbsp;To&amp;nbsp;address&amp;nbsp;this&lt;br&gt;
in&amp;nbsp;Java&amp;nbsp;1.4,&amp;nbsp;a&amp;nbsp;new&amp;nbsp;I/O&amp;nbsp;framework&amp;nbsp;(java.nio)&amp;nbsp;was&amp;nbsp;introduced&amp;nbsp;with&amp;nbsp;one&amp;nbsp;of&amp;nbsp;its&amp;nbsp;goals&amp;nbsp;being&lt;br&gt;
to&amp;nbsp;specifically&amp;nbsp;address&amp;nbsp;these&amp;nbsp;problems.&amp;nbsp;When&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;associated&amp;nbsp;with&amp;nbsp;an&amp;nbsp;NIO&amp;nbsp;operation&lt;br&gt;
is&amp;nbsp;interrupted,&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;wakes&amp;nbsp;up&amp;nbsp;and&amp;nbsp;the&amp;nbsp;I/O&amp;nbsp;stream&amp;nbsp;(called&amp;nbsp;a&amp;nbsp;“channel”)&lt;br&gt;
is&amp;nbsp;automatically&amp;nbsp;closed.&amp;nbsp;(See&amp;nbsp;Chapter&amp;nbsp;12&amp;nbsp;for&amp;nbsp;more&amp;nbsp;about&amp;nbsp;the&amp;nbsp;NIO&amp;nbsp;package.)&lt;br&gt;
&lt;br&gt;
FROM&amp;nbsp;IBM&amp;nbsp;SITE:&lt;br&gt;
Each&amp;nbsp;THREAD&amp;nbsp;has&amp;nbsp;an&amp;nbsp;associated&amp;nbsp;Boolean&amp;nbsp;property&amp;nbsp;that&amp;nbsp;displays&amp;nbsp;the&amp;nbsp;status&amp;nbsp;of&amp;nbsp;the&amp;nbsp;interrupt.&lt;br&gt;
Interrupt&amp;nbsp;status&amp;nbsp;initially&amp;nbsp;has&amp;nbsp;the&amp;nbsp;value&amp;nbsp;false;&amp;nbsp;when&amp;nbsp;the&amp;nbsp;flow&amp;nbsp;is&amp;nbsp;interrupted&amp;nbsp;by&amp;nbsp;any&amp;nbsp;other&amp;nbsp;thread&lt;br&gt;
by&amp;nbsp;calling&amp;nbsp;Thread.interrupt&amp;nbsp;(),&amp;nbsp;then&amp;nbsp;one&amp;nbsp;of&amp;nbsp;two&amp;nbsp;things&amp;nbsp;happens&amp;nbsp;.&amp;nbsp;If&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;is&lt;br&gt;
interrupted&amp;nbsp;by&amp;nbsp;blocking&amp;nbsp;method&amp;nbsp;performs&amp;nbsp;low&amp;nbsp;level&amp;nbsp;,&amp;nbsp;such&amp;nbsp;as&amp;nbsp;Thread.sleep&amp;nbsp;(),&amp;nbsp;Thread.join&amp;nbsp;()&lt;br&gt;
or&amp;nbsp;Object.wait&amp;nbsp;(),&amp;nbsp;it&amp;nbsp;is&amp;nbsp;unlocked&amp;nbsp;and&amp;nbsp;gives&amp;nbsp;InterruptedException.&amp;nbsp;Otherwise&amp;nbsp;,&amp;nbsp;interrupt&amp;nbsp;()&lt;br&gt;
simply&amp;nbsp;establishes&amp;nbsp;the&amp;nbsp;status&amp;nbsp;of&amp;nbsp;flow&amp;nbsp;interruption&amp;nbsp;.&amp;nbsp;Code,&amp;nbsp;used&amp;nbsp;in&amp;nbsp;the&amp;nbsp;interrupted&amp;nbsp;thread&lt;br&gt;
may&amp;nbsp;later&amp;nbsp;turn&amp;nbsp;to&amp;nbsp;interrupt&amp;nbsp;status&amp;nbsp;to&amp;nbsp;see&amp;nbsp;if&amp;nbsp;there&amp;nbsp;was&amp;nbsp;a&amp;nbsp;request&amp;nbsp;to&amp;nbsp;abort&amp;nbsp;the&amp;nbsp;action;&amp;nbsp;interrupt&lt;br&gt;
status&amp;nbsp;can&amp;nbsp;be&amp;nbsp;read&amp;nbsp;by&amp;nbsp;Thread.isInterrupted&amp;nbsp;(),&amp;nbsp;and&amp;nbsp;can&amp;nbsp;be&amp;nbsp;read&amp;nbsp;and&amp;nbsp;cleared&amp;nbsp;in&amp;nbsp;one&lt;br&gt;
operation&amp;nbsp;using&amp;nbsp;the&amp;nbsp;failed&amp;nbsp;title&amp;nbsp;Thread.interrupted&amp;nbsp;().&lt;br&gt;
&lt;br&gt;
Example&amp;nbsp;:&lt;br&gt;
package&amp;nbsp;simplymultithreadexamples;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ControllingMethodsInterrupt&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;thrd&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;MyThread(),&amp;nbsp;"MyThread&amp;nbsp;#1");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;thrd2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;MyThread(),&amp;nbsp;"MyThread&amp;nbsp;#2");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thrd.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thrd.interrupt();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;MyThread&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"&amp;nbsp;starting.");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;1;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10000;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(Thread.interrupted())&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("interrupted&amp;nbsp;without&amp;nbsp;exception,&amp;nbsp;because&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;didnt&amp;nbsp;sleep&amp;nbsp;in&amp;nbsp;MOMENT&amp;nbsp;WHEN&amp;nbsp;IT&amp;nbsp;WAS&amp;nbsp;'intterrupted&amp;nbsp;'");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.print(".");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(long&amp;nbsp;x&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;x&amp;nbsp;&lt;&amp;nbsp;1000;&amp;nbsp;x++){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Thread.sleep(70);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("/");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(Exception&amp;nbsp;exc)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;"&amp;nbsp;interrupted.&amp;nbsp;Exception");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"&amp;nbsp;exiting.");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
MyThread&amp;nbsp;#1&amp;nbsp;starting.&lt;br&gt;
./&lt;br&gt;
/&lt;br&gt;
/&lt;br&gt;
/&lt;br&gt;
/&lt;br&gt;
/&lt;br&gt;
....&lt;br&gt;
interrupted&amp;nbsp;without&amp;nbsp;exception,&amp;nbsp;because&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;didnt&amp;nbsp;sleep&amp;nbsp;in&amp;nbsp;'intterrupted&amp;nbsp;moment'&lt;br&gt;
MyThread&amp;nbsp;#1&amp;nbsp;exiting.&lt;br&gt;
==========================================&lt;br&gt;
==========================================&lt;br&gt;
&lt;br&gt;
How&amp;nbsp;to&amp;nbsp;properly&amp;nbsp;stop&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;in&amp;nbsp;Java&lt;br&gt;
In&amp;nbsp;the&amp;nbsp;IndexProcessor&amp;nbsp;class&amp;nbsp;you&amp;nbsp;need&amp;nbsp;a&amp;nbsp;way&amp;nbsp;of&amp;nbsp;setting&amp;nbsp;a&amp;nbsp;flag&amp;nbsp;which&amp;nbsp;informs&amp;nbsp;the&amp;nbsp;thread&lt;br&gt;
that&amp;nbsp;it&amp;nbsp;will&amp;nbsp;need&amp;nbsp;to&amp;nbsp;terminate,&amp;nbsp;similar&amp;nbsp;to&amp;nbsp;the&amp;nbsp;variable&amp;nbsp;run&amp;nbsp;that&amp;nbsp;you&amp;nbsp;have&amp;nbsp;used&amp;nbsp;just&amp;nbsp;in&lt;br&gt;
the&amp;nbsp;class&amp;nbsp;scope.&lt;br&gt;
&lt;br&gt;
When&amp;nbsp;you&amp;nbsp;wish&amp;nbsp;to&amp;nbsp;stop&amp;nbsp;the&amp;nbsp;thread,&amp;nbsp;you&amp;nbsp;set&amp;nbsp;this&amp;nbsp;flag&amp;nbsp;and&amp;nbsp;call&amp;nbsp;join()&amp;nbsp;on&amp;nbsp;the&amp;nbsp;thread&lt;br&gt;
and&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;it&amp;nbsp;to&amp;nbsp;finish.&lt;br&gt;
&lt;br&gt;
Make&amp;nbsp;sure&amp;nbsp;that&amp;nbsp;the&amp;nbsp;flag&amp;nbsp;is&amp;nbsp;thread&amp;nbsp;safe&amp;nbsp;by&amp;nbsp;using&amp;nbsp;a&amp;nbsp;volatile&amp;nbsp;variable&amp;nbsp;or&amp;nbsp;by&amp;nbsp;using&amp;nbsp;getter&lt;br&gt;
and&amp;nbsp;setter&amp;nbsp;methods&amp;nbsp;which&amp;nbsp;are&amp;nbsp;synchronised&amp;nbsp;with&amp;nbsp;the&amp;nbsp;variable&amp;nbsp;being&amp;nbsp;used&amp;nbsp;as&amp;nbsp;the&amp;nbsp;flag.&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;IndexProcessor&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;Logger&amp;nbsp;LOGGER&amp;nbsp;=&amp;nbsp;LoggerFactory.getLogger(IndexProcessor.class);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;volatile&amp;nbsp;boolean&amp;nbsp;running&amp;nbsp;=&amp;nbsp;true;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;terminate()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;running&amp;nbsp;=&amp;nbsp;false;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(running)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("Sleeping...");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep((long)&amp;nbsp;15000);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("Processing");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.error("Exception",&amp;nbsp;e);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;running&amp;nbsp;=&amp;nbsp;false;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
==&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;SearchEngineContextListener&amp;nbsp;implements&amp;nbsp;ServletContextListener&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;Logger&amp;nbsp;LOGGER&amp;nbsp;=&amp;nbsp;LoggerFactory.getLogger(SearchEngineContextListener.class);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;Thread&amp;nbsp;thread&amp;nbsp;=&amp;nbsp;null;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;IndexProcessor&amp;nbsp;runnable&amp;nbsp;=&amp;nbsp;null;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;contextInitialized(ServletContextEvent&amp;nbsp;event)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;runnable&amp;nbsp;=&amp;nbsp;new&amp;nbsp;IndexProcessor();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(runnable);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("Starting&amp;nbsp;thread:&amp;nbsp;"&amp;nbsp;+&amp;nbsp;thread);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("Background&amp;nbsp;process&amp;nbsp;successfully&amp;nbsp;started.");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;contextDestroyed(ServletContextEvent&amp;nbsp;event)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("Stopping&amp;nbsp;thread:&amp;nbsp;"&amp;nbsp;+&amp;nbsp;thread);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(thread&amp;nbsp;!=&amp;nbsp;null)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;runnable.terminate();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread.join();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("Thread&amp;nbsp;successfully&amp;nbsp;stopped.");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
=====================================&lt;br&gt;
Death&amp;nbsp;of&amp;nbsp;a&amp;nbsp;Thread&lt;br&gt;
A&amp;nbsp;thread&amp;nbsp;continues&amp;nbsp;to&amp;nbsp;execute&amp;nbsp;until&amp;nbsp;one&amp;nbsp;of&amp;nbsp;the&amp;nbsp;following&amp;nbsp;happens:&lt;br&gt;
-&amp;nbsp;It&amp;nbsp;explicitly&amp;nbsp;returns&amp;nbsp;from&amp;nbsp;its&amp;nbsp;target&amp;nbsp;run()&amp;nbsp;method.&lt;br&gt;
-&amp;nbsp;It&amp;nbsp;encounters&amp;nbsp;an&amp;nbsp;uncaught&amp;nbsp;runtime&amp;nbsp;exception.&lt;br&gt;
-&amp;nbsp;The&amp;nbsp;evil&amp;nbsp;and&amp;nbsp;nasty&amp;nbsp;deprecated&amp;nbsp;stop()&amp;nbsp;method&amp;nbsp;is&amp;nbsp;called.&lt;br&gt;
&lt;br&gt;
What&amp;nbsp;happens&amp;nbsp;if&amp;nbsp;none&amp;nbsp;of&amp;nbsp;these&amp;nbsp;things&amp;nbsp;occurs,&amp;nbsp;and&amp;nbsp;the&amp;nbsp;run()&amp;nbsp;method&lt;br&gt;
for&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;never&amp;nbsp;terminates?&amp;nbsp;The&amp;nbsp;answer&amp;nbsp;is&amp;nbsp;that&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;live&amp;nbsp;on,&amp;nbsp;even&lt;br&gt;
after&amp;nbsp;what&amp;nbsp;is&amp;nbsp;ostensibly&amp;nbsp;the&amp;nbsp;part&amp;nbsp;of&amp;nbsp;the&amp;nbsp;application&amp;nbsp;that&amp;nbsp;created&amp;nbsp;it&amp;nbsp;has&amp;nbsp;finished.&lt;br&gt;
This&amp;nbsp;means&amp;nbsp;we&amp;nbsp;have&amp;nbsp;to&amp;nbsp;be&amp;nbsp;aware&amp;nbsp;of&amp;nbsp;how&amp;nbsp;our&amp;nbsp;threads&amp;nbsp;eventually&amp;nbsp;terminate,&amp;nbsp;or&amp;nbsp;an&lt;br&gt;
application&amp;nbsp;can&amp;nbsp;end&amp;nbsp;up&amp;nbsp;leaving&amp;nbsp;orphaned&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;unnecessarily&amp;nbsp;consume&amp;nbsp;resources&lt;br&gt;
or&amp;nbsp;keep&amp;nbsp;the&amp;nbsp;application&amp;nbsp;alive&amp;nbsp;when&amp;nbsp;it&amp;nbsp;would&amp;nbsp;otherwise&amp;nbsp;quit.&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;many&amp;nbsp;cases,&amp;nbsp;we&amp;nbsp;really&amp;nbsp;want&amp;nbsp;to&amp;nbsp;create&amp;nbsp;background&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;do&amp;nbsp;simple,&lt;br&gt;
periodic&amp;nbsp;tasks&amp;nbsp;in&amp;nbsp;an&amp;nbsp;application.&amp;nbsp;The&amp;nbsp;setDaemon()&amp;nbsp;method&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;mark&lt;br&gt;
a&amp;nbsp;thread&amp;nbsp;as&amp;nbsp;a&amp;nbsp;___&amp;nbsp;daemon&amp;nbsp;thread&amp;nbsp;that&amp;nbsp;should&amp;nbsp;be&amp;nbsp;killed&amp;nbsp;and&amp;nbsp;discarded&amp;nbsp;when&amp;nbsp;no&amp;nbsp;other&amp;nbsp;__&lt;br&gt;
nondaemon&amp;nbsp;application&amp;nbsp;threads&amp;nbsp;remain.&amp;nbsp;Normally,&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;interpreter&amp;nbsp;continues&lt;br&gt;
to&amp;nbsp;run&amp;nbsp;until&amp;nbsp;all&amp;nbsp;threads&amp;nbsp;have&amp;nbsp;completed.&amp;nbsp;But&amp;nbsp;when&amp;nbsp;daemon&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;the&lt;br&gt;
only&amp;nbsp;threads&amp;nbsp;still&amp;nbsp;alive,&amp;nbsp;the&amp;nbsp;interpreter&amp;nbsp;will&amp;nbsp;exit.&lt;br&gt;
Here’s&amp;nbsp;a&amp;nbsp;devilish&amp;nbsp;example&amp;nbsp;using&amp;nbsp;daemon&amp;nbsp;threads:&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Devil&amp;nbsp;extends&amp;nbsp;Thread&amp;nbsp;{&lt;br&gt;
&amp;nbsp;Devil()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;setDaemon(&amp;nbsp;true&amp;nbsp;);&lt;br&gt;
&amp;nbsp;start();&lt;br&gt;
}&lt;br&gt;
public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;//&amp;nbsp;perform&amp;nbsp;evil&amp;nbsp;tasks&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
In&amp;nbsp;this&amp;nbsp;example,&amp;nbsp;the&amp;nbsp;Devil&amp;nbsp;thread&amp;nbsp;sets&amp;nbsp;its&amp;nbsp;daemon&amp;nbsp;status&amp;nbsp;when&amp;nbsp;it&amp;nbsp;is&amp;nbsp;created.&lt;br&gt;
If&amp;nbsp;any&amp;nbsp;Devil&amp;nbsp;threads&amp;nbsp;remain&amp;nbsp;when&amp;nbsp;our&amp;nbsp;application&amp;nbsp;is&amp;nbsp;otherwise&amp;nbsp;complete,&amp;nbsp;the&lt;br&gt;
runtime&amp;nbsp;system&amp;nbsp;kills&amp;nbsp;them&amp;nbsp;for&amp;nbsp;us.&amp;nbsp;We&amp;nbsp;don’t&amp;nbsp;have&amp;nbsp;to&amp;nbsp;worry&amp;nbsp;about&amp;nbsp;cleaning&amp;nbsp;them&amp;nbsp;up.&lt;br&gt;
&lt;br&gt;
Daemon&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;primarily&amp;nbsp;useful&amp;nbsp;in&amp;nbsp;standalone&amp;nbsp;Java&amp;nbsp;applications&amp;nbsp;and&amp;nbsp;in&amp;nbsp;the&lt;br&gt;
implementation&amp;nbsp;of&amp;nbsp;server&amp;nbsp;frameworks,&amp;nbsp;but&amp;nbsp;not&amp;nbsp;in&amp;nbsp;component&amp;nbsp;applications&amp;nbsp;such&lt;br&gt;
as&amp;nbsp;applets.&amp;nbsp;Since&amp;nbsp;an&amp;nbsp;applet&amp;nbsp;runs&amp;nbsp;inside&amp;nbsp;another&amp;nbsp;Java&amp;nbsp;application,&amp;nbsp;any&amp;nbsp;daemon&lt;br&gt;
threads&amp;nbsp;it&amp;nbsp;creates&amp;nbsp;can&amp;nbsp;continue&amp;nbsp;to&amp;nbsp;live&amp;nbsp;until&amp;nbsp;the&amp;nbsp;controlling&amp;nbsp;application&amp;nbsp;exits—probably&lt;br&gt;
not&amp;nbsp;the&amp;nbsp;desired&amp;nbsp;effect.&lt;br&gt;
A&amp;nbsp;browser&amp;nbsp;or&amp;nbsp;any&amp;nbsp;other&amp;nbsp;application&amp;nbsp;can&amp;nbsp;use&amp;nbsp;ThreadGroups&amp;nbsp;to&amp;nbsp;contain&amp;nbsp;all&amp;nbsp;the&amp;nbsp;threads&lt;br&gt;
created&amp;nbsp;by&amp;nbsp;subsystems&amp;nbsp;of&amp;nbsp;an&amp;nbsp;application&amp;nbsp;and&amp;nbsp;then&amp;nbsp;clean&amp;nbsp;them&amp;nbsp;up&amp;nbsp;if&amp;nbsp;necessary&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:2" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;list&amp;nbsp;useful&amp;nbsp;methods&amp;nbsp;in&amp;nbsp;java.lang.Thread&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>Constructor&amp;nbsp;Summary&lt;br&gt;
&lt;br&gt;
Constructor&amp;nbsp;and&amp;nbsp;Description&lt;br&gt;
-&amp;nbsp;Thread()&lt;br&gt;
Allocates&amp;nbsp;a&amp;nbsp;new&amp;nbsp;Thread&amp;nbsp;object.&lt;br&gt;
-&amp;nbsp;Thread(Runnable&amp;nbsp;target)&lt;br&gt;
Allocates&amp;nbsp;a&amp;nbsp;new&amp;nbsp;Thread&amp;nbsp;object.&lt;br&gt;
-&amp;nbsp;Thread(Runnable&amp;nbsp;target,&amp;nbsp;String&amp;nbsp;name)&lt;br&gt;
Allocates&amp;nbsp;a&amp;nbsp;new&amp;nbsp;Thread&amp;nbsp;object.&lt;br&gt;
-&amp;nbsp;Thread(String&amp;nbsp;name)&lt;br&gt;
Allocates&amp;nbsp;a&amp;nbsp;new&amp;nbsp;Thread&amp;nbsp;object.&lt;br&gt;
-&amp;nbsp;Thread(ThreadGroup&amp;nbsp;group,&amp;nbsp;Runnable&amp;nbsp;target)&lt;br&gt;
Allocates&amp;nbsp;a&amp;nbsp;new&amp;nbsp;Thread&amp;nbsp;object.&lt;br&gt;
-&amp;nbsp;Thread(ThreadGroup&amp;nbsp;group,&amp;nbsp;Runnable&amp;nbsp;target,&amp;nbsp;String&amp;nbsp;name)&lt;br&gt;
Allocates&amp;nbsp;a&amp;nbsp;new&amp;nbsp;Thread&amp;nbsp;object&amp;nbsp;so&amp;nbsp;that&amp;nbsp;it&amp;nbsp;has&amp;nbsp;target&amp;nbsp;as&amp;nbsp;its&amp;nbsp;run&amp;nbsp;object,&amp;nbsp;has&lt;br&gt;
the&amp;nbsp;specified&amp;nbsp;name&amp;nbsp;as&amp;nbsp;its&amp;nbsp;name,&amp;nbsp;and&amp;nbsp;belongs&amp;nbsp;to&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;referred&amp;nbsp;to&amp;nbsp;by&amp;nbsp;group.&lt;br&gt;
-&amp;nbsp;Thread(ThreadGroup&amp;nbsp;group,&amp;nbsp;Runnable&amp;nbsp;target,&amp;nbsp;String&amp;nbsp;name,&amp;nbsp;long&amp;nbsp;stackSize)&lt;br&gt;
Allocates&amp;nbsp;a&amp;nbsp;new&amp;nbsp;Thread&amp;nbsp;object&amp;nbsp;so&amp;nbsp;that&amp;nbsp;it&amp;nbsp;has&amp;nbsp;target&amp;nbsp;as&amp;nbsp;its&amp;nbsp;run&amp;nbsp;object,&amp;nbsp;has&amp;nbsp;the&lt;br&gt;
specified&amp;nbsp;name&amp;nbsp;as&amp;nbsp;its&amp;nbsp;name,&amp;nbsp;and&amp;nbsp;belongs&amp;nbsp;to&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;referred&amp;nbsp;to&amp;nbsp;by&amp;nbsp;group,&amp;nbsp;and&lt;br&gt;
has&amp;nbsp;the&amp;nbsp;specified&amp;nbsp;stack&amp;nbsp;size.&lt;br&gt;
-&amp;nbsp;Thread(ThreadGroup&amp;nbsp;group,&amp;nbsp;String&amp;nbsp;name)&lt;br&gt;
Allocates&amp;nbsp;a&amp;nbsp;new&amp;nbsp;Thread&amp;nbsp;object.&lt;br&gt;
&lt;br&gt;
================================&lt;br&gt;
================================&lt;br&gt;
Method&amp;nbsp;Summary&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Modifier&amp;nbsp;and&amp;nbsp;Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Method&amp;nbsp;and&amp;nbsp;Description&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;activeCount()&lt;br&gt;
Returns&amp;nbsp;an&amp;nbsp;estimate&amp;nbsp;of&amp;nbsp;the&amp;nbsp;number&amp;nbsp;of&amp;nbsp;active&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread's&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;and&amp;nbsp;its&amp;nbsp;subgroups.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkAccess()&lt;br&gt;
Determines&amp;nbsp;if&amp;nbsp;the&amp;nbsp;currently&amp;nbsp;running&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;permission&amp;nbsp;to&amp;nbsp;modify&amp;nbsp;this&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;protected&amp;nbsp;Object&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;clone()&lt;br&gt;
Throws&amp;nbsp;CloneNotSupportedException&amp;nbsp;as&amp;nbsp;a&amp;nbsp;Thread&amp;nbsp;can&amp;nbsp;not&amp;nbsp;be&amp;nbsp;meaningfully&amp;nbsp;cloned.&lt;br&gt;
-&amp;nbsp;int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;countStackFrames()&lt;br&gt;
Deprecated.&amp;nbsp;&lt;br&gt;
The&amp;nbsp;definition&amp;nbsp;of&amp;nbsp;this&amp;nbsp;call&amp;nbsp;depends&amp;nbsp;on&amp;nbsp;suspend(),&amp;nbsp;which&amp;nbsp;is&amp;nbsp;deprecated.&amp;nbsp;Further,&amp;nbsp;the&amp;nbsp;results&amp;nbsp;of&amp;nbsp;this&amp;nbsp;call&amp;nbsp;were&amp;nbsp;never&amp;nbsp;well-defined.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;Thread&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;currentThread()&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;reference&amp;nbsp;to&amp;nbsp;the&amp;nbsp;currently&amp;nbsp;executing&amp;nbsp;thread&amp;nbsp;object.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;destroy()&lt;br&gt;
Deprecated.&amp;nbsp;&lt;br&gt;
This&amp;nbsp;method&amp;nbsp;was&amp;nbsp;originally&amp;nbsp;designed&amp;nbsp;to&amp;nbsp;destroy&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;without&amp;nbsp;any&amp;nbsp;cleanup.&amp;nbsp;Any&lt;br&gt;
monitors&amp;nbsp;it&amp;nbsp;held&amp;nbsp;would&amp;nbsp;have&amp;nbsp;remained&amp;nbsp;locked.&amp;nbsp;However,&amp;nbsp;the&amp;nbsp;method&amp;nbsp;was&amp;nbsp;never&lt;br&gt;
implemented.&amp;nbsp;If&amp;nbsp;if&amp;nbsp;were&amp;nbsp;to&amp;nbsp;be&amp;nbsp;implemented,&amp;nbsp;it&amp;nbsp;would&amp;nbsp;be&amp;nbsp;deadlock-prone&amp;nbsp;in&amp;nbsp;much&amp;nbsp;the&lt;br&gt;
manner&amp;nbsp;of&amp;nbsp;suspend().&amp;nbsp;If&amp;nbsp;the&amp;nbsp;target&amp;nbsp;thread&amp;nbsp;held&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;protecting&amp;nbsp;a&amp;nbsp;critical&amp;nbsp;system&lt;br&gt;
resource&amp;nbsp;when&amp;nbsp;it&amp;nbsp;was&amp;nbsp;destroyed,&amp;nbsp;no&amp;nbsp;thread&amp;nbsp;could&amp;nbsp;ever&amp;nbsp;access&amp;nbsp;this&amp;nbsp;resource&amp;nbsp;again.&lt;br&gt;
If&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;ever&amp;nbsp;attempted&amp;nbsp;to&amp;nbsp;lock&amp;nbsp;this&amp;nbsp;resource,&amp;nbsp;deadlock&amp;nbsp;would&amp;nbsp;result.&amp;nbsp;Such&lt;br&gt;
deadlocks&amp;nbsp;typically&amp;nbsp;manifest&amp;nbsp;themselves&amp;nbsp;as&amp;nbsp;"frozen"&amp;nbsp;processes.&amp;nbsp;For&amp;nbsp;more&amp;nbsp;information,&lt;br&gt;
see&amp;nbsp;Why&amp;nbsp;are&amp;nbsp;Thread.stop,&amp;nbsp;Thread.suspend&amp;nbsp;and&amp;nbsp;Thread.resume&amp;nbsp;Deprecated?.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dumpStack()&lt;br&gt;
Prints&amp;nbsp;a&amp;nbsp;stack&amp;nbsp;trace&amp;nbsp;of&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;the&amp;nbsp;standard&amp;nbsp;error&amp;nbsp;stream.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;enumerate(Thread[]&amp;nbsp;tarray)&lt;br&gt;
Copies&amp;nbsp;into&amp;nbsp;the&amp;nbsp;specified&amp;nbsp;array&amp;nbsp;every&amp;nbsp;active&amp;nbsp;thread&amp;nbsp;in&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread's&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;and&amp;nbsp;its&amp;nbsp;subgroups.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;Map&lt;Thread,StackTraceElement[]&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getAllStackTraces()&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;map&amp;nbsp;of&amp;nbsp;stack&amp;nbsp;traces&amp;nbsp;for&amp;nbsp;all&amp;nbsp;live&amp;nbsp;threads.&lt;br&gt;
-&amp;nbsp;ClassLoader&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getContextClassLoader()&lt;br&gt;
Returns&amp;nbsp;the&amp;nbsp;context&amp;nbsp;ClassLoader&amp;nbsp;for&amp;nbsp;this&amp;nbsp;Thread.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;Thread.UncaughtExceptionHandler&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getDefaultUncaughtExceptionHandler()&lt;br&gt;
Returns&amp;nbsp;the&amp;nbsp;default&amp;nbsp;handler&amp;nbsp;invoked&amp;nbsp;when&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;abruptly&amp;nbsp;terminates&amp;nbsp;due&amp;nbsp;to&amp;nbsp;an&amp;nbsp;uncaught&amp;nbsp;exception.&lt;br&gt;
-&amp;nbsp;long&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getId()&lt;br&gt;
Returns&amp;nbsp;the&amp;nbsp;identifier&amp;nbsp;of&amp;nbsp;this&amp;nbsp;Thread.&lt;br&gt;
-&amp;nbsp;String&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getName()&lt;br&gt;
Returns&amp;nbsp;this&amp;nbsp;thread's&amp;nbsp;name.&lt;br&gt;
-&amp;nbsp;int&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getPriority()&lt;br&gt;
Returns&amp;nbsp;this&amp;nbsp;thread's&amp;nbsp;priority.&lt;br&gt;
-&amp;nbsp;StackTraceElement[]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getStackTrace()&lt;br&gt;
Returns&amp;nbsp;an&amp;nbsp;array&amp;nbsp;of&amp;nbsp;stack&amp;nbsp;trace&amp;nbsp;elements&amp;nbsp;representing&amp;nbsp;the&amp;nbsp;stack&amp;nbsp;dump&amp;nbsp;of&amp;nbsp;this&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;Thread.State&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getState()&lt;br&gt;
Returns&amp;nbsp;the&amp;nbsp;state&amp;nbsp;of&amp;nbsp;this&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;ThreadGroup&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getThreadGroup()&lt;br&gt;
Returns&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;to&amp;nbsp;which&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;belongs.&lt;br&gt;
-&amp;nbsp;Thread.UncaughtExceptionHandler&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getUncaughtExceptionHandler()&lt;br&gt;
Returns&amp;nbsp;the&amp;nbsp;handler&amp;nbsp;invoked&amp;nbsp;when&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;abruptly&amp;nbsp;terminates&amp;nbsp;due&amp;nbsp;to&amp;nbsp;an&amp;nbsp;uncaught&amp;nbsp;exception.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;boolean&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;holdsLock(Object&amp;nbsp;obj)&lt;br&gt;
Returns&amp;nbsp;true&amp;nbsp;if&amp;nbsp;and&amp;nbsp;only&amp;nbsp;if&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;holds&amp;nbsp;the&amp;nbsp;monitor&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;the&amp;nbsp;specified&amp;nbsp;object.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;interrupt()&lt;br&gt;
Interrupts&amp;nbsp;this&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;boolean&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;interrupted()&lt;br&gt;
Tests&amp;nbsp;whether&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;been&amp;nbsp;interrupted.&lt;br&gt;
-&amp;nbsp;boolean&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;isAlive()&lt;br&gt;
Tests&amp;nbsp;if&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;alive.&lt;br&gt;
-&amp;nbsp;boolean&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;isDaemon()&lt;br&gt;
Tests&amp;nbsp;if&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;a&amp;nbsp;daemon&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;boolean&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;isInterrupted()&lt;br&gt;
Tests&amp;nbsp;whether&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;been&amp;nbsp;interrupted.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;join()&lt;br&gt;
Waits&amp;nbsp;for&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;die.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;join(long&amp;nbsp;millis)&lt;br&gt;
Waits&amp;nbsp;at&amp;nbsp;most&amp;nbsp;millis&amp;nbsp;milliseconds&amp;nbsp;for&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;die.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;join(long&amp;nbsp;millis,&amp;nbsp;int&amp;nbsp;nanos)&lt;br&gt;
Waits&amp;nbsp;at&amp;nbsp;most&amp;nbsp;millis&amp;nbsp;milliseconds&amp;nbsp;plus&amp;nbsp;nanos&amp;nbsp;nanoseconds&amp;nbsp;for&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;die.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resume()&lt;br&gt;
Deprecated.&amp;nbsp;&lt;br&gt;
This&amp;nbsp;method&amp;nbsp;exists&amp;nbsp;solely&amp;nbsp;for&amp;nbsp;use&amp;nbsp;with&amp;nbsp;suspend(),&amp;nbsp;which&amp;nbsp;has&amp;nbsp;been&amp;nbsp;deprecated&amp;nbsp;because&lt;br&gt;
it&amp;nbsp;is&amp;nbsp;deadlock-prone.&amp;nbsp;For&amp;nbsp;more&amp;nbsp;information,&amp;nbsp;see&amp;nbsp;Why&amp;nbsp;are&amp;nbsp;Thread.stop,&amp;nbsp;Thread.suspend&lt;br&gt;
and&amp;nbsp;Thread.resume&amp;nbsp;Deprecated?.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;run()&lt;br&gt;
If&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;was&amp;nbsp;constructed&amp;nbsp;using&amp;nbsp;a&amp;nbsp;separate&amp;nbsp;Runnable&amp;nbsp;run&amp;nbsp;object,&amp;nbsp;then&amp;nbsp;that&amp;nbsp;Runnable&lt;br&gt;
object's&amp;nbsp;run&amp;nbsp;method&amp;nbsp;is&amp;nbsp;called;&amp;nbsp;otherwise,&amp;nbsp;this&amp;nbsp;method&amp;nbsp;does&amp;nbsp;nothing&amp;nbsp;and&amp;nbsp;returns.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setContextClassLoader(ClassLoader&amp;nbsp;cl)&lt;br&gt;
Sets&amp;nbsp;the&amp;nbsp;context&amp;nbsp;ClassLoader&amp;nbsp;for&amp;nbsp;this&amp;nbsp;Thread.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setDaemon(boolean&amp;nbsp;on)&lt;br&gt;
Marks&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;as&amp;nbsp;either&amp;nbsp;a&amp;nbsp;daemon&amp;nbsp;thread&amp;nbsp;or&amp;nbsp;a&amp;nbsp;user&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler&amp;nbsp;eh)&lt;br&gt;
Set&amp;nbsp;the&amp;nbsp;default&amp;nbsp;handler&amp;nbsp;invoked&amp;nbsp;when&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;abruptly&amp;nbsp;terminates&amp;nbsp;due&amp;nbsp;to&amp;nbsp;an&amp;nbsp;uncaught&amp;nbsp;exception,&lt;br&gt;
and&amp;nbsp;no&amp;nbsp;other&amp;nbsp;handler&amp;nbsp;has&amp;nbsp;been&amp;nbsp;defined&amp;nbsp;for&amp;nbsp;that&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setName(String&amp;nbsp;name)&lt;br&gt;
Changes&amp;nbsp;the&amp;nbsp;name&amp;nbsp;of&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;be&amp;nbsp;equal&amp;nbsp;to&amp;nbsp;the&amp;nbsp;argument&amp;nbsp;name.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setPriority(int&amp;nbsp;newPriority)&lt;br&gt;
Changes&amp;nbsp;the&amp;nbsp;priority&amp;nbsp;of&amp;nbsp;this&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler&amp;nbsp;eh)&lt;br&gt;
Set&amp;nbsp;the&amp;nbsp;handler&amp;nbsp;invoked&amp;nbsp;when&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;abruptly&amp;nbsp;terminates&amp;nbsp;due&amp;nbsp;to&amp;nbsp;an&amp;nbsp;uncaught&amp;nbsp;exception.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep(long&amp;nbsp;millis)&lt;br&gt;
Causes&amp;nbsp;the&amp;nbsp;currently&amp;nbsp;executing&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;sleep&amp;nbsp;(temporarily&amp;nbsp;cease&amp;nbsp;execution)&amp;nbsp;for&amp;nbsp;the&amp;nbsp;specified&lt;br&gt;
number&amp;nbsp;of&amp;nbsp;milliseconds,&amp;nbsp;subject&amp;nbsp;to&amp;nbsp;the&amp;nbsp;precision&amp;nbsp;and&amp;nbsp;accuracy&amp;nbsp;of&amp;nbsp;system&amp;nbsp;timers&amp;nbsp;and&amp;nbsp;schedulers.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep(long&amp;nbsp;millis,&amp;nbsp;int&amp;nbsp;nanos)&lt;br&gt;
Causes&amp;nbsp;the&amp;nbsp;currently&amp;nbsp;executing&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;sleep&amp;nbsp;(temporarily&amp;nbsp;cease&amp;nbsp;execution)&amp;nbsp;for&amp;nbsp;the&amp;nbsp;specified&lt;br&gt;
number&amp;nbsp;of&amp;nbsp;milliseconds&amp;nbsp;plus&amp;nbsp;the&amp;nbsp;specified&amp;nbsp;number&amp;nbsp;of&amp;nbsp;nanoseconds,&amp;nbsp;subject&amp;nbsp;to&amp;nbsp;the&amp;nbsp;precision&amp;nbsp;and&lt;br&gt;
accuracy&amp;nbsp;of&amp;nbsp;system&amp;nbsp;timers&amp;nbsp;and&amp;nbsp;schedulers.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;start()&lt;br&gt;
Causes&amp;nbsp;this&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;begin&amp;nbsp;execution;&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;Virtual&amp;nbsp;Machine&amp;nbsp;calls&amp;nbsp;the&amp;nbsp;run&amp;nbsp;method&amp;nbsp;of&amp;nbsp;this&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stop()&lt;br&gt;
Deprecated.&amp;nbsp;&lt;br&gt;
This&amp;nbsp;method&amp;nbsp;is&amp;nbsp;inherently&amp;nbsp;unsafe.&amp;nbsp;Stopping&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;with&amp;nbsp;Thread.stop&amp;nbsp;causes&amp;nbsp;it&amp;nbsp;to&amp;nbsp;unlock&amp;nbsp;all&amp;nbsp;of&amp;nbsp;the&lt;br&gt;
monitors&amp;nbsp;that&amp;nbsp;it&amp;nbsp;has&amp;nbsp;locked&amp;nbsp;(as&amp;nbsp;a&amp;nbsp;natural&amp;nbsp;consequence&amp;nbsp;of&amp;nbsp;the&amp;nbsp;unchecked&amp;nbsp;ThreadDeath&amp;nbsp;exception&lt;br&gt;
propagating&amp;nbsp;up&amp;nbsp;the&amp;nbsp;stack).&amp;nbsp;If&amp;nbsp;any&amp;nbsp;of&amp;nbsp;the&amp;nbsp;objects&amp;nbsp;previously&amp;nbsp;protected&amp;nbsp;by&amp;nbsp;these&amp;nbsp;monitors&lt;br&gt;
were&amp;nbsp;in&amp;nbsp;an&amp;nbsp;inconsistent&amp;nbsp;state,&amp;nbsp;the&amp;nbsp;damaged&amp;nbsp;objects&amp;nbsp;become&amp;nbsp;visible&amp;nbsp;to&amp;nbsp;other&amp;nbsp;threads,&lt;br&gt;
potentially&amp;nbsp;resulting&amp;nbsp;in&amp;nbsp;arbitrary&amp;nbsp;behavior.&amp;nbsp;Many&amp;nbsp;uses&amp;nbsp;of&amp;nbsp;stop&amp;nbsp;should&amp;nbsp;be&amp;nbsp;replaced&amp;nbsp;by&amp;nbsp;code&amp;nbsp;that&lt;br&gt;
simply&amp;nbsp;modifies&amp;nbsp;some&amp;nbsp;variable&amp;nbsp;to&amp;nbsp;indicate&amp;nbsp;that&amp;nbsp;the&amp;nbsp;target&amp;nbsp;thread&amp;nbsp;should&amp;nbsp;stop&amp;nbsp;running.&amp;nbsp;The&lt;br&gt;
target&amp;nbsp;thread&amp;nbsp;should&amp;nbsp;check&amp;nbsp;this&amp;nbsp;variable&amp;nbsp;regularly,&amp;nbsp;and&amp;nbsp;return&amp;nbsp;from&amp;nbsp;its&amp;nbsp;run&amp;nbsp;method&amp;nbsp;in&amp;nbsp;an&lt;br&gt;
orderly&amp;nbsp;fashion&amp;nbsp;if&amp;nbsp;the&amp;nbsp;variable&amp;nbsp;indicates&amp;nbsp;that&amp;nbsp;it&amp;nbsp;is&amp;nbsp;to&amp;nbsp;stop&amp;nbsp;running.&amp;nbsp;If&amp;nbsp;the&amp;nbsp;target&amp;nbsp;thread&amp;nbsp;waits&lt;br&gt;
for&amp;nbsp;long&amp;nbsp;periods&amp;nbsp;(on&amp;nbsp;a&amp;nbsp;condition&amp;nbsp;variable,&amp;nbsp;for&amp;nbsp;example),&amp;nbsp;the&amp;nbsp;interrupt&amp;nbsp;method&amp;nbsp;should&amp;nbsp;be&lt;br&gt;
used&amp;nbsp;to&amp;nbsp;interrupt&amp;nbsp;the&amp;nbsp;wait.&amp;nbsp;For&amp;nbsp;more&amp;nbsp;information,&amp;nbsp;see&amp;nbsp;Why&amp;nbsp;are&amp;nbsp;Thread.stop,&lt;br&gt;
Thread.suspend&amp;nbsp;and&amp;nbsp;Thread.resume&amp;nbsp;Deprecated?.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stop(Throwable&amp;nbsp;obj)&lt;br&gt;
Deprecated.&amp;nbsp;&lt;br&gt;
This&amp;nbsp;method&amp;nbsp;is&amp;nbsp;inherently&amp;nbsp;unsafe.&amp;nbsp;See&amp;nbsp;stop()&amp;nbsp;for&amp;nbsp;details.&amp;nbsp;An&amp;nbsp;additional&amp;nbsp;danger&amp;nbsp;of&amp;nbsp;this&lt;br&gt;
method&amp;nbsp;is&amp;nbsp;that&amp;nbsp;it&amp;nbsp;may&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;generate&amp;nbsp;exceptions&amp;nbsp;that&amp;nbsp;the&amp;nbsp;target&amp;nbsp;thread&lt;br&gt;
is&amp;nbsp;unprepared&amp;nbsp;to&amp;nbsp;handle&amp;nbsp;(including&amp;nbsp;checked&amp;nbsp;exceptions&amp;nbsp;that&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;could&lt;br&gt;
not&amp;nbsp;possibly&amp;nbsp;throw,&amp;nbsp;were&amp;nbsp;it&amp;nbsp;not&amp;nbsp;for&amp;nbsp;this&amp;nbsp;method).&amp;nbsp;For&amp;nbsp;more&amp;nbsp;information,&amp;nbsp;see&amp;nbsp;Why&lt;br&gt;
are&amp;nbsp;Thread.stop,&amp;nbsp;Thread.suspend&amp;nbsp;and&amp;nbsp;Thread.resume&amp;nbsp;Deprecated?.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;suspend()&lt;br&gt;
Deprecated.&amp;nbsp;&lt;br&gt;
This&amp;nbsp;method&amp;nbsp;has&amp;nbsp;been&amp;nbsp;deprecated,&amp;nbsp;as&amp;nbsp;it&amp;nbsp;is&amp;nbsp;inherently&amp;nbsp;deadlock-prone.&amp;nbsp;If&amp;nbsp;the&amp;nbsp;target&amp;nbsp;thread&lt;br&gt;
holds&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;the&amp;nbsp;monitor&amp;nbsp;protecting&amp;nbsp;a&amp;nbsp;critical&amp;nbsp;system&amp;nbsp;resource&amp;nbsp;when&amp;nbsp;it&amp;nbsp;is&amp;nbsp;suspended,&lt;br&gt;
no&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;access&amp;nbsp;this&amp;nbsp;resource&amp;nbsp;until&amp;nbsp;the&amp;nbsp;target&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;resumed.&amp;nbsp;If&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;that&lt;br&gt;
would&amp;nbsp;resume&amp;nbsp;the&amp;nbsp;target&amp;nbsp;thread&amp;nbsp;attempts&amp;nbsp;to&amp;nbsp;lock&amp;nbsp;this&amp;nbsp;monitor&amp;nbsp;prior&amp;nbsp;to&amp;nbsp;calling&amp;nbsp;resume,&lt;br&gt;
deadlock&amp;nbsp;results.&amp;nbsp;Such&amp;nbsp;deadlocks&amp;nbsp;typically&amp;nbsp;manifest&amp;nbsp;themselves&amp;nbsp;as&amp;nbsp;"frozen"&amp;nbsp;processes.&lt;br&gt;
For&amp;nbsp;more&amp;nbsp;information,&amp;nbsp;see&amp;nbsp;Why&amp;nbsp;are&amp;nbsp;Thread.stop,&amp;nbsp;Thread.suspend&amp;nbsp;and&amp;nbsp;Thread.resume&lt;br&gt;
Deprecated?.&lt;br&gt;
-&amp;nbsp;String&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;toString()&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;string&amp;nbsp;representation&amp;nbsp;of&amp;nbsp;this&amp;nbsp;thread,&amp;nbsp;including&amp;nbsp;the&amp;nbsp;thread's&amp;nbsp;name,&lt;br&gt;
priority,&amp;nbsp;and&amp;nbsp;thread&amp;nbsp;group.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;yield()&lt;br&gt;
A&amp;nbsp;hint&amp;nbsp;to&amp;nbsp;the&amp;nbsp;scheduler&amp;nbsp;that&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;willing&amp;nbsp;to&amp;nbsp;yield&amp;nbsp;its&amp;nbsp;current&amp;nbsp;use&amp;nbsp;of&amp;nbsp;a&amp;nbsp;processor.&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:3" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Synchronization,&amp;nbsp;describe.&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;lock&amp;nbsp;?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>Java&amp;nbsp;provides&amp;nbsp;a&amp;nbsp;few&amp;nbsp;simple&amp;nbsp;structures&amp;nbsp;for&amp;nbsp;synchronizing&amp;nbsp;the&amp;nbsp;activities&amp;nbsp;of&amp;nbsp;threads.&lt;br&gt;
They&amp;nbsp;are&amp;nbsp;all&amp;nbsp;based&amp;nbsp;on&amp;nbsp;the&amp;nbsp;__&amp;nbsp;concept&amp;nbsp;of&amp;nbsp;monitors&amp;nbsp;__,&amp;nbsp;a&amp;nbsp;widely&amp;nbsp;used&amp;nbsp;synchronization&lt;br&gt;
scheme.&amp;nbsp;You&amp;nbsp;don’t&amp;nbsp;have&amp;nbsp;to&amp;nbsp;know&amp;nbsp;the&amp;nbsp;details&amp;nbsp;about&amp;nbsp;how&amp;nbsp;monitors&amp;nbsp;work&amp;nbsp;to&amp;nbsp;be&lt;br&gt;
able&amp;nbsp;to&amp;nbsp;use&amp;nbsp;them,&amp;nbsp;but&amp;nbsp;it&amp;nbsp;may&amp;nbsp;help&amp;nbsp;you&amp;nbsp;to&amp;nbsp;have&amp;nbsp;a&amp;nbsp;picture&amp;nbsp;in&amp;nbsp;mind.&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;__&amp;nbsp;monitor&amp;nbsp;is&amp;nbsp;essentially&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;__.&amp;nbsp;The&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;attached&amp;nbsp;to&amp;nbsp;a&amp;nbsp;resource&amp;nbsp;that&lt;br&gt;
many&amp;nbsp;threads&amp;nbsp;may&amp;nbsp;need&amp;nbsp;to&amp;nbsp;access,&amp;nbsp;but&amp;nbsp;that&amp;nbsp;should&amp;nbsp;be&amp;nbsp;accessed&amp;nbsp;by&amp;nbsp;only&lt;br&gt;
_&amp;nbsp;one&amp;nbsp;thread&amp;nbsp;at&amp;nbsp;a&amp;nbsp;time&amp;nbsp;_.&amp;nbsp;It’s&amp;nbsp;very&amp;nbsp;much&amp;nbsp;like&amp;nbsp;a&amp;nbsp;___&amp;nbsp;restroom&amp;nbsp;___&amp;nbsp;with&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;the&lt;br&gt;
door;&amp;nbsp;if&amp;nbsp;it’s&amp;nbsp;unlocked,&amp;nbsp;you&amp;nbsp;can&amp;nbsp;enter&amp;nbsp;and&amp;nbsp;lock&amp;nbsp;the&amp;nbsp;door&amp;nbsp;while&amp;nbsp;you&amp;nbsp;are&amp;nbsp;using&lt;br&gt;
it.&amp;nbsp;If&amp;nbsp;the&amp;nbsp;resource&amp;nbsp;is&amp;nbsp;not&amp;nbsp;being&amp;nbsp;used,&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&lt;br&gt;
and&amp;nbsp;access&amp;nbsp;the&amp;nbsp;resource.&amp;nbsp;When&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;done,&amp;nbsp;it&amp;nbsp;relinquishes&amp;nbsp;the&amp;nbsp;lock,&lt;br&gt;
just&amp;nbsp;as&amp;nbsp;you&amp;nbsp;unlock&amp;nbsp;the&amp;nbsp;restroom&amp;nbsp;door&amp;nbsp;and&amp;nbsp;leave&amp;nbsp;it&amp;nbsp;open&amp;nbsp;for&amp;nbsp;the&amp;nbsp;next&amp;nbsp;person.&lt;br&gt;
However,&amp;nbsp;if&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;already&amp;nbsp;has&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;for&amp;nbsp;the&amp;nbsp;resource,&amp;nbsp;all&amp;nbsp;other&lt;br&gt;
threads&amp;nbsp;must&amp;nbsp;wait&amp;nbsp;until&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;done&amp;nbsp;and&amp;nbsp;has&amp;nbsp;released&amp;nbsp;the&amp;nbsp;lock.&lt;br&gt;
This&amp;nbsp;is&amp;nbsp;just&amp;nbsp;like&amp;nbsp;when&amp;nbsp;the&amp;nbsp;restroom&amp;nbsp;is&amp;nbsp;occupied&amp;nbsp;when&amp;nbsp;you&amp;nbsp;arrive:&amp;nbsp;you&amp;nbsp;have&lt;br&gt;
to&amp;nbsp;wait&amp;nbsp;until&amp;nbsp;the&amp;nbsp;current&amp;nbsp;user&amp;nbsp;is&amp;nbsp;done&amp;nbsp;and&amp;nbsp;unlocks&amp;nbsp;the&amp;nbsp;door.&lt;br&gt;
&lt;br&gt;
Fortunately,&amp;nbsp;Java&amp;nbsp;makes&amp;nbsp;the&amp;nbsp;process&amp;nbsp;of&amp;nbsp;synchronizing&amp;nbsp;access&amp;nbsp;to&amp;nbsp;resources&lt;br&gt;
fairly&amp;nbsp;easy.&amp;nbsp;The&amp;nbsp;language&amp;nbsp;handles&amp;nbsp;setting&amp;nbsp;up&amp;nbsp;and&amp;nbsp;acquiring&amp;nbsp;locks;&amp;nbsp;all&amp;nbsp;you&amp;nbsp;need&lt;br&gt;
to&amp;nbsp;do&amp;nbsp;is&amp;nbsp;___&amp;nbsp;specify&amp;nbsp;the&amp;nbsp;resources&amp;nbsp;that&amp;nbsp;require&amp;nbsp;synchronization.&lt;br&gt;
&lt;br&gt;
=============================================&lt;br&gt;
&lt;br&gt;
&amp;nbsp;Serializing&amp;nbsp;Access&amp;nbsp;to&amp;nbsp;Methods&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;most&amp;nbsp;common&amp;nbsp;need&amp;nbsp;for&amp;nbsp;synchronization&amp;nbsp;among&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;is&amp;nbsp;to&lt;br&gt;
serialize&amp;nbsp;their&amp;nbsp;access&amp;nbsp;to&amp;nbsp;some&amp;nbsp;resource&amp;nbsp;(an&amp;nbsp;object)—in&amp;nbsp;other&amp;nbsp;words,&amp;nbsp;to&lt;br&gt;
make&amp;nbsp;sure&amp;nbsp;that&amp;nbsp;only&amp;nbsp;one&amp;nbsp;thread&amp;nbsp;at&amp;nbsp;a&amp;nbsp;time&amp;nbsp;can&amp;nbsp;manipulate&amp;nbsp;an&amp;nbsp;object&amp;nbsp;or&lt;br&gt;
variable.&amp;nbsp;In&amp;nbsp;Java,&amp;nbsp;every&amp;nbsp;object&amp;nbsp;has&amp;nbsp;an&amp;nbsp;associated&amp;nbsp;lock.&amp;nbsp;To&amp;nbsp;be&amp;nbsp;more&amp;nbsp;specific,&lt;br&gt;
every&amp;nbsp;class&amp;nbsp;and&amp;nbsp;every&amp;nbsp;instance&amp;nbsp;of&amp;nbsp;a&amp;nbsp;class&amp;nbsp;has&amp;nbsp;its&amp;nbsp;own&amp;nbsp;lock.&amp;nbsp;The&lt;br&gt;
synchronized&amp;nbsp;keyword&amp;nbsp;marks&amp;nbsp;places&amp;nbsp;where&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;must&amp;nbsp;acquire&amp;nbsp;the&lt;br&gt;
lock&amp;nbsp;before&amp;nbsp;proceeding.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
FOR&amp;nbsp;example,&amp;nbsp;suppose&amp;nbsp;we&amp;nbsp;implemented&amp;nbsp;a&amp;nbsp;SpeechSynthesizer&amp;nbsp;class&amp;nbsp;that&amp;nbsp;contains&lt;br&gt;
a&amp;nbsp;say()&amp;nbsp;method.&amp;nbsp;We&amp;nbsp;don’t&amp;nbsp;want&amp;nbsp;multiple&amp;nbsp;threads&amp;nbsp;calling&amp;nbsp;say()&amp;nbsp;at&amp;nbsp;the&amp;nbsp;same&amp;nbsp;time&lt;br&gt;
because&amp;nbsp;we&amp;nbsp;wouldn’t&amp;nbsp;be&amp;nbsp;able&amp;nbsp;to&amp;nbsp;understand&amp;nbsp;anything&amp;nbsp;being&amp;nbsp;said.&amp;nbsp;So&amp;nbsp;we&amp;nbsp;mark&amp;nbsp;the&lt;br&gt;
say()&amp;nbsp;method&amp;nbsp;as&amp;nbsp;synchronized,&amp;nbsp;which&amp;nbsp;means&amp;nbsp;that&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;must&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&lt;br&gt;
on&amp;nbsp;the&amp;nbsp;SpeechSynthe&amp;nbsp;sizer&amp;nbsp;object&amp;nbsp;before&amp;nbsp;it&amp;nbsp;can&amp;nbsp;speak:&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;SpeechSynthesizer&amp;nbsp;{&lt;br&gt;
&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;say(&amp;nbsp;String&amp;nbsp;words&amp;nbsp;)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;//&amp;nbsp;speak&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
!!!!&amp;nbsp;Because&amp;nbsp;__&amp;nbsp;say()&amp;nbsp;is&amp;nbsp;an&amp;nbsp;instance&amp;nbsp;method&amp;nbsp;__,&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;must&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;the&lt;br&gt;
SpeechSynthesizer&amp;nbsp;-&gt;&amp;nbsp;instance&amp;nbsp;&lt;-&amp;nbsp;!!!!___&amp;nbsp;it’s&amp;nbsp;using&amp;nbsp;before&amp;nbsp;it&amp;nbsp;can&amp;nbsp;invoke&amp;nbsp;the&amp;nbsp;say()&amp;nbsp;method.&lt;br&gt;
When&amp;nbsp;say()&amp;nbsp;has&amp;nbsp;completed,&amp;nbsp;it&amp;nbsp;gives&amp;nbsp;up&amp;nbsp;the&amp;nbsp;lock,&amp;nbsp;which&amp;nbsp;allows&amp;nbsp;the&amp;nbsp;next&amp;nbsp;waiting&lt;br&gt;
thread&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;run&amp;nbsp;the&amp;nbsp;method.&amp;nbsp;It&amp;nbsp;doesn’t&amp;nbsp;matter&amp;nbsp;whether&amp;nbsp;the&lt;br&gt;
thread&amp;nbsp;is&amp;nbsp;owned&amp;nbsp;by&amp;nbsp;the&amp;nbsp;SpeechSynthesizer&amp;nbsp;itself&amp;nbsp;or&amp;nbsp;some&amp;nbsp;other&amp;nbsp;object;&amp;nbsp;every&lt;br&gt;
thread&amp;nbsp;must&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;same&amp;nbsp;lock,&amp;nbsp;that&amp;nbsp;of&amp;nbsp;the&amp;nbsp;SpeechSynthesizer&amp;nbsp;instance.&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;If&amp;nbsp;say()&amp;nbsp;were&amp;nbsp;a&amp;nbsp;class&amp;nbsp;(static)&amp;nbsp;method&amp;nbsp;instead&amp;nbsp;of&amp;nbsp;an&amp;nbsp;instance&amp;nbsp;method,&amp;nbsp;we&lt;br&gt;
could&amp;nbsp;still&amp;nbsp;mark&amp;nbsp;it&amp;nbsp;as&amp;nbsp;synchronized.&amp;nbsp;In&amp;nbsp;this&amp;nbsp;case,&amp;nbsp;because&amp;nbsp;no&amp;nbsp;instance&amp;nbsp;object&lt;br&gt;
is&amp;nbsp;involved,&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;on&amp;nbsp;the&amp;nbsp;class&amp;nbsp;object&amp;nbsp;itself.&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;():&lt;br&gt;
package&amp;nbsp;synchronization;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;SynchronizationMethodHelloWorld&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Speaker&amp;nbsp;speaker&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Speaker();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;Thread&amp;nbsp;t1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;ThreadSpeaker(new&amp;nbsp;Speaker()));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;Thread&amp;nbsp;t2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;ThreadSpeaker(new&amp;nbsp;Speaker()));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/*&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*&amp;nbsp;//OUTPUT:&amp;nbsp;(No&amp;nbsp;synchronization&amp;nbsp;because&amp;nbsp;Threads&amp;nbsp;has&amp;nbsp;different&amp;nbsp;instances&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;ThreadSpeaker(speaker));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;ThreadSpeaker(speaker));&amp;nbsp;//&amp;nbsp;synchronized&amp;nbsp;,&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;because&amp;nbsp;threads&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;has&amp;nbsp;one&amp;nbsp;instance&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;of&amp;nbsp;Speaker&amp;nbsp;class&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/*&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2&amp;nbsp;Say:&amp;nbsp;Thread-0&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2&amp;nbsp;Say:&amp;nbsp;Thread-1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Speaker&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;say(String&amp;nbsp;arg)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;3;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(i&amp;nbsp;+&amp;nbsp;"&amp;nbsp;Say:&amp;nbsp;"&amp;nbsp;+&amp;nbsp;arg);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(14);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(Exception&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;ThreadSpeaker&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;Speaker&amp;nbsp;speaker;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;ThreadSpeaker(Speaker&amp;nbsp;speaker)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.speaker&amp;nbsp;=&amp;nbsp;speaker;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;5;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.speaker.say(Thread.currentThread().getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(14);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
==============================================&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;addition&amp;nbsp;to&amp;nbsp;synchronizing&amp;nbsp;entire&amp;nbsp;methods,&amp;nbsp;the&amp;nbsp;synchronized&amp;nbsp;keyword&amp;nbsp;can&amp;nbsp;&lt;br&gt;
be&amp;nbsp;used&amp;nbsp;in&amp;nbsp;a&amp;nbsp;special&amp;nbsp;construct&amp;nbsp;to&amp;nbsp;guard&amp;nbsp;arbitrary&amp;nbsp;&amp;nbsp;__&amp;nbsp;blocks&amp;nbsp;of&amp;nbsp;code&amp;nbsp;__.&amp;nbsp;In&amp;nbsp;this&amp;nbsp;form,&lt;br&gt;
it&amp;nbsp;also&amp;nbsp;takes&amp;nbsp;an&amp;nbsp;explicit&amp;nbsp;argument&amp;nbsp;that&amp;nbsp;specifies&amp;nbsp;the&amp;nbsp;object&amp;nbsp;for&amp;nbsp;which&amp;nbsp;it&amp;nbsp;is&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;a&amp;nbsp;lock:&lt;br&gt;
&amp;nbsp;synchronized&amp;nbsp;(&amp;nbsp;myObject&amp;nbsp;)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;//&amp;nbsp;Functionality&amp;nbsp;that&amp;nbsp;needs&amp;nbsp;exclusive&amp;nbsp;access&amp;nbsp;to&amp;nbsp;resources&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
This&amp;nbsp;code&amp;nbsp;block&amp;nbsp;can&amp;nbsp;appear&amp;nbsp;in&amp;nbsp;any&amp;nbsp;method.&amp;nbsp;When&amp;nbsp;it&amp;nbsp;is&amp;nbsp;reached,&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;has&lt;br&gt;
to&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;myObject&amp;nbsp;before&amp;nbsp;proceeding.&amp;nbsp;In&amp;nbsp;this&amp;nbsp;way,&amp;nbsp;we&amp;nbsp;can&amp;nbsp;synchronize&lt;br&gt;
methods&amp;nbsp;(or&amp;nbsp;parts&amp;nbsp;of&amp;nbsp;methods)&amp;nbsp;in&amp;nbsp;different&amp;nbsp;classes&amp;nbsp;in&amp;nbsp;the&amp;nbsp;same&amp;nbsp;way&amp;nbsp;as&amp;nbsp;methods&amp;nbsp;in&lt;br&gt;
the&amp;nbsp;same&amp;nbsp;class.&amp;nbsp;A&amp;nbsp;synchronized&amp;nbsp;instance&amp;nbsp;method&amp;nbsp;is,&amp;nbsp;therefore,&amp;nbsp;equivalent&amp;nbsp;to&amp;nbsp;a&lt;br&gt;
method&amp;nbsp;with&amp;nbsp;its&amp;nbsp;statements&amp;nbsp;synchronized&amp;nbsp;on&amp;nbsp;the&amp;nbsp;current&amp;nbsp;object.&amp;nbsp;Thus:&lt;br&gt;
&amp;nbsp;&lt;br&gt;
&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;myMethod&amp;nbsp;()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;...&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
is&amp;nbsp;equivalent&amp;nbsp;to:&lt;br&gt;
&amp;nbsp;&amp;nbsp;void&amp;nbsp;myMethod&amp;nbsp;()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;(&amp;nbsp;this&amp;nbsp;)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;...&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
==========================&lt;br&gt;
============================&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;lock&amp;nbsp;?&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;monitor&amp;nbsp;is&amp;nbsp;essentially&amp;nbsp;a&amp;nbsp;lock.&amp;nbsp;The&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;attached&amp;nbsp;to&amp;nbsp;a&amp;nbsp;resource&amp;nbsp;that&lt;br&gt;
many&amp;nbsp;threads&amp;nbsp;may&amp;nbsp;need&amp;nbsp;to&amp;nbsp;access,&amp;nbsp;but&amp;nbsp;that&amp;nbsp;should&amp;nbsp;be&amp;nbsp;accessed&amp;nbsp;by&amp;nbsp;only&lt;br&gt;
one&amp;nbsp;thread&amp;nbsp;at&amp;nbsp;a&amp;nbsp;time.&amp;nbsp;It’s&amp;nbsp;very&amp;nbsp;much&amp;nbsp;like&amp;nbsp;a&amp;nbsp;restroom&amp;nbsp;with&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;the&lt;br&gt;
door;&amp;nbsp;if&amp;nbsp;it’s&amp;nbsp;unlocked,&amp;nbsp;you&amp;nbsp;can&amp;nbsp;enter&amp;nbsp;and&amp;nbsp;lock&amp;nbsp;the&amp;nbsp;door&amp;nbsp;while&amp;nbsp;you&amp;nbsp;are&amp;nbsp;using&lt;br&gt;
it.&amp;nbsp;If&amp;nbsp;the&amp;nbsp;resource&amp;nbsp;is&amp;nbsp;not&amp;nbsp;being&amp;nbsp;used,&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;access&lt;br&gt;
the&amp;nbsp;resource.&amp;nbsp;When&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;done,&amp;nbsp;it&amp;nbsp;relinquishes&amp;nbsp;the&amp;nbsp;lock,&amp;nbsp;just&amp;nbsp;as&amp;nbsp;you&lt;br&gt;
unlock&amp;nbsp;the&amp;nbsp;restroom&amp;nbsp;door&amp;nbsp;and&amp;nbsp;leave&amp;nbsp;it&amp;nbsp;open&amp;nbsp;for&amp;nbsp;the&amp;nbsp;next&amp;nbsp;person.&amp;nbsp;However,&lt;br&gt;
if&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;already&amp;nbsp;has&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;for&amp;nbsp;the&amp;nbsp;resource,&amp;nbsp;all&amp;nbsp;other&amp;nbsp;threads&lt;br&gt;
must&amp;nbsp;wait&amp;nbsp;until&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;done&amp;nbsp;and&amp;nbsp;has&amp;nbsp;released&amp;nbsp;the&amp;nbsp;lock.&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:4" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Accessing&amp;nbsp;class&amp;nbsp;and&amp;nbsp;instance&amp;nbsp;Variables&amp;nbsp;from&amp;nbsp;Multiple&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Threads,&amp;nbsp;describe.&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;principle&amp;nbsp;of&amp;nbsp;Reenrtant&amp;nbsp;Lock&amp;nbsp;,&amp;nbsp;describe.&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;'volatile'&amp;nbsp;variables,&amp;nbsp;provide&amp;nbsp;example.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
In&amp;nbsp;the&amp;nbsp;SpreadSheet&amp;nbsp;example,&amp;nbsp;we&amp;nbsp;guarded&amp;nbsp;access&amp;nbsp;to&amp;nbsp;a&amp;nbsp;set&amp;nbsp;of&amp;nbsp;instance&lt;br&gt;
variables&amp;nbsp;with&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;method&amp;nbsp;in&amp;nbsp;order&amp;nbsp;to&amp;nbsp;avoid&amp;nbsp;changing&amp;nbsp;one&amp;nbsp;of&lt;br&gt;
the&amp;nbsp;variables&amp;nbsp;while&amp;nbsp;someone&amp;nbsp;was&amp;nbsp;reading&amp;nbsp;the&amp;nbsp;others.&amp;nbsp;We&amp;nbsp;wanted&amp;nbsp;to&amp;nbsp;keep&lt;br&gt;
them&amp;nbsp;coordinated.&amp;nbsp;But&amp;nbsp;what&amp;nbsp;about&amp;nbsp;individual&amp;nbsp;variable&amp;nbsp;types?&lt;br&gt;
Do&amp;nbsp;they&amp;nbsp;need&amp;nbsp;to&amp;nbsp;be&amp;nbsp;synchronized?&amp;nbsp;Normally,&amp;nbsp;the&amp;nbsp;answer&amp;nbsp;is&amp;nbsp;no.&amp;nbsp;&lt;br&gt;
!!&amp;nbsp;Almost&amp;nbsp;all&amp;nbsp;operations&amp;nbsp;on&amp;nbsp;_primitives&amp;nbsp;and&amp;nbsp;_object&amp;nbsp;reference&amp;nbsp;types&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;happen&lt;br&gt;
atomically:&amp;nbsp;that&amp;nbsp;is,&amp;nbsp;they&amp;nbsp;are&amp;nbsp;handled&amp;nbsp;by&amp;nbsp;the&amp;nbsp;VM&amp;nbsp;in&amp;nbsp;one&amp;nbsp;step,&amp;nbsp;with&amp;nbsp;no&amp;nbsp;opportunity&lt;br&gt;
for&amp;nbsp;two&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;collide.&amp;nbsp;This&amp;nbsp;prevents&amp;nbsp;threads&amp;nbsp;from&amp;nbsp;looking&amp;nbsp;at&amp;nbsp;references&lt;br&gt;
while&amp;nbsp;they&amp;nbsp;are&amp;nbsp;in&amp;nbsp;the&amp;nbsp;process&amp;nbsp;of&amp;nbsp;being&amp;nbsp;accessed&amp;nbsp;by&amp;nbsp;other&amp;nbsp;threads.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
But&amp;nbsp;watch&amp;nbsp;out—we&amp;nbsp;did&amp;nbsp;say&amp;nbsp;almost.&amp;nbsp;If&amp;nbsp;you&amp;nbsp;read&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;VM&amp;nbsp;specification&lt;br&gt;
carefully,&amp;nbsp;you&amp;nbsp;will&amp;nbsp;see&amp;nbsp;that&amp;nbsp;the&amp;nbsp;double&amp;nbsp;and&amp;nbsp;long&amp;nbsp;primitive&amp;nbsp;types&amp;nbsp;are&amp;nbsp;not&lt;br&gt;
guaranteed&amp;nbsp;to&amp;nbsp;be&amp;nbsp;handled&amp;nbsp;atomically.&amp;nbsp;Both&amp;nbsp;of&amp;nbsp;these&amp;nbsp;types&amp;nbsp;represent&amp;nbsp;64-bit&lt;br&gt;
values.&amp;nbsp;The&amp;nbsp;problem&amp;nbsp;has&amp;nbsp;to&amp;nbsp;do&amp;nbsp;with&amp;nbsp;how&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;VM’s&amp;nbsp;stack&amp;nbsp;handles&amp;nbsp;them.&lt;br&gt;
It&amp;nbsp;is&amp;nbsp;possible&amp;nbsp;that&amp;nbsp;this&amp;nbsp;specification&amp;nbsp;will&amp;nbsp;be&amp;nbsp;beefed&amp;nbsp;up&amp;nbsp;in&amp;nbsp;the&amp;nbsp;future.&lt;br&gt;
But&amp;nbsp;for&amp;nbsp;now,&amp;nbsp;to&amp;nbsp;be&amp;nbsp;strict,&amp;nbsp;you&amp;nbsp;should&amp;nbsp;synchronize&amp;nbsp;access&amp;nbsp;to&amp;nbsp;your&amp;nbsp;double&lt;br&gt;
and&amp;nbsp;long&amp;nbsp;instance&amp;nbsp;variables&amp;nbsp;through&amp;nbsp;accessor&amp;nbsp;methods,&amp;nbsp;or&amp;nbsp;use&amp;nbsp;the&amp;nbsp;&lt;br&gt;
__volatile&amp;nbsp;keyword&amp;nbsp;or&amp;nbsp;an&amp;nbsp;__&amp;nbsp;atomic&amp;nbsp;wrapper&amp;nbsp;class,&amp;nbsp;which&amp;nbsp;we’ll&amp;nbsp;describe&amp;nbsp;next.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Another&amp;nbsp;issue,&amp;nbsp;independent&amp;nbsp;of&amp;nbsp;the&amp;nbsp;atomicity&amp;nbsp;of&amp;nbsp;the&amp;nbsp;values,&amp;nbsp;is&amp;nbsp;the&amp;nbsp;notion&lt;br&gt;
of&amp;nbsp;different&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;the&amp;nbsp;VM&amp;nbsp;__caching&amp;nbsp;values&amp;nbsp;for&amp;nbsp;periods&amp;nbsp;of&amp;nbsp;time—that&amp;nbsp;is,&lt;br&gt;
even&amp;nbsp;though&amp;nbsp;one&amp;nbsp;thread&amp;nbsp;may&amp;nbsp;have&amp;nbsp;changed&amp;nbsp;the&amp;nbsp;value,&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;VM&amp;nbsp;may&lt;br&gt;
not&amp;nbsp;be&amp;nbsp;obliged&amp;nbsp;to&amp;nbsp;make&amp;nbsp;that&amp;nbsp;value&amp;nbsp;appear&amp;nbsp;until&amp;nbsp;the&amp;nbsp;VM&amp;nbsp;reaches&amp;nbsp;a&amp;nbsp;certain&lt;br&gt;
state&amp;nbsp;known&amp;nbsp;as&amp;nbsp;a&amp;nbsp;“memory&amp;nbsp;barrier.”&amp;nbsp;While&amp;nbsp;this&amp;nbsp;should&amp;nbsp;not&amp;nbsp;be&amp;nbsp;a&amp;nbsp;problem&lt;br&gt;
in&amp;nbsp;most&amp;nbsp;real-world&amp;nbsp;programming&amp;nbsp;cases,&amp;nbsp;you&amp;nbsp;can&amp;nbsp;address&amp;nbsp;this&amp;nbsp;by&amp;nbsp;declaring&lt;br&gt;
the&amp;nbsp;variable&amp;nbsp;with&amp;nbsp;the&amp;nbsp;volatile&amp;nbsp;keyword.&amp;nbsp;This&amp;nbsp;keyword&amp;nbsp;indicates&amp;nbsp;to&amp;nbsp;the&amp;nbsp;VM&lt;br&gt;
that&amp;nbsp;the&amp;nbsp;value&amp;nbsp;may&amp;nbsp;be&amp;nbsp;changed&amp;nbsp;by&amp;nbsp;external&amp;nbsp;threads&amp;nbsp;and&amp;nbsp;effectively&lt;br&gt;
synchronizes&amp;nbsp;access&amp;nbsp;to&amp;nbsp;it&amp;nbsp;automatically.&lt;br&gt;
&lt;br&gt;
Finally,&amp;nbsp;the&amp;nbsp;java.util.concurrent.atomic&amp;nbsp;package&amp;nbsp;provides&amp;nbsp;__&amp;nbsp;synchronized&lt;br&gt;
wrapper&amp;nbsp;classes&amp;nbsp;for&amp;nbsp;all&amp;nbsp;primitive&amp;nbsp;types&amp;nbsp;and&amp;nbsp;references.&amp;nbsp;These&amp;nbsp;wrappers&lt;br&gt;
provide&amp;nbsp;not&amp;nbsp;only&amp;nbsp;simple&amp;nbsp;set()&amp;nbsp;and&amp;nbsp;get()&amp;nbsp;operations&amp;nbsp;on&amp;nbsp;the&amp;nbsp;values&amp;nbsp;but&amp;nbsp;also&lt;br&gt;
specialized&amp;nbsp;“combo”&amp;nbsp;operations,&amp;nbsp;such&amp;nbsp;as&amp;nbsp;compareAndSet(),&amp;nbsp;that&amp;nbsp;work&lt;br&gt;
atomically&amp;nbsp;and&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;build&amp;nbsp;higher-level&amp;nbsp;synchronized&amp;nbsp;application&lt;br&gt;
components.&amp;nbsp;The&amp;nbsp;classes&amp;nbsp;in&amp;nbsp;this&amp;nbsp;package&amp;nbsp;were&amp;nbsp;designed&amp;nbsp;specifically&lt;br&gt;
to&amp;nbsp;map&amp;nbsp;down&amp;nbsp;to&amp;nbsp;hardware-level&amp;nbsp;functionality&amp;nbsp;in&amp;nbsp;many&amp;nbsp;cases&amp;nbsp;and&amp;nbsp;can&amp;nbsp;be&lt;br&gt;
very&amp;nbsp;efficient.&amp;nbsp;We’ll&amp;nbsp;talk&amp;nbsp;more&amp;nbsp;about&amp;nbsp;them&amp;nbsp;later&amp;nbsp;in&amp;nbsp;this&amp;nbsp;chapter.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
=======&lt;br&gt;
Reentrant&amp;nbsp;locking&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;locks&amp;nbsp;acquired&amp;nbsp;by&amp;nbsp;Java&amp;nbsp;upon&amp;nbsp;entering&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;method&amp;nbsp;or&amp;nbsp;block&amp;nbsp;of&lt;br&gt;
code&amp;nbsp;are&amp;nbsp;reentrant,&amp;nbsp;meaning&amp;nbsp;that&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;holding&amp;nbsp;onto&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;may&lt;br&gt;
acquire&amp;nbsp;the&amp;nbsp;same&amp;nbsp;lock&amp;nbsp;again&amp;nbsp;any&amp;nbsp;number&amp;nbsp;of&amp;nbsp;times&amp;nbsp;and&amp;nbsp;never&amp;nbsp;blocks&amp;nbsp;waiting&lt;br&gt;
for&amp;nbsp;itself.&amp;nbsp;In&amp;nbsp;most&amp;nbsp;cases,&amp;nbsp;this&amp;nbsp;means&amp;nbsp;that&amp;nbsp;the&amp;nbsp;code&amp;nbsp;behaves&amp;nbsp;as&amp;nbsp;you’d&amp;nbsp;expect;&lt;br&gt;
a&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;call&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;method&amp;nbsp;recursively&amp;nbsp;and&amp;nbsp;can&amp;nbsp;itself&amp;nbsp;call&amp;nbsp;upon&lt;br&gt;
other&amp;nbsp;synchronized&amp;nbsp;methods&amp;nbsp;within&amp;nbsp;the&amp;nbsp;same&amp;nbsp;object.&lt;br&gt;
==================================&lt;br&gt;
&amp;nbsp;Volatile&amp;nbsp;varibales&amp;nbsp;&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
volatile&amp;nbsp;is&amp;nbsp;probably&amp;nbsp;the&amp;nbsp;less&amp;nbsp;known/understood/documented&amp;nbsp;keyword&amp;nbsp;in&amp;nbsp;Java.&lt;br&gt;
I&amp;nbsp;have&amp;nbsp;recently&amp;nbsp;read&amp;nbsp;an&amp;nbsp;article&amp;nbsp;on&amp;nbsp;one&amp;nbsp;of&amp;nbsp;my&amp;nbsp;favourite&amp;nbsp;blog&amp;nbsp;about&amp;nbsp;the&amp;nbsp;volatile&lt;br&gt;
keyword.&amp;nbsp;The&amp;nbsp;author&amp;nbsp;shows&amp;nbsp;a&amp;nbsp;piece&amp;nbsp;of&amp;nbsp;code&amp;nbsp;where&amp;nbsp;the&amp;nbsp;volatile&amp;nbsp;keyword&amp;nbsp;seems&lt;br&gt;
to&amp;nbsp;have&amp;nbsp;an&amp;nbsp;influence.&amp;nbsp;This&amp;nbsp;example&amp;nbsp;was&amp;nbsp;not&amp;nbsp;easy&amp;nbsp;to&amp;nbsp;understand&amp;nbsp;and&amp;nbsp;the&amp;nbsp;role&lt;br&gt;
of&amp;nbsp;the&amp;nbsp;volatile&amp;nbsp;keyword&amp;nbsp;on&amp;nbsp;the&amp;nbsp;behaviour&amp;nbsp;of&amp;nbsp;the&amp;nbsp;JVM&amp;nbsp;was&amp;nbsp;not&amp;nbsp;really&amp;nbsp;defined.&lt;br&gt;
So&amp;nbsp;I&amp;nbsp;have&amp;nbsp;decided&amp;nbsp;to&amp;nbsp;browse&amp;nbsp;the&amp;nbsp;web&amp;nbsp;to&amp;nbsp;find&amp;nbsp;a&amp;nbsp;better&amp;nbsp;code&amp;nbsp;example&amp;nbsp;for&amp;nbsp;the&amp;nbsp;volatile&lt;br&gt;
keyword.&amp;nbsp;After&amp;nbsp;one&amp;nbsp;hour,&amp;nbsp;nothing!&amp;nbsp;Only&amp;nbsp;wrong&amp;nbsp;examples,&amp;nbsp;articles&amp;nbsp;comparing&amp;nbsp;volatile&lt;br&gt;
with&amp;nbsp;synchronized&amp;nbsp;and&amp;nbsp;other&amp;nbsp;confused&amp;nbsp;examples&amp;nbsp;where&amp;nbsp;the&amp;nbsp;author&amp;nbsp;seems&amp;nbsp;as&amp;nbsp;lost&lt;br&gt;
as&amp;nbsp;the&amp;nbsp;reader...&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;synchronization;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.logging.Level;&lt;br&gt;
import&amp;nbsp;java.util.logging.Logger;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;VolatileExample&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;Logger&amp;nbsp;LOGGER&amp;nbsp;=&amp;nbsp;Logger.getAnonymousLogger();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;volatile&amp;nbsp;int&amp;nbsp;MY_INT&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;ChangeListener().start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;ChangeMaker().start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;class&amp;nbsp;ChangeListener&amp;nbsp;extends&amp;nbsp;Thread&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;local_value&amp;nbsp;=&amp;nbsp;MY_INT;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(local_value&amp;nbsp;&lt;&amp;nbsp;5)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(local_value&amp;nbsp;!=&amp;nbsp;MY_INT)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.log(Level.INFO,&amp;nbsp;"Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;{0}",&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MY_INT);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;local_value&amp;nbsp;=&amp;nbsp;MY_INT;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;class&amp;nbsp;ChangeMaker&amp;nbsp;extends&amp;nbsp;Thread&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;local_value&amp;nbsp;=&amp;nbsp;MY_INT;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(MY_INT&amp;nbsp;&lt;&amp;nbsp;5)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;VolatileExample.LOGGER.log(Level.INFO,&amp;nbsp;"Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;"&amp;nbsp;+&amp;nbsp;(local_value&amp;nbsp;+&amp;nbsp;1));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MY_INT&amp;nbsp;=&amp;nbsp;++local_value;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(500);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
===&lt;br&gt;
With&amp;nbsp;the&amp;nbsp;volatile&amp;nbsp;keyword&amp;nbsp;the&amp;nbsp;output&amp;nbsp;is&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;1&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;1&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;2&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;2&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;3&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;3&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;4&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;4&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;5&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;5&amp;nbsp;&lt;br&gt;
Without&amp;nbsp;the&amp;nbsp;volatile&amp;nbsp;keyword&amp;nbsp;the&amp;nbsp;output&amp;nbsp;is&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;1&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;2&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;3&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;4&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;5&lt;br&gt;
.....And&amp;nbsp;the&amp;nbsp;change&amp;nbsp;listener&amp;nbsp;loop&amp;nbsp;infinitely...&amp;nbsp;&lt;br&gt;
&amp;nbsp;&lt;br&gt;
&lt;br&gt;
/*!!!!!!!!!BUTTTTTTTTT&amp;nbsp;I&amp;nbsp;always&amp;nbsp;get&amp;nbsp;OUTPUT&amp;nbsp;(try&amp;nbsp;in&amp;nbsp;java&amp;nbsp;6&amp;nbsp;in&amp;nbsp;Monday,&amp;nbsp;maybe&amp;nbsp;java&amp;nbsp;7&amp;nbsp;have&amp;nbsp;some&amp;nbsp;behavior)&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;1&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;1&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;2&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;2&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;3&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;3&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;4&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;4&lt;br&gt;
Incrementing&amp;nbsp;MY_INT&amp;nbsp;to&amp;nbsp;5&lt;br&gt;
Got&amp;nbsp;Change&amp;nbsp;for&amp;nbsp;MY_INT&amp;nbsp;:&amp;nbsp;5&amp;nbsp;*/&lt;br&gt;
&lt;br&gt;
=====&lt;br&gt;
Explanation&lt;br&gt;
So&amp;nbsp;what&amp;nbsp;happens?&amp;nbsp;_Each&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;its&amp;nbsp;own&amp;nbsp;stack_!,&amp;nbsp;and&amp;nbsp;so&amp;nbsp;its&amp;nbsp;own&amp;nbsp;copy&lt;br&gt;
of&amp;nbsp;variables&amp;nbsp;it&amp;nbsp;can&amp;nbsp;access.&amp;nbsp;When&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;created,&amp;nbsp;it&amp;nbsp;copies&amp;nbsp;the&amp;nbsp;value&lt;br&gt;
of&amp;nbsp;all&amp;nbsp;accessible&amp;nbsp;variables&amp;nbsp;in&amp;nbsp;its&amp;nbsp;own&amp;nbsp;memory.&amp;nbsp;The&amp;nbsp;volatile&amp;nbsp;keyword&amp;nbsp;is&amp;nbsp;used&lt;br&gt;
to&amp;nbsp;say&amp;nbsp;to&amp;nbsp;the&amp;nbsp;jvm&amp;nbsp;"Warning,&amp;nbsp;this&amp;nbsp;variable&amp;nbsp;may&amp;nbsp;be&amp;nbsp;modified&amp;nbsp;in&amp;nbsp;an&amp;nbsp;other&amp;nbsp;Thread"&amp;nbsp;!.&lt;br&gt;
Without&amp;nbsp;this&amp;nbsp;keyword&amp;nbsp;the&amp;nbsp;JVM&amp;nbsp;is&amp;nbsp;free&amp;nbsp;to&amp;nbsp;make&amp;nbsp;some&amp;nbsp;optimizations,&amp;nbsp;like&amp;nbsp;never&lt;br&gt;
refreshing&amp;nbsp;those&amp;nbsp;local&amp;nbsp;copies&amp;nbsp;in&amp;nbsp;some&amp;nbsp;threads.&amp;nbsp;The&amp;nbsp;volatile&amp;nbsp;force&amp;nbsp;the&amp;nbsp;thread&lt;br&gt;
to&amp;nbsp;update&amp;nbsp;the&amp;nbsp;original&amp;nbsp;variable&amp;nbsp;for&amp;nbsp;each&amp;nbsp;variable.&amp;nbsp;The&amp;nbsp;volatile&amp;nbsp;keyword&amp;nbsp;could&lt;br&gt;
be&amp;nbsp;used&amp;nbsp;on&amp;nbsp;every&amp;nbsp;kind&amp;nbsp;of&amp;nbsp;variable,&amp;nbsp;either&amp;nbsp;primitive&amp;nbsp;or&amp;nbsp;objects!&amp;nbsp;Maybe&amp;nbsp;the&amp;nbsp;subject&lt;br&gt;
of&amp;nbsp;another&amp;nbsp;article,&amp;nbsp;more&amp;nbsp;detailed...&lt;br&gt;
&lt;br&gt;
Never&amp;nbsp;used&amp;nbsp;volatile&amp;nbsp;and&amp;nbsp;never&amp;nbsp;met&amp;nbsp;this&amp;nbsp;problem...&lt;br&gt;
Like&amp;nbsp;all&amp;nbsp;threads&amp;nbsp;issues,&amp;nbsp;it&amp;nbsp;happens&amp;nbsp;under&amp;nbsp;specials&amp;nbsp;circumstances.&amp;nbsp;Really&lt;br&gt;
special&amp;nbsp;for&amp;nbsp;this&amp;nbsp;one...&amp;nbsp;My&amp;nbsp;example&amp;nbsp;has&amp;nbsp;big&amp;nbsp;chances&amp;nbsp;to&amp;nbsp;show&amp;nbsp;mainly&amp;nbsp;because&lt;br&gt;
the&amp;nbsp;ChangeListener&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;busy,&amp;nbsp;thanks&amp;nbsp;to&amp;nbsp;the&amp;nbsp;loop,&amp;nbsp;and&amp;nbsp;the&amp;nbsp;JVM&amp;nbsp;consider&amp;nbsp;that&lt;br&gt;
this&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;no&amp;nbsp;time&amp;nbsp;for&amp;nbsp;updating&amp;nbsp;the&amp;nbsp;local&amp;nbsp;variables.&amp;nbsp;Executing&amp;nbsp;some&amp;nbsp;synchronized&lt;br&gt;
methods&amp;nbsp;or&amp;nbsp;adding&amp;nbsp;an&amp;nbsp;other&amp;nbsp;variable&amp;nbsp;which&amp;nbsp;is&amp;nbsp;volatile&amp;nbsp;(or&amp;nbsp;even&amp;nbsp;executing&amp;nbsp;some&lt;br&gt;
simple&amp;nbsp;lines&amp;nbsp;of&amp;nbsp;code)&amp;nbsp;could&amp;nbsp;modify&amp;nbsp;the&amp;nbsp;JVM&amp;nbsp;behavior&amp;nbsp;and&amp;nbsp;"correct"&amp;nbsp;this&amp;nbsp;problem...&lt;br&gt;
&lt;br&gt;
Should&amp;nbsp;I&amp;nbsp;do&amp;nbsp;a&amp;nbsp;big&amp;nbsp;refactor&amp;nbsp;to&amp;nbsp;identify&amp;nbsp;all&amp;nbsp;variables&amp;nbsp;who&amp;nbsp;needs&amp;nbsp;volatile?&lt;br&gt;
&lt;br&gt;
&amp;nbsp;Be&amp;nbsp;pragmatic!&amp;nbsp;If&amp;nbsp;you&amp;nbsp;think&amp;nbsp;your&amp;nbsp;project&amp;nbsp;needs&amp;nbsp;it,&amp;nbsp;do&amp;nbsp;it.&amp;nbsp;I&amp;nbsp;think&amp;nbsp;that&amp;nbsp;the&amp;nbsp;essential&lt;br&gt;
is&amp;nbsp;to&amp;nbsp;be&amp;nbsp;aware&amp;nbsp;of&amp;nbsp;that,&amp;nbsp;to&amp;nbsp;know&amp;nbsp;what&amp;nbsp;is&amp;nbsp;the&amp;nbsp;goal&amp;nbsp;of&amp;nbsp;each&amp;nbsp;keyword&amp;nbsp;of&amp;nbsp;the&amp;nbsp;java&amp;nbsp;language&lt;br&gt;
in&amp;nbsp;order&amp;nbsp;to&amp;nbsp;take&amp;nbsp;the&amp;nbsp;good&amp;nbsp;decisions.&lt;br&gt;
===============================&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:5" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;wait()&amp;nbsp;and&amp;nbsp;notify()&amp;nbsp;Methods,&amp;nbsp;describe.&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;the&amp;nbsp;difference&amp;nbsp;between&amp;nbsp;wait&amp;nbsp;and&amp;nbsp;sleep&amp;nbsp;?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>WAIT&amp;nbsp;:&lt;br&gt;
wait()&amp;nbsp;tells&amp;nbsp;the&amp;nbsp;calling&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;give&amp;nbsp;up&amp;nbsp;the&amp;nbsp;monitor&amp;nbsp;and&amp;nbsp;go&amp;nbsp;to&amp;nbsp;sleep&amp;nbsp;until&lt;br&gt;
some&amp;nbsp;other&amp;nbsp;thread&amp;nbsp;enters&amp;nbsp;the&amp;nbsp;same&amp;nbsp;monitor&amp;nbsp;and&amp;nbsp;calls&amp;nbsp;notify(&amp;nbsp;).&amp;nbsp;!!!!&amp;nbsp;&lt;br&gt;
&lt;br&gt;
With&amp;nbsp;the&amp;nbsp;synchronized&amp;nbsp;keyword,&amp;nbsp;we&amp;nbsp;can&amp;nbsp;serialize&amp;nbsp;the&amp;nbsp;execution&amp;nbsp;of&amp;nbsp;methods&lt;br&gt;
and&amp;nbsp;blocks&amp;nbsp;of&amp;nbsp;code&amp;nbsp;so&amp;nbsp;that&amp;nbsp;only&amp;nbsp;one&amp;nbsp;thread&amp;nbsp;at&amp;nbsp;a&amp;nbsp;time&amp;nbsp;can&amp;nbsp;execute&amp;nbsp;a&lt;br&gt;
synchronized&amp;nbsp;item.&amp;nbsp;The&amp;nbsp;wait()&amp;nbsp;and&amp;nbsp;notify()&amp;nbsp;methods&amp;nbsp;of&amp;nbsp;the&amp;nbsp;Object&amp;nbsp;class&lt;br&gt;
extend&amp;nbsp;this&amp;nbsp;capability&amp;nbsp;by&amp;nbsp;allowing&amp;nbsp;us&amp;nbsp;to&amp;nbsp;explicitly&amp;nbsp;coordinate&amp;nbsp;the&amp;nbsp;waiting&amp;nbsp;and&lt;br&gt;
running&amp;nbsp;threads.&amp;nbsp;Every&amp;nbsp;object&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;is&amp;nbsp;a&amp;nbsp;subclass&amp;nbsp;of&amp;nbsp;Object,&amp;nbsp;so&amp;nbsp;every&amp;nbsp;object&lt;br&gt;
inherits&amp;nbsp;these&amp;nbsp;methods.&amp;nbsp;By&amp;nbsp;using&amp;nbsp;wait()&amp;nbsp;and&amp;nbsp;notify(),&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;effectively&lt;br&gt;
give&amp;nbsp;up&amp;nbsp;its&amp;nbsp;hold&amp;nbsp;on&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;at&amp;nbsp;an&amp;nbsp;arbitrary&amp;nbsp;point&amp;nbsp;and&amp;nbsp;then&amp;nbsp;wait&amp;nbsp;for&lt;br&gt;
another&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;give&amp;nbsp;it&amp;nbsp;back&amp;nbsp;before&amp;nbsp;continuing.&amp;nbsp;All&amp;nbsp;of&amp;nbsp;the&amp;nbsp;coordinated&lt;br&gt;
activity&amp;nbsp;still&amp;nbsp;happens&amp;nbsp;inside&amp;nbsp;synchronized&amp;nbsp;blocks,&amp;nbsp;and&amp;nbsp;still&amp;nbsp;only&amp;nbsp;one&amp;nbsp;thread&lt;br&gt;
is&amp;nbsp;executing&amp;nbsp;at&amp;nbsp;a&amp;nbsp;given&amp;nbsp;time.&lt;br&gt;
&lt;br&gt;
By&amp;nbsp;executing&amp;nbsp;wait()&amp;nbsp;from&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;block,&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;gives&amp;nbsp;up&amp;nbsp;its&amp;nbsp;hold&lt;br&gt;
on&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;goes&amp;nbsp;to&amp;nbsp;sleep.&amp;nbsp;A&amp;nbsp;thread&amp;nbsp;might&amp;nbsp;do&amp;nbsp;this&amp;nbsp;if&amp;nbsp;it&amp;nbsp;needs&amp;nbsp;to&amp;nbsp;wait&lt;br&gt;
for&amp;nbsp;something&amp;nbsp;to&amp;nbsp;happen&amp;nbsp;in&amp;nbsp;another&amp;nbsp;part&amp;nbsp;of&amp;nbsp;the&amp;nbsp;application,&amp;nbsp;as&amp;nbsp;we’ll&amp;nbsp;see&lt;br&gt;
shortly.&amp;nbsp;Later,&amp;nbsp;when&amp;nbsp;the&amp;nbsp;necessary&amp;nbsp;event&amp;nbsp;happens,&amp;nbsp;the&amp;nbsp;running&amp;nbsp;thread&amp;nbsp;calls&lt;br&gt;
notify()&amp;nbsp;from&amp;nbsp;a&amp;nbsp;block&amp;nbsp;synchronized&amp;nbsp;on&amp;nbsp;the&amp;nbsp;same&amp;nbsp;object.&amp;nbsp;The&amp;nbsp;first&amp;nbsp;thread&amp;nbsp;wakes&lt;br&gt;
up&amp;nbsp;and&amp;nbsp;begins&amp;nbsp;trying&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;again.&amp;nbsp;When&amp;nbsp;the&amp;nbsp;first&amp;nbsp;thread&amp;nbsp;manages&lt;br&gt;
to&amp;nbsp;reacquire&amp;nbsp;the&amp;nbsp;lock,&amp;nbsp;it&amp;nbsp;continues&amp;nbsp;from&amp;nbsp;where&amp;nbsp;it&amp;nbsp;left&amp;nbsp;off.&amp;nbsp;However,&lt;br&gt;
the&amp;nbsp;thread&amp;nbsp;that&amp;nbsp;was&amp;nbsp;waiting&amp;nbsp;may&amp;nbsp;not&amp;nbsp;get&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;immediately&amp;nbsp;(or&amp;nbsp;perhaps&lt;br&gt;
ever).&amp;nbsp;It&amp;nbsp;depends&amp;nbsp;on&amp;nbsp;when&amp;nbsp;the&amp;nbsp;second&amp;nbsp;thread&amp;nbsp;eventually&amp;nbsp;releases&amp;nbsp;the&amp;nbsp;lock&lt;br&gt;
and&amp;nbsp;which&amp;nbsp;thread&amp;nbsp;manages&amp;nbsp;to&amp;nbsp;snag&amp;nbsp;it&amp;nbsp;next.&amp;nbsp;The&amp;nbsp;first&amp;nbsp;thread&amp;nbsp;won’t&amp;nbsp;wake&amp;nbsp;up&lt;br&gt;
from&amp;nbsp;the&amp;nbsp;wait()&amp;nbsp;unless&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;calls&amp;nbsp;notify().&amp;nbsp;!!!!&amp;nbsp;An&amp;nbsp;overloaded&amp;nbsp;version&lt;br&gt;
of&amp;nbsp;wait(),&amp;nbsp;however,&amp;nbsp;allows&amp;nbsp;us&amp;nbsp;to&amp;nbsp;specify&amp;nbsp;a&amp;nbsp;timeout&amp;nbsp;period.&amp;nbsp;If&amp;nbsp;another&amp;nbsp;thread&lt;br&gt;
doesn’t&amp;nbsp;call&amp;nbsp;notify()&amp;nbsp;in&amp;nbsp;the&amp;nbsp;specified&amp;nbsp;period,&amp;nbsp;the&amp;nbsp;waiting&amp;nbsp;thread&lt;br&gt;
automatically&amp;nbsp;wakes&amp;nbsp;up.&lt;br&gt;
&lt;br&gt;
Let’s&amp;nbsp;look&amp;nbsp;at&amp;nbsp;a&amp;nbsp;simple&amp;nbsp;scenario&amp;nbsp;to&amp;nbsp;see&amp;nbsp;what’s&amp;nbsp;going&amp;nbsp;on.&amp;nbsp;In&amp;nbsp;the&amp;nbsp;following&lt;br&gt;
example,&amp;nbsp;we’ll&amp;nbsp;assume&amp;nbsp;there&amp;nbsp;are&amp;nbsp;three&amp;nbsp;threads—one&amp;nbsp;waiting&amp;nbsp;to&amp;nbsp;execute&lt;br&gt;
each&amp;nbsp;of&amp;nbsp;the&amp;nbsp;three&amp;nbsp;synchronized&amp;nbsp;methods&amp;nbsp;of&amp;nbsp;the&amp;nbsp;MyThing&amp;nbsp;class.&amp;nbsp;We’ll&amp;nbsp;call&lt;br&gt;
them&amp;nbsp;the&amp;nbsp;waiter,&amp;nbsp;notifier,&amp;nbsp;and&amp;nbsp;related&amp;nbsp;threads.&lt;br&gt;
Here’s&amp;nbsp;a&amp;nbsp;code&amp;nbsp;fragment&amp;nbsp;to&amp;nbsp;illustrate:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;class&amp;nbsp;MyThing&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;waiterMethod()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;do&amp;nbsp;some&amp;nbsp;stuff&lt;br&gt;
&amp;nbsp;&amp;nbsp;wait();&amp;nbsp;//&amp;nbsp;now&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;notifier&amp;nbsp;to&amp;nbsp;do&amp;nbsp;something&lt;br&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;continue&amp;nbsp;where&amp;nbsp;we&amp;nbsp;left&amp;nbsp;off&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;notifierMethod()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;do&amp;nbsp;some&amp;nbsp;stuff&lt;br&gt;
&amp;nbsp;&amp;nbsp;notify();&amp;nbsp;//&amp;nbsp;notify&amp;nbsp;waiter&amp;nbsp;that&amp;nbsp;we've&amp;nbsp;done&amp;nbsp;it&lt;br&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;continue&amp;nbsp;doing&amp;nbsp;stuff&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;relatedMethod()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;//&amp;nbsp;do&amp;nbsp;some&amp;nbsp;related&amp;nbsp;stuff&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
...&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
===&lt;br&gt;
Let’s&amp;nbsp;assume&amp;nbsp;that&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;named&amp;nbsp;waiter&amp;nbsp;gets&amp;nbsp;through&amp;nbsp;the&amp;nbsp;gate&amp;nbsp;first&amp;nbsp;and&lt;br&gt;
begins&amp;nbsp;executing&amp;nbsp;waiterMethod().&amp;nbsp;The&amp;nbsp;two&amp;nbsp;other&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;initially&lt;br&gt;
blocked&amp;nbsp;when&amp;nbsp;trying&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;for&amp;nbsp;the&amp;nbsp;MyThing&amp;nbsp;object.&amp;nbsp;When&amp;nbsp;waiter&lt;br&gt;
executes&amp;nbsp;the&amp;nbsp;wait()&amp;nbsp;method,&amp;nbsp;it&amp;nbsp;relinquishes&amp;nbsp;its&amp;nbsp;hold&amp;nbsp;on&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;goes&amp;nbsp;to&lt;br&gt;
sleep.&amp;nbsp;Now&amp;nbsp;two&amp;nbsp;viable&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;the&amp;nbsp;lock.&amp;nbsp;Which&amp;nbsp;thread&amp;nbsp;gets&amp;nbsp;it&lt;br&gt;
depends&amp;nbsp;on&amp;nbsp;several&amp;nbsp;factors,&amp;nbsp;including&amp;nbsp;chance&amp;nbsp;and&amp;nbsp;the&amp;nbsp;priorities&amp;nbsp;of&lt;br&gt;
the&amp;nbsp;threads.&amp;nbsp;(We’ll&amp;nbsp;discuss&amp;nbsp;thread&amp;nbsp;scheduling&amp;nbsp;in&amp;nbsp;the&amp;nbsp;next&amp;nbsp;section.)&lt;br&gt;
&lt;br&gt;
Let’s&amp;nbsp;suppose&amp;nbsp;that&amp;nbsp;notifier&amp;nbsp;is&amp;nbsp;the&amp;nbsp;next&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock,&amp;nbsp;so&amp;nbsp;it&amp;nbsp;begins&amp;nbsp;to&amp;nbsp;run&lt;br&gt;
notifierMethod().&amp;nbsp;waiter&amp;nbsp;continues&amp;nbsp;to&amp;nbsp;sleep,&amp;nbsp;and&amp;nbsp;related&amp;nbsp;languishes,&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;its&lt;br&gt;
turn.&amp;nbsp;When&amp;nbsp;notifier&amp;nbsp;executes&amp;nbsp;the&amp;nbsp;call&amp;nbsp;to&amp;nbsp;notify(),&amp;nbsp;the&amp;nbsp;runtime&amp;nbsp;system&amp;nbsp;prods&amp;nbsp;the&amp;nbsp;waiter&lt;br&gt;
thread,&amp;nbsp;effectively&amp;nbsp;telling&amp;nbsp;it&amp;nbsp;something&amp;nbsp;has&amp;nbsp;changed.&amp;nbsp;waiter&amp;nbsp;wakes&amp;nbsp;up&amp;nbsp;and&amp;nbsp;rejoins&lt;br&gt;
related&amp;nbsp;in&amp;nbsp;vying&amp;nbsp;for&amp;nbsp;the&amp;nbsp;MyThing&amp;nbsp;lock.&amp;nbsp;It&amp;nbsp;doesn’t&amp;nbsp;receive&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;automatically;&amp;nbsp;it&amp;nbsp;just&lt;br&gt;
changes&amp;nbsp;its&amp;nbsp;state&amp;nbsp;from&amp;nbsp;&amp;nbsp;!!!!!&amp;nbsp;"Leave&amp;nbsp;me&amp;nbsp;alone"&amp;nbsp;to&amp;nbsp;"I&amp;nbsp;want&amp;nbsp;the&amp;nbsp;lock."&lt;br&gt;
&lt;br&gt;
At&amp;nbsp;this&amp;nbsp;point,&amp;nbsp;notifier&amp;nbsp;still&amp;nbsp;owns&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;continues&amp;nbsp;to&amp;nbsp;hold&amp;nbsp;it&amp;nbsp;until&amp;nbsp;the&lt;br&gt;
synchronized&amp;nbsp;notifierMethod()&amp;nbsp;returns,&amp;nbsp;or&amp;nbsp;perhaps&amp;nbsp;executes&amp;nbsp;a&amp;nbsp;wait()&amp;nbsp;itself.&amp;nbsp;At&lt;br&gt;
that&amp;nbsp;point,&amp;nbsp;the&amp;nbsp;other&amp;nbsp;two&amp;nbsp;methods&amp;nbsp;get&amp;nbsp;to&amp;nbsp;fight&amp;nbsp;over&amp;nbsp;the&amp;nbsp;lock.&amp;nbsp;waiter&amp;nbsp;would&amp;nbsp;like&lt;br&gt;
to&amp;nbsp;continue&amp;nbsp;executing&amp;nbsp;waiter&amp;nbsp;Method()&amp;nbsp;from&amp;nbsp;the&amp;nbsp;point&amp;nbsp;where&amp;nbsp;it&amp;nbsp;left&amp;nbsp;off,&amp;nbsp;while&lt;br&gt;
related,&amp;nbsp;which&amp;nbsp;has&amp;nbsp;been&amp;nbsp;patient,&amp;nbsp;would&amp;nbsp;like&amp;nbsp;to&amp;nbsp;get&amp;nbsp;started.&amp;nbsp;We’ll&amp;nbsp;let&amp;nbsp;you&amp;nbsp;choose&lt;br&gt;
your&amp;nbsp;own&amp;nbsp;ending&amp;nbsp;for&amp;nbsp;the&amp;nbsp;story.&lt;br&gt;
&lt;br&gt;
For&amp;nbsp;each&amp;nbsp;call&amp;nbsp;to&amp;nbsp;notify(),&amp;nbsp;the&amp;nbsp;runtime&amp;nbsp;system&amp;nbsp;wakes&amp;nbsp;up&amp;nbsp;just&amp;nbsp;one&amp;nbsp;thread&amp;nbsp;that&lt;br&gt;
is&amp;nbsp;asleep&amp;nbsp;in&amp;nbsp;a&amp;nbsp;wait()&amp;nbsp;call.&amp;nbsp;The&amp;nbsp;group&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;waiting&amp;nbsp;on&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;called&amp;nbsp;the&lt;br&gt;
wait&amp;nbsp;set.&amp;nbsp;If&amp;nbsp;multiple&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;waiting,&amp;nbsp;Java&amp;nbsp;picks&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;on&amp;nbsp;an&amp;nbsp;arbitrary&lt;br&gt;
basis,&amp;nbsp;which&amp;nbsp;may&amp;nbsp;be&amp;nbsp;implementation-dependent.&amp;nbsp;The&amp;nbsp;Object&amp;nbsp;class&amp;nbsp;also&amp;nbsp;provides&lt;br&gt;
a&amp;nbsp;notifyAll()&amp;nbsp;call&amp;nbsp;to&amp;nbsp;wake&amp;nbsp;up&amp;nbsp;all&amp;nbsp;waiting&amp;nbsp;threads.&amp;nbsp;In&amp;nbsp;most&amp;nbsp;cases,&amp;nbsp;you’ll&amp;nbsp;probably&lt;br&gt;
want&amp;nbsp;to&amp;nbsp;use&amp;nbsp;notifyAll()&amp;nbsp;rather&amp;nbsp;than&amp;nbsp;notify().&amp;nbsp;Keep&amp;nbsp;in&amp;nbsp;mind&amp;nbsp;that&amp;nbsp;notify()&amp;nbsp;really&lt;br&gt;
means,&amp;nbsp;“Hey,&amp;nbsp;something&amp;nbsp;related&amp;nbsp;to&amp;nbsp;this&amp;nbsp;object&amp;nbsp;has&amp;nbsp;changed.&amp;nbsp;The&amp;nbsp;condition&amp;nbsp;you&lt;br&gt;
are&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;may&amp;nbsp;have&amp;nbsp;changed,&amp;nbsp;so&amp;nbsp;check&amp;nbsp;it&amp;nbsp;again.”&amp;nbsp;In&amp;nbsp;general,&amp;nbsp;there&amp;nbsp;is&amp;nbsp;no&lt;br&gt;
reason&amp;nbsp;to&amp;nbsp;assume&amp;nbsp;only&amp;nbsp;one&amp;nbsp;thread&amp;nbsp;at&amp;nbsp;a&amp;nbsp;time&amp;nbsp;is&amp;nbsp;interested&amp;nbsp;in&amp;nbsp;the&amp;nbsp;change&amp;nbsp;or&amp;nbsp;able&amp;nbsp;to&lt;br&gt;
act&amp;nbsp;upon&amp;nbsp;it.&amp;nbsp;Different&amp;nbsp;threads&amp;nbsp;might&amp;nbsp;look&amp;nbsp;upon&amp;nbsp;whatever&amp;nbsp;has&amp;nbsp;changed&amp;nbsp;in&amp;nbsp;different&amp;nbsp;ways.&lt;br&gt;
=================================================&lt;br&gt;
Wait&amp;nbsp;conditions&lt;br&gt;
In&amp;nbsp;general,&amp;nbsp;our&amp;nbsp;waiter&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;a&amp;nbsp;particular&amp;nbsp;condition&amp;nbsp;to&amp;nbsp;change,&amp;nbsp;and&lt;br&gt;
we&amp;nbsp;will&amp;nbsp;want&amp;nbsp;it&amp;nbsp;to&amp;nbsp;sit&amp;nbsp;in&amp;nbsp;a&amp;nbsp;loop&amp;nbsp;like&amp;nbsp;the&amp;nbsp;following:&lt;br&gt;
&amp;nbsp;while&amp;nbsp;(&amp;nbsp;condition&amp;nbsp;!=&amp;nbsp;true&amp;nbsp;)&lt;br&gt;
&amp;nbsp;&amp;nbsp;wait();&lt;br&gt;
&lt;br&gt;
This&amp;nbsp;test&amp;nbsp;is&amp;nbsp;called&amp;nbsp;the&amp;nbsp;wait&amp;nbsp;condition.&amp;nbsp;Other&amp;nbsp;synchronized&amp;nbsp;threads&amp;nbsp;call&amp;nbsp;notify()&amp;nbsp;or&lt;br&gt;
notifyAll()&amp;nbsp;when&amp;nbsp;they&amp;nbsp;have&amp;nbsp;modified&amp;nbsp;the&amp;nbsp;environment&amp;nbsp;so&amp;nbsp;that&amp;nbsp;the&amp;nbsp;condition&amp;nbsp;can&amp;nbsp;be&lt;br&gt;
checked&amp;nbsp;again.&amp;nbsp;It’s&amp;nbsp;important&amp;nbsp;to&amp;nbsp;use&amp;nbsp;a&amp;nbsp;loop&amp;nbsp;on&amp;nbsp;the&amp;nbsp;wait&amp;nbsp;condition&amp;nbsp;to&amp;nbsp;be&amp;nbsp;sure&amp;nbsp;that&amp;nbsp;the&lt;br&gt;
thread&amp;nbsp;has&amp;nbsp;been&amp;nbsp;awakened&amp;nbsp;for&amp;nbsp;the&amp;nbsp;right&amp;nbsp;reason.&amp;nbsp;Threads&amp;nbsp;may&amp;nbsp;also&amp;nbsp;use&amp;nbsp;a&amp;nbsp;timed&amp;nbsp;version&lt;br&gt;
of&amp;nbsp;wait()&amp;nbsp;to&amp;nbsp;do&amp;nbsp;periodic&amp;nbsp;work&amp;nbsp;while&amp;nbsp;checking&amp;nbsp;the&amp;nbsp;condition&amp;nbsp;in&amp;nbsp;this&amp;nbsp;way.&amp;nbsp;Using&amp;nbsp;wait&lt;br&gt;
conditions&amp;nbsp;like&amp;nbsp;this&amp;nbsp;is&amp;nbsp;also&amp;nbsp;an&amp;nbsp;alternative&amp;nbsp;to&amp;nbsp;polling&amp;nbsp;and&amp;nbsp;sleeping,&amp;nbsp;as&amp;nbsp;you’ll&amp;nbsp;see&amp;nbsp;in&amp;nbsp;the&lt;br&gt;
following&amp;nbsp;section.&lt;br&gt;
==================================================&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;waitandnotify;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;WaitAndNotify1&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadB&amp;nbsp;b&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ThreadB();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.start();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;(b)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Waiting&amp;nbsp;for&amp;nbsp;b&amp;nbsp;to&amp;nbsp;complete...");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.wait();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Total&amp;nbsp;is:&amp;nbsp;"&amp;nbsp;+b.total);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;ThreadB&amp;nbsp;extends&amp;nbsp;Thread&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;int&amp;nbsp;total;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;String&amp;nbsp;toString()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;this.total&amp;nbsp;+&amp;nbsp;"";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;(this)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;=&amp;nbsp;1000000000;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;total&amp;nbsp;+=&amp;nbsp;i;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//System.out.println(total);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notify();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Waiting&amp;nbsp;for&amp;nbsp;b&amp;nbsp;to&amp;nbsp;complete...&lt;br&gt;
Total&amp;nbsp;is:&amp;nbsp;-243309312&lt;br&gt;
&lt;br&gt;
======================================&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&amp;nbsp;Producer&amp;nbsp;=&amp;nbsp;&gt;&amp;nbsp;Consumer&amp;nbsp;(using&amp;nbsp;wait&amp;nbsp;and&amp;nbsp;notify):&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;waitandnotify.consumerproducer;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.ArrayList;&lt;br&gt;
import&amp;nbsp;java.util.Date;&lt;br&gt;
import&amp;nbsp;java.util.List;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;Producer&amp;nbsp;implements&amp;nbsp;Runnable{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;final&amp;nbsp;int&amp;nbsp;MAXQUEUE&amp;nbsp;=&amp;nbsp;5;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;List&lt;String&gt;&amp;nbsp;messages&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ArrayList&lt;&gt;();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;putMessage();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;putMessage(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(messages.size()&amp;nbsp;&gt;=&amp;nbsp;MAXQUEUE)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;messages.add(&amp;nbsp;(new&amp;nbsp;Date()).toString()&amp;nbsp;);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notify();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;String&amp;nbsp;getMessage()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(messages.size()&amp;nbsp;==&amp;nbsp;0)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String&amp;nbsp;message&amp;nbsp;=&amp;nbsp;messages.remove(0);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notify();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;message;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
===&lt;br&gt;
package&amp;nbsp;waitandnotify.consumerproducer;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;Consumer&amp;nbsp;implements&amp;nbsp;Runnable{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Producer&amp;nbsp;producer;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Consumer(Producer&amp;nbsp;producer)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.producer&amp;nbsp;=&amp;nbsp;producer;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String&amp;nbsp;message&amp;nbsp;=&amp;nbsp;producer.getMessage();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Get&amp;nbsp;message&amp;nbsp;"&amp;nbsp;+&amp;nbsp;message);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(2000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
}&lt;br&gt;
===&lt;br&gt;
package&amp;nbsp;waitandnotify.consumerproducer;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ConsumerProducerProgram&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Producer&amp;nbsp;producer&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Producer();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Consumer&amp;nbsp;consumer&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Consumer(producer);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(producer).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(consumer).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Get&amp;nbsp;message&amp;nbsp;Sun&amp;nbsp;Mar&amp;nbsp;23&amp;nbsp;09:51:07&amp;nbsp;EET&amp;nbsp;2014&lt;br&gt;
Get&amp;nbsp;message&amp;nbsp;Sun&amp;nbsp;Mar&amp;nbsp;23&amp;nbsp;09:51:08&amp;nbsp;EET&amp;nbsp;2014&lt;br&gt;
Get&amp;nbsp;message&amp;nbsp;Sun&amp;nbsp;Mar&amp;nbsp;23&amp;nbsp;09:51:09&amp;nbsp;EET&amp;nbsp;2014&lt;br&gt;
Get&amp;nbsp;message&amp;nbsp;Sun&amp;nbsp;Mar&amp;nbsp;23&amp;nbsp;09:51:10&amp;nbsp;EET&amp;nbsp;2014&lt;br&gt;
.....&lt;br&gt;
===========================================&lt;br&gt;
===&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;the&amp;nbsp;difference&amp;nbsp;between&amp;nbsp;wait&amp;nbsp;and&amp;nbsp;sleep&amp;nbsp;?&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;major&amp;nbsp;difference&amp;nbsp;is&amp;nbsp;that&amp;nbsp;wait()&amp;nbsp;releases&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;or&amp;nbsp;monitor&amp;nbsp;while&amp;nbsp;sleep()&amp;nbsp;doesn’t&lt;br&gt;
releases&amp;nbsp;any&amp;nbsp;lock&amp;nbsp;or&amp;nbsp;monitor&amp;nbsp;while&amp;nbsp;waiting.&amp;nbsp;Wait&amp;nbsp;is&amp;nbsp;used&amp;nbsp;for&amp;nbsp;inter-thread&amp;nbsp;communication&lt;br&gt;
while&amp;nbsp;sleep&amp;nbsp;is&amp;nbsp;used&amp;nbsp;to&amp;nbsp;introduce&amp;nbsp;pause&amp;nbsp;on&amp;nbsp;execution,&amp;nbsp;generally.&lt;br&gt;
&lt;br&gt;
Thread.sleep()&amp;nbsp;sends&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;into&amp;nbsp;the&amp;nbsp;“Not&amp;nbsp;Runnable”&amp;nbsp;state&amp;nbsp;for&amp;nbsp;some&lt;br&gt;
amount&amp;nbsp;of&amp;nbsp;time.&amp;nbsp;The&amp;nbsp;thread&amp;nbsp;__&amp;nbsp;keeps&amp;nbsp;the&amp;nbsp;monitors&amp;nbsp;it&amp;nbsp;has&amp;nbsp;acquired&amp;nbsp;—&amp;nbsp;i.e.&amp;nbsp;if&amp;nbsp;the&amp;nbsp;thread&lt;br&gt;
is&amp;nbsp;currently&amp;nbsp;in&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;block&amp;nbsp;or&amp;nbsp;method&amp;nbsp;no&amp;nbsp;other&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;enter&amp;nbsp;this&amp;nbsp;block&lt;br&gt;
or&amp;nbsp;method.&amp;nbsp;If&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;calls&amp;nbsp;t.interrupt()&amp;nbsp;it&amp;nbsp;will&amp;nbsp;wake&amp;nbsp;up&amp;nbsp;the&amp;nbsp;sleeping&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
!!!&amp;nbsp;Note&amp;nbsp;that&amp;nbsp;sleep&amp;nbsp;is&amp;nbsp;a&amp;nbsp;static&amp;nbsp;method,&amp;nbsp;which&amp;nbsp;means&amp;nbsp;that&amp;nbsp;it&amp;nbsp;always&amp;nbsp;affects&amp;nbsp;the&amp;nbsp;current&lt;br&gt;
thread&amp;nbsp;(the&amp;nbsp;one&amp;nbsp;that&amp;nbsp;is&amp;nbsp;executing&amp;nbsp;the&amp;nbsp;sleep&amp;nbsp;method).&amp;nbsp;A&amp;nbsp;common&amp;nbsp;mistake&amp;nbsp;is&amp;nbsp;to&amp;nbsp;call&lt;br&gt;
t.sleep()&amp;nbsp;where&amp;nbsp;t&amp;nbsp;is&amp;nbsp;a&amp;nbsp;different&amp;nbsp;thread;&amp;nbsp;even&amp;nbsp;then,&amp;nbsp;it&amp;nbsp;is&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;that&amp;nbsp;will&lt;br&gt;
sleep,&amp;nbsp;not&amp;nbsp;the&amp;nbsp;t&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
object.wait()&amp;nbsp;sends&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;into&amp;nbsp;the&amp;nbsp;“Not&amp;nbsp;Runnable”&amp;nbsp;state,&amp;nbsp;like&amp;nbsp;sleep(),&lt;br&gt;
but&amp;nbsp;with&amp;nbsp;a&amp;nbsp;twist.&amp;nbsp;Wait&amp;nbsp;is&amp;nbsp;called&amp;nbsp;on&amp;nbsp;an&amp;nbsp;object,&amp;nbsp;not&amp;nbsp;a&amp;nbsp;thread;&amp;nbsp;we&amp;nbsp;call&amp;nbsp;this&amp;nbsp;object&amp;nbsp;the&lt;br&gt;
“lock&amp;nbsp;object.”&amp;nbsp;Before&amp;nbsp;lock.wait()&amp;nbsp;is&amp;nbsp;called,&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;must&amp;nbsp;synchronize&amp;nbsp;on&lt;br&gt;
the&amp;nbsp;lock&amp;nbsp;object;&amp;nbsp;wait()&amp;nbsp;then&amp;nbsp;releases&amp;nbsp;this&amp;nbsp;lock,&amp;nbsp;and&amp;nbsp;adds&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;the&amp;nbsp;“wait&amp;nbsp;list”&amp;nbsp;!!&lt;br&gt;
associated&amp;nbsp;with&amp;nbsp;the&amp;nbsp;lock.&amp;nbsp;Later,&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;synchronize&amp;nbsp;on&amp;nbsp;the&amp;nbsp;same&amp;nbsp;lock&lt;br&gt;
object&amp;nbsp;and&amp;nbsp;call&amp;nbsp;lock.notify().&amp;nbsp;This&amp;nbsp;wakes&amp;nbsp;up&amp;nbsp;the&amp;nbsp;original,&amp;nbsp;waiting&amp;nbsp;thread.&lt;br&gt;
Basically,&amp;nbsp;wait()/notify()&amp;nbsp;is&amp;nbsp;like&amp;nbsp;sleep()/interrupt(),&amp;nbsp;only&amp;nbsp;the&amp;nbsp;active&amp;nbsp;thread&amp;nbsp;does&amp;nbsp;not&lt;br&gt;
need&amp;nbsp;a&amp;nbsp;direct&amp;nbsp;pointer&amp;nbsp;to&amp;nbsp;the&amp;nbsp;sleeping&amp;nbsp;thread,&amp;nbsp;but&amp;nbsp;only&amp;nbsp;to&amp;nbsp;the&amp;nbsp;shared&amp;nbsp;lock&amp;nbsp;object.&lt;br&gt;
&lt;br&gt;
synchronized(LOCK)&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1000);&amp;nbsp;//&amp;nbsp;LOCK&amp;nbsp;is&amp;nbsp;held&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
synchronized(LOCK)&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOCK.wait();&amp;nbsp;//&amp;nbsp;LOCK&amp;nbsp;is&amp;nbsp;not&amp;nbsp;held&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
=&lt;br&gt;
Let&amp;nbsp;categorize&amp;nbsp;all&amp;nbsp;above&amp;nbsp;points&amp;nbsp;:&lt;br&gt;
Call&amp;nbsp;on:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait():&amp;nbsp;Call&amp;nbsp;on&amp;nbsp;an&amp;nbsp;object;&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;must&amp;nbsp;synchronize&amp;nbsp;on&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;object.&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep():&amp;nbsp;Call&amp;nbsp;on&amp;nbsp;a&amp;nbsp;Thread;&amp;nbsp;always&amp;nbsp;currently&amp;nbsp;executing&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
Synchronized:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait():&amp;nbsp;when&amp;nbsp;synchronized&amp;nbsp;multiple&amp;nbsp;threads&amp;nbsp;access&amp;nbsp;same&amp;nbsp;Object&amp;nbsp;one&amp;nbsp;by&amp;nbsp;one.&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep():&amp;nbsp;when&amp;nbsp;synchronized&amp;nbsp;multiple&amp;nbsp;threads&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;sleep&amp;nbsp;over&amp;nbsp;of&amp;nbsp;sleeping&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
Hold&amp;nbsp;lock:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait():&amp;nbsp;release&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;for&amp;nbsp;other&amp;nbsp;objects&amp;nbsp;to&amp;nbsp;have&amp;nbsp;chance&amp;nbsp;to&amp;nbsp;execute.&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep():&amp;nbsp;keep&amp;nbsp;lock&amp;nbsp;for&amp;nbsp;at&amp;nbsp;least&amp;nbsp;t&amp;nbsp;times&amp;nbsp;if&amp;nbsp;timeout&amp;nbsp;specified&amp;nbsp;or&amp;nbsp;somebody&amp;nbsp;interrupt.&lt;br&gt;
&lt;br&gt;
Wake-up&amp;nbsp;condition:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait():&amp;nbsp;until&amp;nbsp;call&amp;nbsp;notify(),&amp;nbsp;notifyAll()&amp;nbsp;from&amp;nbsp;object&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep():&amp;nbsp;until&amp;nbsp;at&amp;nbsp;least&amp;nbsp;time&amp;nbsp;expire&amp;nbsp;or&amp;nbsp;call&amp;nbsp;interrupt().&lt;br&gt;
&lt;br&gt;
Usage:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep():&amp;nbsp;for&amp;nbsp;time-synchronization&amp;nbsp;and;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait():&amp;nbsp;for&amp;nbsp;multi-thread-synchronization.&lt;br&gt;
===========</questionanswer>
  </question>
  <question id="1_0_0_3_0:6" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;ThreadLocal&amp;nbsp;objects,&amp;nbsp;describe.&lt;br&gt;
Provide&amp;nbsp;examples.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
A&amp;nbsp;common&amp;nbsp;issue&amp;nbsp;that&amp;nbsp;arises&amp;nbsp;is&amp;nbsp;the&amp;nbsp;need&amp;nbsp;to&amp;nbsp;maintain&amp;nbsp;some&amp;nbsp;information&lt;br&gt;
or&amp;nbsp;state&amp;nbsp;on&amp;nbsp;a&amp;nbsp;perthread&amp;nbsp;basis.&amp;nbsp;For&amp;nbsp;example,&amp;nbsp;we&amp;nbsp;might&amp;nbsp;want&amp;nbsp;to&amp;nbsp;carry&amp;nbsp;some&lt;br&gt;
context&amp;nbsp;with&amp;nbsp;the&amp;nbsp;!!&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;as&amp;nbsp;it&amp;nbsp;executes&amp;nbsp;our&amp;nbsp;application.&amp;nbsp;Or&amp;nbsp;we&amp;nbsp;might&lt;br&gt;
simply&amp;nbsp;want&amp;nbsp;to&amp;nbsp;have&amp;nbsp;a&amp;nbsp;__&amp;nbsp;value&amp;nbsp;that&amp;nbsp;is&amp;nbsp;different&amp;nbsp;for&amp;nbsp;different&amp;nbsp;threads__&amp;nbsp;in&amp;nbsp;the&amp;nbsp;same&lt;br&gt;
way&amp;nbsp;that&amp;nbsp;each&amp;nbsp;thread&amp;nbsp;“sees”&amp;nbsp;its&amp;nbsp;own&amp;nbsp;local&amp;nbsp;variables&amp;nbsp;in&amp;nbsp;a&amp;nbsp;method.&amp;nbsp;Java&amp;nbsp;supports&lt;br&gt;
this&amp;nbsp;through&amp;nbsp;the&amp;nbsp;ThreadLocal&amp;nbsp;class.&amp;nbsp;&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;ThreadLocal&amp;nbsp;is&amp;nbsp;an&amp;nbsp;object&amp;nbsp;wrapper&amp;nbsp;that&amp;nbsp;automatically&amp;nbsp;maintains&amp;nbsp;a&amp;nbsp;separate&amp;nbsp;value&amp;nbsp;for&lt;br&gt;
any&amp;nbsp;thread&amp;nbsp;calling&amp;nbsp;it.&amp;nbsp;For&amp;nbsp;example:&lt;br&gt;
&lt;br&gt;
ThreadLocal&amp;nbsp;userID&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ThreadLocal();&lt;br&gt;
userID.set("Pat");&amp;nbsp;//&amp;nbsp;called&amp;nbsp;by&amp;nbsp;thread&amp;nbsp;1&lt;br&gt;
userID.set("Bob");&amp;nbsp;//&amp;nbsp;called&amp;nbsp;by&amp;nbsp;thread&amp;nbsp;2&lt;br&gt;
userID.get();&amp;nbsp;//&amp;nbsp;thread&amp;nbsp;1&amp;nbsp;gets&amp;nbsp;"Pat"&lt;br&gt;
userID.get();&amp;nbsp;//&amp;nbsp;thread&amp;nbsp;2&amp;nbsp;gets&amp;nbsp;"Bob"&lt;br&gt;
&lt;br&gt;
ThreadLocals&amp;nbsp;are&amp;nbsp;implemented&amp;nbsp;using&amp;nbsp;a&amp;nbsp;Map&amp;nbsp;attached&amp;nbsp;to&amp;nbsp;each&amp;nbsp;Thread&lt;br&gt;
instance,&amp;nbsp;so&amp;nbsp;their&amp;nbsp;values&amp;nbsp;will&amp;nbsp;disappear&amp;nbsp;when&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;is&amp;nbsp;no&amp;nbsp;longer&amp;nbsp;used&amp;nbsp;and&lt;br&gt;
garbage&amp;nbsp;is&amp;nbsp;collected.&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;useful&amp;nbsp;addition&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;7&amp;nbsp;is&amp;nbsp;the&amp;nbsp;ThreadLocalRandom&amp;nbsp;class,&amp;nbsp;which&amp;nbsp;is&amp;nbsp;an&lt;br&gt;
extension&amp;nbsp;of&amp;nbsp;the&amp;nbsp;java.util.Random&amp;nbsp;class&amp;nbsp;discussed&amp;nbsp;in&amp;nbsp;Chapter&amp;nbsp;11.&amp;nbsp;The&lt;br&gt;
ThreadLocalRandom&amp;nbsp;class&amp;nbsp;eliminates&amp;nbsp;contention&amp;nbsp;(waiting&amp;nbsp;due&amp;nbsp;to&lt;br&gt;
synchronization)&amp;nbsp;on&amp;nbsp;the&amp;nbsp;random-number&amp;nbsp;generator&amp;nbsp;when&amp;nbsp;called&amp;nbsp;from&amp;nbsp;different&amp;nbsp;threads.&lt;br&gt;
&lt;br&gt;
!!!!&lt;br&gt;
ThreadLocal&amp;nbsp;instances&amp;nbsp;are&amp;nbsp;typically&amp;nbsp;private&amp;nbsp;static&amp;nbsp;fields&amp;nbsp;in&amp;nbsp;classes&amp;nbsp;that&amp;nbsp;wish&amp;nbsp;to&amp;nbsp;associate&lt;br&gt;
state&amp;nbsp;with&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;(e.g.,&amp;nbsp;a&amp;nbsp;user&amp;nbsp;ID&amp;nbsp;or&amp;nbsp;Transaction&amp;nbsp;ID).&lt;br&gt;
===&lt;br&gt;
Method&amp;nbsp;Summary&lt;br&gt;
&lt;br&gt;
Methods&amp;nbsp;&lt;br&gt;
Modifier&amp;nbsp;and&amp;nbsp;Type&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Method&amp;nbsp;and&amp;nbsp;Description&lt;br&gt;
-&amp;nbsp;T&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;get()&lt;br&gt;
Returns&amp;nbsp;the&amp;nbsp;value&amp;nbsp;in&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread's&amp;nbsp;copy&amp;nbsp;of&amp;nbsp;this&amp;nbsp;thread-local&amp;nbsp;variable.&lt;br&gt;
-&amp;nbsp;protected&amp;nbsp;T&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initialValue()&lt;br&gt;
Returns&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread's&amp;nbsp;"initial&amp;nbsp;value"&amp;nbsp;for&amp;nbsp;this&amp;nbsp;thread-local&amp;nbsp;variable.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;remove()&lt;br&gt;
Removes&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread's&amp;nbsp;value&amp;nbsp;for&amp;nbsp;this&amp;nbsp;thread-local&amp;nbsp;variable.&lt;br&gt;
-&amp;nbsp;void&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;set(T&amp;nbsp;value)&lt;br&gt;
Sets&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread's&amp;nbsp;copy&amp;nbsp;of&amp;nbsp;this&amp;nbsp;thread-local&amp;nbsp;variable&amp;nbsp;to&amp;nbsp;the&amp;nbsp;specified&amp;nbsp;value.&lt;br&gt;
===&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
===================================================&lt;br&gt;
===================================================&lt;br&gt;
EXAMPLE&amp;nbsp;:&amp;nbsp;&lt;br&gt;
package&amp;nbsp;synchronization;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.Random;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ThreadLocalExample&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//!!!!&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;ThreadLocal&lt;String&gt;&amp;nbsp;threadLocalValue&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ThreadLocal&lt;String&gt;(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;protected&amp;nbsp;String&amp;nbsp;initialValue()&amp;nbsp;{&amp;nbsp;//&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;"default&amp;nbsp;value";&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;OPTIONAL&amp;nbsp;BLOCK&amp;nbsp;to&amp;nbsp;set&amp;nbsp;default&amp;nbsp;value&amp;nbsp;of&amp;nbsp;ThreadLocal&amp;nbsp;Object&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Thread&amp;nbsp;Name=&amp;nbsp;"&amp;nbsp;+&amp;nbsp;Thread.currentThread().getName()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;"&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;"&amp;nbsp;+&amp;nbsp;threadLocalValue.get());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;nextValue&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Random().nextInt(1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(nextValue);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;threadLocalValue.set(nextValue&amp;nbsp;+&amp;nbsp;"");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Thread&amp;nbsp;Name=&amp;nbsp;"&amp;nbsp;+&amp;nbsp;Thread.currentThread().getName()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;"&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;"&amp;nbsp;+&amp;nbsp;threadLocalValue.get());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadLocalExample&amp;nbsp;example&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ThreadLocalExample();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(example,&amp;nbsp;i&amp;nbsp;+&amp;nbsp;"");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(new&amp;nbsp;Random().nextInt(1000));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(9000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadLocalExample.threadLocalValue.set("hello&amp;nbsp;,&amp;nbsp;i&amp;nbsp;am&amp;nbsp;thread&amp;nbsp;local&amp;nbsp;in&amp;nbsp;main");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("In&amp;nbsp;main&amp;nbsp;Thread&amp;nbsp;:&amp;nbsp;"&amp;nbsp;+&amp;nbsp;ThreadLocalExample.threadLocalValue.get());//&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;0&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;0&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;319&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;1&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;1&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;338&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;2&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;3&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;4&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;2&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;814&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;3&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;909&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;5&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;6&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;6&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;211&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;5&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;408&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;4&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;964&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;7&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;8&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;8&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;253&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;9&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;default&amp;nbsp;value&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;9&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;80&lt;br&gt;
Thread&amp;nbsp;Name=&amp;nbsp;7&amp;nbsp;default&amp;nbsp;Formatter&amp;nbsp;=&amp;nbsp;944&lt;br&gt;
In&amp;nbsp;main&amp;nbsp;Thread&amp;nbsp;:&amp;nbsp;hello&amp;nbsp;,&amp;nbsp;i&amp;nbsp;am&amp;nbsp;thread&amp;nbsp;local&amp;nbsp;in&amp;nbsp;main&lt;br&gt;
========================================&lt;br&gt;
IMPLEMENTATION&amp;nbsp;OF&amp;nbsp;ThreadLocal:&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ThreadLocal&lt;T&gt;&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;final&amp;nbsp;int&amp;nbsp;threadLocalHashCode&amp;nbsp;=&amp;nbsp;nextHashCode();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;AtomicInteger&amp;nbsp;nextHashCode&amp;nbsp;=&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;AtomicInteger();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;protected&amp;nbsp;T&amp;nbsp;initialValue()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;null;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;ThreadLocal()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;T&amp;nbsp;get()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t&amp;nbsp;=&amp;nbsp;Thread.currentThread();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadLocalMap&amp;nbsp;map&amp;nbsp;=&amp;nbsp;getMap(t);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(map&amp;nbsp;!=&amp;nbsp;null)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadLocalMap.Entry&amp;nbsp;e&amp;nbsp;=&amp;nbsp;map.getEntry(this);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(e&amp;nbsp;!=&amp;nbsp;null)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;(T)e.value;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;setInitialValue();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;set(T&amp;nbsp;value)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t&amp;nbsp;=&amp;nbsp;Thread.currentThread();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadLocalMap&amp;nbsp;map&amp;nbsp;=&amp;nbsp;getMap(t);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(map&amp;nbsp;!=&amp;nbsp;null)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;map.set(this,&amp;nbsp;value);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;createMap(t,&amp;nbsp;value);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;remove()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadLocalMap&amp;nbsp;m&amp;nbsp;=&amp;nbsp;getMap(Thread.currentThread());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(m&amp;nbsp;!=&amp;nbsp;null)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m.remove(this);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;class&amp;nbsp;ThreadLocalMap&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;class&amp;nbsp;Entry&amp;nbsp;extends&amp;nbsp;WeakReference&lt;ThreadLocal&gt;&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/**&amp;nbsp;The&amp;nbsp;value&amp;nbsp;associated&amp;nbsp;with&amp;nbsp;this&amp;nbsp;ThreadLocal.&amp;nbsp;*/&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object&amp;nbsp;value;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Entry(ThreadLocal&amp;nbsp;k,&amp;nbsp;Object&amp;nbsp;v)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;super(k);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value&amp;nbsp;=&amp;nbsp;v;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;int&amp;nbsp;INITIAL_CAPACITY&amp;nbsp;=&amp;nbsp;16;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/**&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*&amp;nbsp;The&amp;nbsp;table,&amp;nbsp;resized&amp;nbsp;as&amp;nbsp;necessary.&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*&amp;nbsp;table.length&amp;nbsp;MUST&amp;nbsp;always&amp;nbsp;be&amp;nbsp;a&amp;nbsp;power&amp;nbsp;of&amp;nbsp;two.&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;Entry[]&amp;nbsp;table;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadLocalMap(ThreadLocal&amp;nbsp;firstKey,&amp;nbsp;Object&amp;nbsp;firstValue)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;table&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Entry[INITIAL_CAPACITY];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;firstKey.threadLocalHashCode&amp;nbsp;&amp;&amp;nbsp;(INITIAL_CAPACITY&amp;nbsp;-&amp;nbsp;1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;table[i]&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Entry(firstKey,&amp;nbsp;firstValue);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;size&amp;nbsp;=&amp;nbsp;1;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setThreshold(INITIAL_CAPACITY);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;ThreadLocalMap(ThreadLocalMap&amp;nbsp;parentMap)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Entry[]&amp;nbsp;parentTable&amp;nbsp;=&amp;nbsp;parentMap.table;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;len&amp;nbsp;=&amp;nbsp;parentTable.length;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setThreshold(len);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;table&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Entry[len];&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;j&amp;nbsp;&lt;&amp;nbsp;len;&amp;nbsp;j++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Entry&amp;nbsp;e&amp;nbsp;=&amp;nbsp;parentTable[j];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(e&amp;nbsp;!=&amp;nbsp;null)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadLocal&amp;nbsp;key&amp;nbsp;=&amp;nbsp;e.get();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(key&amp;nbsp;!=&amp;nbsp;null)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object&amp;nbsp;value&amp;nbsp;=&amp;nbsp;key.childValue(e.value);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Entry&amp;nbsp;c&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Entry(key,&amp;nbsp;value);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;h&amp;nbsp;=&amp;nbsp;key.threadLocalHashCode&amp;nbsp;&amp;&amp;nbsp;(len&amp;nbsp;-&amp;nbsp;1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(table[h]&amp;nbsp;!=&amp;nbsp;null)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;h&amp;nbsp;=&amp;nbsp;nextIndex(h,&amp;nbsp;len);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;table[h]&amp;nbsp;=&amp;nbsp;c;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;size++;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;........&lt;br&gt;
}</questionanswer>
  </question>
  <question id="1_0_0_3_0:7" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;&amp;nbsp;Scheduling&amp;nbsp;and&amp;nbsp;Priority,&amp;nbsp;describe.&lt;br&gt;
In&amp;nbsp;which&amp;nbsp;states&amp;nbsp;Thread&amp;nbsp;can&amp;nbsp;be&amp;nbsp;?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
Java&amp;nbsp;makes&amp;nbsp;few&amp;nbsp;guarantees&amp;nbsp;about&amp;nbsp;how&amp;nbsp;it&amp;nbsp;schedules&amp;nbsp;threads.&amp;nbsp;Almost&amp;nbsp;all&lt;br&gt;
of&amp;nbsp;Java’s&amp;nbsp;thread&amp;nbsp;scheduling&amp;nbsp;is&amp;nbsp;left&amp;nbsp;up&amp;nbsp;to&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;implementation&amp;nbsp;and,&lt;br&gt;
to&amp;nbsp;some&amp;nbsp;degree,&amp;nbsp;the&amp;nbsp;application.&amp;nbsp;Although&amp;nbsp;it&amp;nbsp;might&amp;nbsp;have&amp;nbsp;made&amp;nbsp;sense&lt;br&gt;
(and&amp;nbsp;would&amp;nbsp;certainly&amp;nbsp;have&amp;nbsp;made&amp;nbsp;many&amp;nbsp;developers&amp;nbsp;happier)&amp;nbsp;if&amp;nbsp;Java’s&lt;br&gt;
developers&amp;nbsp;had&amp;nbsp;specified&amp;nbsp;a&amp;nbsp;scheduling&amp;nbsp;algorithm,&amp;nbsp;a&amp;nbsp;single&amp;nbsp;algorithm&lt;br&gt;
isn’t&amp;nbsp;necessarily&amp;nbsp;suitable&amp;nbsp;for&amp;nbsp;all&amp;nbsp;the&amp;nbsp;roles&amp;nbsp;that&amp;nbsp;Java&amp;nbsp;can&amp;nbsp;play.&amp;nbsp;Instead,&lt;br&gt;
Java’s&amp;nbsp;designers&amp;nbsp;put&amp;nbsp;the&amp;nbsp;burden&amp;nbsp;on&amp;nbsp;you&amp;nbsp;to&amp;nbsp;write&amp;nbsp;robust&amp;nbsp;code&amp;nbsp;that&amp;nbsp;works&lt;br&gt;
no&amp;nbsp;matter&amp;nbsp;the&amp;nbsp;scheduling&amp;nbsp;algorithm,&amp;nbsp;and&amp;nbsp;let&amp;nbsp;the&amp;nbsp;implementation&amp;nbsp;tune&amp;nbsp;the&lt;br&gt;
algorithm&amp;nbsp;for&amp;nbsp;the&amp;nbsp;best&amp;nbsp;fit.&lt;br&gt;
&lt;br&gt;
Every&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;a&amp;nbsp;priority&amp;nbsp;value.&amp;nbsp;In&amp;nbsp;general,&amp;nbsp;any&amp;nbsp;time&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;of&amp;nbsp;a&amp;nbsp;higher&lt;br&gt;
priority&amp;nbsp;than&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread&amp;nbsp;becomes&amp;nbsp;runnable&amp;nbsp;(is&amp;nbsp;started,&amp;nbsp;stops&lt;br&gt;
sleeping,&amp;nbsp;or&amp;nbsp;is&amp;nbsp;notified),&amp;nbsp;it&amp;nbsp;preempts&amp;nbsp;the&amp;nbsp;lower-priority&amp;nbsp;thread&amp;nbsp;and&amp;nbsp;begins&lt;br&gt;
executing.&amp;nbsp;By&amp;nbsp;default,&amp;nbsp;threads&amp;nbsp;with&amp;nbsp;the&amp;nbsp;same&amp;nbsp;priority&amp;nbsp;are&amp;nbsp;scheduled&amp;nbsp;round-robin,&lt;br&gt;
which&amp;nbsp;means&amp;nbsp;once&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;starts&amp;nbsp;to&amp;nbsp;run,&amp;nbsp;it&amp;nbsp;continues&amp;nbsp;until&amp;nbsp;it&amp;nbsp;does&lt;br&gt;
one&amp;nbsp;of&amp;nbsp;the&amp;nbsp;following:&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Sleeps,&amp;nbsp;by&amp;nbsp;calling&amp;nbsp;Thread.sleep()&amp;nbsp;or&amp;nbsp;wait()&lt;br&gt;
-&amp;nbsp;Waits&amp;nbsp;for&amp;nbsp;a&amp;nbsp;lock,&amp;nbsp;in&amp;nbsp;order&amp;nbsp;to&amp;nbsp;run&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;method&lt;br&gt;
-&amp;nbsp;Blocks&amp;nbsp;on&amp;nbsp;I/O,&amp;nbsp;for&amp;nbsp;example,&amp;nbsp;in&amp;nbsp;a&amp;nbsp;read()&amp;nbsp;or&amp;nbsp;accept()&amp;nbsp;call&lt;br&gt;
-&amp;nbsp;Explicitly&amp;nbsp;yields&amp;nbsp;control,&amp;nbsp;by&amp;nbsp;calling&amp;nbsp;yield()&lt;br&gt;
-&amp;nbsp;Terminates,&amp;nbsp;by&amp;nbsp;completing&amp;nbsp;its&amp;nbsp;target&amp;nbsp;method&amp;nbsp;or&amp;nbsp;with&amp;nbsp;a&amp;nbsp;stop()&amp;nbsp;call&amp;nbsp;(deprecated)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&lt;br&gt;
package&amp;nbsp;threadspriorityandstate;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ThreadPriorityExample&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;MyT(),&amp;nbsp;"t1");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;MyT(),&amp;nbsp;"t22222222222");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.setPriority(Thread.MIN_PRIORITY);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.setPriority(Thread.MAX_PRIORITY);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.start();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;MyT&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;100;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
==&lt;br&gt;
We&amp;nbsp;would&amp;nbsp;expect&amp;nbsp;that&amp;nbsp;with&amp;nbsp;this&amp;nbsp;change&amp;nbsp;to&amp;nbsp;our&amp;nbsp;Thready&amp;nbsp;class,&amp;nbsp;the&amp;nbsp;t1&amp;nbsp;thread&lt;br&gt;
would&amp;nbsp;take&amp;nbsp;over&amp;nbsp;completely.&amp;nbsp;If&amp;nbsp;you&amp;nbsp;run&amp;nbsp;this&amp;nbsp;code&amp;nbsp;on&amp;nbsp;the&amp;nbsp;Solaris&amp;nbsp;implementation&lt;br&gt;
of&amp;nbsp;Java&amp;nbsp;5.0,&amp;nbsp;that’s&amp;nbsp;what&amp;nbsp;happens.&amp;nbsp;The&amp;nbsp;same&amp;nbsp;is&amp;nbsp;not&amp;nbsp;true&amp;nbsp;on&amp;nbsp;Windows&amp;nbsp;or&amp;nbsp;with&lt;br&gt;
some&amp;nbsp;older&amp;nbsp;versions&amp;nbsp;of&amp;nbsp;Java.&amp;nbsp;Similarly,&amp;nbsp;if&amp;nbsp;you&amp;nbsp;change&amp;nbsp;the&amp;nbsp;priorities&amp;nbsp;to&amp;nbsp;values&amp;nbsp;other&lt;br&gt;
than&amp;nbsp;min&amp;nbsp;and&amp;nbsp;max,&amp;nbsp;you&amp;nbsp;may&amp;nbsp;not&amp;nbsp;see&amp;nbsp;any&amp;nbsp;difference&amp;nbsp;at&amp;nbsp;all.&amp;nbsp;The&amp;nbsp;subtleties&lt;br&gt;
relating&amp;nbsp;to&amp;nbsp;priority&amp;nbsp;and&amp;nbsp;performance&amp;nbsp;relate&amp;nbsp;to&amp;nbsp;how&amp;nbsp;Java&amp;nbsp;threads&amp;nbsp;and&amp;nbsp;priorities&lt;br&gt;
are&amp;nbsp;mapped&amp;nbsp;to&amp;nbsp;real&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;the&amp;nbsp;OS.&amp;nbsp;For&amp;nbsp;this&amp;nbsp;reason,&amp;nbsp;thread&amp;nbsp;priorities&amp;nbsp;should&lt;br&gt;
be&amp;nbsp;reserved&amp;nbsp;for&amp;nbsp;system&amp;nbsp;and&amp;nbsp;framework&amp;nbsp;development.&lt;br&gt;
&lt;br&gt;
!!!!!!!&amp;nbsp;(Rarely&amp;nbsp;-&amp;nbsp;ridko)&lt;br&gt;
&amp;nbsp;Why-thread-priority-rarely-matters&lt;br&gt;
If&amp;nbsp;you&amp;nbsp;have&amp;nbsp;plenty&amp;nbsp;of&amp;nbsp;free&amp;nbsp;CPU,&amp;nbsp;every&amp;nbsp;thread&amp;nbsp;which&amp;nbsp;can&amp;nbsp;run&amp;nbsp;will&amp;nbsp;run.&amp;nbsp;The&amp;nbsp;OS&lt;br&gt;
has&amp;nbsp;no&amp;nbsp;reason&amp;nbsp;not&amp;nbsp;to&amp;nbsp;run&amp;nbsp;a&amp;nbsp;low&amp;nbsp;priority&amp;nbsp;thread&amp;nbsp;or&amp;nbsp;process&amp;nbsp;when&amp;nbsp;it&amp;nbsp;has&amp;nbsp;free&lt;br&gt;
resources.&amp;nbsp;If&amp;nbsp;your&amp;nbsp;system&amp;nbsp;is&amp;nbsp;close&amp;nbsp;to&amp;nbsp;100%&amp;nbsp;of&amp;nbsp;CPU&amp;nbsp;on&amp;nbsp;every&amp;nbsp;core,&amp;nbsp;the&amp;nbsp;OS&amp;nbsp;has&amp;nbsp;to&lt;br&gt;
make&amp;nbsp;a&amp;nbsp;choice&amp;nbsp;as&amp;nbsp;to&amp;nbsp;how&amp;nbsp;much&amp;nbsp;time&amp;nbsp;each&amp;nbsp;thread&amp;nbsp;or&amp;nbsp;process&amp;nbsp;gets&amp;nbsp;on&amp;nbsp;the&amp;nbsp;CPU&lt;br&gt;
and&amp;nbsp;it&amp;nbsp;is&amp;nbsp;likely&amp;nbsp;to&amp;nbsp;give&amp;nbsp;favour&amp;nbsp;to&amp;nbsp;higher&amp;nbsp;priority&amp;nbsp;threads&amp;nbsp;over&amp;nbsp;lower&amp;nbsp;priority&amp;nbsp;threads,&lt;br&gt;
(many&amp;nbsp;OSes&amp;nbsp;ignore&amp;nbsp;the&amp;nbsp;hint)&amp;nbsp;and&amp;nbsp;other&amp;nbsp;factors&amp;nbsp;are&amp;nbsp;likely&amp;nbsp;to&amp;nbsp;matter&amp;nbsp;as&amp;nbsp;well.&lt;br&gt;
This&amp;nbsp;priority&amp;nbsp;only&amp;nbsp;extends&amp;nbsp;to&amp;nbsp;raw&amp;nbsp;CPU.&amp;nbsp;Threads&amp;nbsp;compete&amp;nbsp;equally&amp;nbsp;for&amp;nbsp;CPU&amp;nbsp;cache,&lt;br&gt;
heap&amp;nbsp;space,&amp;nbsp;CPU&amp;nbsp;to&amp;nbsp;memory&amp;nbsp;bandwidth,&amp;nbsp;file&amp;nbsp;cache,&amp;nbsp;disk&amp;nbsp;IO,&amp;nbsp;network&amp;nbsp;IO&amp;nbsp;and&lt;br&gt;
everything&amp;nbsp;else.&amp;nbsp;If&amp;nbsp;any&amp;nbsp;of&amp;nbsp;these&amp;nbsp;resource&amp;nbsp;are&amp;nbsp;in&amp;nbsp;competition,&amp;nbsp;they&amp;nbsp;are&amp;nbsp;all&amp;nbsp;equal.&lt;br&gt;
&lt;br&gt;
To&amp;nbsp;set&amp;nbsp;a&amp;nbsp;high&amp;nbsp;priority&amp;nbsp;on&amp;nbsp;Windows&amp;nbsp;you&amp;nbsp;need&amp;nbsp;to&amp;nbsp;be&amp;nbsp;an&amp;nbsp;administrator&amp;nbsp;and&amp;nbsp;on&lt;br&gt;
Linux&amp;nbsp;you&amp;nbsp;need&amp;nbsp;to&amp;nbsp;be&amp;nbsp;root&amp;nbsp;to&amp;nbsp;set&amp;nbsp;the&amp;nbsp;priority&amp;nbsp;of&amp;nbsp;a&amp;nbsp;thread.&lt;br&gt;
Different&amp;nbsp;Implementations&amp;nbsp;and&amp;nbsp;OSes&amp;nbsp;can&amp;nbsp;ignore&amp;nbsp;this&amp;nbsp;hint.&lt;br&gt;
&lt;br&gt;
============================================&lt;br&gt;
Thread&amp;nbsp;State&lt;br&gt;
&amp;nbsp;At&amp;nbsp;any&amp;nbsp;given&amp;nbsp;time,&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;in&amp;nbsp;one&amp;nbsp;of&amp;nbsp;five&amp;nbsp;general&amp;nbsp;states&amp;nbsp;that&amp;nbsp;encompass&lt;br&gt;
its&amp;nbsp;lifecycle&amp;nbsp;and&amp;nbsp;activities.&amp;nbsp;These&amp;nbsp;states&amp;nbsp;are&amp;nbsp;defined&amp;nbsp;in&amp;nbsp;the&amp;nbsp;Thread.State&lt;br&gt;
enumeration&amp;nbsp;and&amp;nbsp;queried&amp;nbsp;via&amp;nbsp;the&amp;nbsp;getState()&amp;nbsp;method&amp;nbsp;of&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;class:&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;NEW&lt;br&gt;
The&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;been&amp;nbsp;created&amp;nbsp;but&amp;nbsp;not&amp;nbsp;yet&amp;nbsp;started.&lt;br&gt;
-&amp;nbsp;RUNNABLE&lt;br&gt;
The&amp;nbsp;normal&amp;nbsp;active&amp;nbsp;state&amp;nbsp;of&amp;nbsp;a&amp;nbsp;running&amp;nbsp;thread,&amp;nbsp;including&amp;nbsp;the&amp;nbsp;time&amp;nbsp;when&amp;nbsp;a&lt;br&gt;
thread&amp;nbsp;is&amp;nbsp;blocked&amp;nbsp;in&amp;nbsp;an&amp;nbsp;I/O&amp;nbsp;operation,&amp;nbsp;like&amp;nbsp;a&amp;nbsp;read&amp;nbsp;or&amp;nbsp;write&amp;nbsp;or&amp;nbsp;network&lt;br&gt;
connection.&lt;br&gt;
-&amp;nbsp;BLOCKED&lt;br&gt;
The&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;blocked,&amp;nbsp;waiting&amp;nbsp;to&amp;nbsp;enter&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;method&amp;nbsp;or&amp;nbsp;code&lt;br&gt;
block.&amp;nbsp;This&amp;nbsp;includes&amp;nbsp;the&amp;nbsp;time&amp;nbsp;when&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;been&amp;nbsp;awakened&amp;nbsp;by&amp;nbsp;a&lt;br&gt;
notify()&amp;nbsp;and&amp;nbsp;is&amp;nbsp;attempting&amp;nbsp;to&amp;nbsp;reacquire&amp;nbsp;its&amp;nbsp;lock&amp;nbsp;after&amp;nbsp;a&amp;nbsp;wait().&lt;br&gt;
-&amp;nbsp;WAITING,&amp;nbsp;TIMED_WAITING&lt;br&gt;
The&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;via&amp;nbsp;a&amp;nbsp;call&amp;nbsp;to&amp;nbsp;wait()&amp;nbsp;or&amp;nbsp;join().&amp;nbsp;In&amp;nbsp;the&lt;br&gt;
case&amp;nbsp;of&amp;nbsp;TIMED_WAITING,&amp;nbsp;the&amp;nbsp;call&amp;nbsp;has&amp;nbsp;a&amp;nbsp;timeout.&lt;br&gt;
-&amp;nbsp;TERMINATED&lt;br&gt;
The&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;completed&amp;nbsp;due&amp;nbsp;to&amp;nbsp;a&amp;nbsp;return,&amp;nbsp;an&amp;nbsp;exception,&amp;nbsp;or&amp;nbsp;being&amp;nbsp;stopped.&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:8" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;What&amp;nbsp;is&amp;nbsp;the&amp;nbsp;difference&amp;nbsp;between&amp;nbsp;preemptive&amp;nbsp;scheduling&amp;nbsp;and&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;time&amp;nbsp;slicing?&amp;#0;&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>Preemptive&amp;nbsp;scheduling:&amp;nbsp;The&amp;nbsp;highest&amp;nbsp;priority&amp;nbsp;task&amp;nbsp;executes&amp;nbsp;until&amp;nbsp;it&amp;nbsp;enters&lt;br&gt;
the&amp;nbsp;waiting&amp;nbsp;or&amp;nbsp;dead&amp;nbsp;states&amp;nbsp;or&amp;nbsp;a&amp;nbsp;higher&amp;nbsp;priority&amp;nbsp;task&amp;nbsp;comes&amp;nbsp;into&amp;nbsp;existence.&lt;br&gt;
&lt;br&gt;
Time&amp;nbsp;slicing:&amp;nbsp;A&amp;nbsp;task&amp;nbsp;executes&amp;nbsp;for&amp;nbsp;a&amp;nbsp;predefined&amp;nbsp;slice&amp;nbsp;of&amp;nbsp;time&amp;nbsp;and&amp;nbsp;then&amp;nbsp;reenters&lt;br&gt;
the&amp;nbsp;pool&amp;nbsp;of&amp;nbsp;ready&amp;nbsp;tasks.&amp;nbsp;The&amp;nbsp;scheduler&amp;nbsp;then&amp;nbsp;determines&amp;nbsp;which&amp;nbsp;task&amp;nbsp;should&amp;nbsp;execute&lt;br&gt;
next,&amp;nbsp;based&amp;nbsp;on&amp;nbsp;priority&amp;nbsp;and&amp;nbsp;other&amp;nbsp;factors&lt;br&gt;
&lt;br&gt;
==========&lt;br&gt;
Wiki&amp;nbsp;:&amp;nbsp;&lt;br&gt;
Fixed-priority&amp;nbsp;pre-emptive&amp;nbsp;scheduling&amp;nbsp;is&amp;nbsp;a&amp;nbsp;scheduling&amp;nbsp;system&amp;nbsp;commonly&amp;nbsp;used&amp;nbsp;in&lt;br&gt;
real-time&amp;nbsp;systems.&amp;nbsp;With&amp;nbsp;fixed&amp;nbsp;priority&amp;nbsp;pre-emptive&amp;nbsp;scheduling,&amp;nbsp;the&amp;nbsp;scheduler&lt;br&gt;
ensures&amp;nbsp;that&amp;nbsp;at&amp;nbsp;any&amp;nbsp;given&amp;nbsp;time,&amp;nbsp;the&amp;nbsp;processor&amp;nbsp;executes&amp;nbsp;the&amp;nbsp;highest&amp;nbsp;priority&amp;nbsp;task&lt;br&gt;
of&amp;nbsp;all&amp;nbsp;those&amp;nbsp;tasks&amp;nbsp;that&amp;nbsp;are&amp;nbsp;currently&amp;nbsp;ready&amp;nbsp;to&amp;nbsp;execute.&lt;br&gt;
The&amp;nbsp;pre-emptive&amp;nbsp;scheduler&amp;nbsp;has&amp;nbsp;a&amp;nbsp;clock&amp;nbsp;interrupt&amp;nbsp;task&amp;nbsp;that&amp;nbsp;can&amp;nbsp;provide&amp;nbsp;the&lt;br&gt;
scheduler&amp;nbsp;with&amp;nbsp;options&amp;nbsp;to&amp;nbsp;switch&amp;nbsp;after&amp;nbsp;the&amp;nbsp;task&amp;nbsp;has&amp;nbsp;had&amp;nbsp;a&amp;nbsp;given&amp;nbsp;period&amp;nbsp;to&lt;br&gt;
execute—the&amp;nbsp;time&amp;nbsp;slice.&amp;nbsp;This&amp;nbsp;scheduling&amp;nbsp;system&amp;nbsp;has&amp;nbsp;the&amp;nbsp;advantage&amp;nbsp;of&amp;nbsp;making&lt;br&gt;
sure&amp;nbsp;no&amp;nbsp;task&amp;nbsp;hogs&amp;nbsp;the&amp;nbsp;processor&amp;nbsp;for&amp;nbsp;any&amp;nbsp;time&amp;nbsp;longer&amp;nbsp;than&amp;nbsp;the&amp;nbsp;time&amp;nbsp;slice.&amp;nbsp;However,&lt;br&gt;
this&amp;nbsp;scheduling&amp;nbsp;scheme&amp;nbsp;is&amp;nbsp;vulnerable&amp;nbsp;to&amp;nbsp;process&amp;nbsp;or&amp;nbsp;thread&amp;nbsp;lockout:&amp;nbsp;since&amp;nbsp;priority&lt;br&gt;
is&amp;nbsp;given&amp;nbsp;to&amp;nbsp;higher-priority&amp;nbsp;tasks,&amp;nbsp;the&amp;nbsp;lower-priority&amp;nbsp;tasks&amp;nbsp;could&amp;nbsp;wait&amp;nbsp;an&amp;nbsp;indefinite&lt;br&gt;
amount&amp;nbsp;of&amp;nbsp;time.&amp;nbsp;One&amp;nbsp;common&amp;nbsp;method&amp;nbsp;of&amp;nbsp;arbitrating&amp;nbsp;this&amp;nbsp;situation&amp;nbsp;is&amp;nbsp;aging,&amp;nbsp;which&lt;br&gt;
gradually&amp;nbsp;increments&amp;nbsp;the&amp;nbsp;priority&amp;nbsp;of&amp;nbsp;waiting&amp;nbsp;processes&amp;nbsp;and&amp;nbsp;threads,&amp;nbsp;ensuring&lt;br&gt;
that&amp;nbsp;they&amp;nbsp;will&amp;nbsp;all&amp;nbsp;eventually&amp;nbsp;execute.&amp;nbsp;Most&amp;nbsp;Real-time&amp;nbsp;operating&amp;nbsp;systems&amp;nbsp;(RTOSs)&lt;br&gt;
have&amp;nbsp;pre-emptive&amp;nbsp;schedulers.&amp;nbsp;Also&amp;nbsp;turning&amp;nbsp;off&amp;nbsp;time&amp;nbsp;slicing&amp;nbsp;effectively&amp;nbsp;gives&amp;nbsp;you&lt;br&gt;
&amp;nbsp;the&amp;nbsp;non-pre-emptive&amp;nbsp;RTOS.&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:9" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Yielding,&amp;nbsp;describe.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>Whenever&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;sleeps,&amp;nbsp;waits,&amp;nbsp;or&amp;nbsp;blocks&amp;nbsp;on&amp;nbsp;I/O,&amp;nbsp;it&amp;nbsp;gives&amp;nbsp;up&amp;nbsp;its&lt;br&gt;
time&amp;nbsp;slot&amp;nbsp;and&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;scheduled.&amp;nbsp;As&amp;nbsp;long&amp;nbsp;as&amp;nbsp;you&amp;nbsp;don’t&amp;nbsp;write&lt;br&gt;
methods&amp;nbsp;that&amp;nbsp;use&amp;nbsp;hard&amp;nbsp;loops,&amp;nbsp;all&amp;nbsp;threads&amp;nbsp;should&amp;nbsp;get&amp;nbsp;their&amp;nbsp;due.&lt;br&gt;
However,&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;also&amp;nbsp;signal&amp;nbsp;that&amp;nbsp;it&amp;nbsp;is&amp;nbsp;willing&amp;nbsp;to&amp;nbsp;give&amp;nbsp;up&amp;nbsp;its&lt;br&gt;
time&amp;nbsp;voluntarily&amp;nbsp;at&amp;nbsp;any&amp;nbsp;point&amp;nbsp;with&amp;nbsp;the&amp;nbsp;yield()&amp;nbsp;call.&amp;nbsp;We&amp;nbsp;can&amp;nbsp;change&amp;nbsp;our&lt;br&gt;
previous&amp;nbsp;example&amp;nbsp;to&amp;nbsp;include&amp;nbsp;a&amp;nbsp;yield()&amp;nbsp;on&amp;nbsp;each&amp;nbsp;iteration:&lt;br&gt;
!!&amp;nbsp;Yield&amp;nbsp;-&amp;nbsp;(viddavaty&amp;nbsp;(ukr))&lt;br&gt;
&lt;br&gt;
DEF:&lt;br&gt;
The&amp;nbsp;java.lang.Thread.yield()&amp;nbsp;method&amp;nbsp;causes&amp;nbsp;the&amp;nbsp;currently&amp;nbsp;executing&amp;nbsp;thread&lt;br&gt;
object&amp;nbsp;to&amp;nbsp;temporarily&amp;nbsp;pause&amp;nbsp;and&amp;nbsp;allow&amp;nbsp;other&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;execute.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;yield;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;YieldExample&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;YieldExample(String&amp;nbsp;str)&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(this,&amp;nbsp;str);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;this&amp;nbsp;will&amp;nbsp;call&amp;nbsp;run()&amp;nbsp;function&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;5;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;yields&amp;nbsp;control&amp;nbsp;to&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;every&amp;nbsp;5&amp;nbsp;iterations&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;((i&amp;nbsp;%&amp;nbsp;5)&amp;nbsp;==&amp;nbsp;0)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"yielding&amp;nbsp;control...");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/*&amp;nbsp;causes&amp;nbsp;the&amp;nbsp;currently&amp;nbsp;executing&amp;nbsp;thread&amp;nbsp;object&amp;nbsp;to&amp;nbsp;temporarily&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pause&amp;nbsp;and&amp;nbsp;allow&amp;nbsp;other&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;execute&amp;nbsp;*/&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.yield();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"&amp;nbsp;has&amp;nbsp;finished&amp;nbsp;executing.");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;YieldExample("Thread&amp;nbsp;1");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;YieldExample("Thread&amp;nbsp;2");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;YieldExample("Thread&amp;nbsp;3");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&amp;nbsp;&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;(can&amp;nbsp;change&amp;nbsp;=)):&lt;br&gt;
Thread&amp;nbsp;1&amp;nbsp;is&amp;nbsp;yielding&amp;nbsp;control...&lt;br&gt;
Thread&amp;nbsp;2&amp;nbsp;is&amp;nbsp;yielding&amp;nbsp;control...&lt;br&gt;
Thread&amp;nbsp;3&amp;nbsp;is&amp;nbsp;yielding&amp;nbsp;control...&lt;br&gt;
Thread&amp;nbsp;1&amp;nbsp;has&amp;nbsp;finished&amp;nbsp;executing.&lt;br&gt;
Thread&amp;nbsp;2&amp;nbsp;has&amp;nbsp;finished&amp;nbsp;executing.&lt;br&gt;
Thread&amp;nbsp;3&amp;nbsp;has&amp;nbsp;finished&amp;nbsp;executing.</questionanswer>
  </question>
  <question id="1_0_0_3_0:10" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Thread&amp;nbsp;Groups,&amp;nbsp;describe.&lt;br&gt;
&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;the&amp;nbsp;result&amp;nbsp;of&amp;nbsp;code&amp;nbsp;:&lt;br&gt;
Thread&amp;nbsp;t&amp;nbsp;=&amp;nbsp;new&amp;nbsp;MyThread();&amp;nbsp;//&amp;nbsp;MyThread&amp;nbsp;extends&amp;nbsp;Thread&lt;br&gt;
System.out.println(t&amp;nbsp;instanseof&amp;nbsp;Runnable);&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
The&amp;nbsp;ThreadGroup&amp;nbsp;class&amp;nbsp;allows&amp;nbsp;us&amp;nbsp;to&amp;nbsp;deal&amp;nbsp;with&amp;nbsp;threads&amp;nbsp;wholesale:&amp;nbsp;we&amp;nbsp;can&amp;nbsp;use&lt;br&gt;
it&amp;nbsp;to&amp;nbsp;arrange&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;groups&amp;nbsp;and&amp;nbsp;deal&amp;nbsp;with&amp;nbsp;the&amp;nbsp;groups&amp;nbsp;as&amp;nbsp;a&amp;nbsp;whole.&amp;nbsp;A&lt;br&gt;
thread&amp;nbsp;group&amp;nbsp;can&amp;nbsp;contain&amp;nbsp;other&amp;nbsp;thread&amp;nbsp;groups&amp;nbsp;in&amp;nbsp;addition&amp;nbsp;to&amp;nbsp;individual&amp;nbsp;threads,&lt;br&gt;
so&amp;nbsp;our&amp;nbsp;arrangements&amp;nbsp;can&amp;nbsp;be&amp;nbsp;hierarchical.&lt;br&gt;
&lt;br&gt;
Thread&amp;nbsp;groups&amp;nbsp;are&amp;nbsp;particularly&amp;nbsp;useful&amp;nbsp;when&amp;nbsp;we&amp;nbsp;want&amp;nbsp;to&amp;nbsp;start&amp;nbsp;a&amp;nbsp;task&amp;nbsp;that&lt;br&gt;
might&amp;nbsp;create&amp;nbsp;__&amp;nbsp;many&amp;nbsp;threads&amp;nbsp;of&amp;nbsp;its&amp;nbsp;own&amp;nbsp;__.&amp;nbsp;By&amp;nbsp;assigning&amp;nbsp;the&amp;nbsp;task&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;group,&lt;br&gt;
we&amp;nbsp;can&amp;nbsp;later&amp;nbsp;identify&amp;nbsp;and&amp;nbsp;control&amp;nbsp;all&amp;nbsp;the&amp;nbsp;task’s&amp;nbsp;threads.&amp;nbsp;Thread&amp;nbsp;groups&amp;nbsp;are&lt;br&gt;
also&amp;nbsp;the&amp;nbsp;subject&amp;nbsp;of&amp;nbsp;restrictions&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;imposed&amp;nbsp;by&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;Security&amp;nbsp;Manager,&lt;br&gt;
so&amp;nbsp;we&amp;nbsp;can&amp;nbsp;restrict&amp;nbsp;a&amp;nbsp;thread’s&amp;nbsp;behavior&amp;nbsp;according&amp;nbsp;to&amp;nbsp;its&amp;nbsp;thread&amp;nbsp;group.&amp;nbsp;For&amp;nbsp;example,&lt;br&gt;
we&amp;nbsp;can&amp;nbsp;forbid&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;a&amp;nbsp;particular&amp;nbsp;group&amp;nbsp;from&amp;nbsp;interacting&amp;nbsp;with&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;other&lt;br&gt;
groups.&amp;nbsp;!!!&amp;nbsp;This&amp;nbsp;is&amp;nbsp;one&amp;nbsp;way&amp;nbsp;web&amp;nbsp;browsers&amp;nbsp;can&amp;nbsp;prevent&amp;nbsp;threads&amp;nbsp;started&amp;nbsp;by&lt;br&gt;
&amp;nbsp;!&amp;nbsp;Java&amp;nbsp;applets&amp;nbsp;from&amp;nbsp;stopping&amp;nbsp;important&amp;nbsp;system&amp;nbsp;threads.&amp;nbsp;When&amp;nbsp;we&amp;nbsp;create&amp;nbsp;a&amp;nbsp;thread,&lt;br&gt;
it&amp;nbsp;normally&amp;nbsp;becomes&amp;nbsp;part&amp;nbsp;of&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;to&amp;nbsp;which&amp;nbsp;the&amp;nbsp;currently&amp;nbsp;running&amp;nbsp;thread&lt;br&gt;
belongs.&amp;nbsp;To&amp;nbsp;create&amp;nbsp;a&amp;nbsp;new&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;of&amp;nbsp;our&amp;nbsp;own,&amp;nbsp;we&amp;nbsp;can&amp;nbsp;call&amp;nbsp;the&amp;nbsp;constructor:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;myTaskGroup&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ThreadGroup("My&amp;nbsp;Task&amp;nbsp;Group");&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;ThreadGroup&amp;nbsp;constructor&amp;nbsp;takes&amp;nbsp;a&amp;nbsp;name,&amp;nbsp;which&amp;nbsp;a&amp;nbsp;debugger&amp;nbsp;can&amp;nbsp;use&amp;nbsp;to&amp;nbsp;help&lt;br&gt;
you&amp;nbsp;identify&amp;nbsp;the&amp;nbsp;group.&amp;nbsp;Once&amp;nbsp;we&amp;nbsp;have&amp;nbsp;a&amp;nbsp;group,&amp;nbsp;we&amp;nbsp;can&amp;nbsp;put&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;the&amp;nbsp;group&amp;nbsp;by&lt;br&gt;
supplying&amp;nbsp;the&amp;nbsp;ThreadGroup&amp;nbsp;object&amp;nbsp;as&amp;nbsp;an&amp;nbsp;argument&amp;nbsp;to&amp;nbsp;the&amp;nbsp;Thread&amp;nbsp;constructor:&lt;br&gt;
&lt;br&gt;
Thread&amp;nbsp;myTask&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(&amp;nbsp;myTaskGroup,&amp;nbsp;taskPerformer&amp;nbsp;);&lt;br&gt;
&lt;br&gt;
Here,&amp;nbsp;myTaskGroup&amp;nbsp;is&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;group,&amp;nbsp;and&amp;nbsp;taskPerformer&amp;nbsp;is&amp;nbsp;the&amp;nbsp;target&lt;br&gt;
object&amp;nbsp;(the&amp;nbsp;Runnable&amp;nbsp;object&amp;nbsp;that&amp;nbsp;performs&amp;nbsp;the&amp;nbsp;task).&amp;nbsp;Any&amp;nbsp;additional&amp;nbsp;threads&amp;nbsp;that&lt;br&gt;
myTask&amp;nbsp;creates&amp;nbsp;also&amp;nbsp;belong&amp;nbsp;to&amp;nbsp;the&amp;nbsp;myTaskGroup&amp;nbsp;thread&amp;nbsp;group.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;ThreadGroup&amp;nbsp;class&amp;nbsp;exists&amp;nbsp;so&amp;nbsp;that&amp;nbsp;you&amp;nbsp;can&amp;nbsp;control&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;batches.&amp;nbsp;It&lt;br&gt;
has&amp;nbsp;methods&amp;nbsp;that&amp;nbsp;parallel&amp;nbsp;the&amp;nbsp;basic&amp;nbsp;Thread&amp;nbsp;control&amp;nbsp;methods—even&amp;nbsp;the&amp;nbsp;deprecated&lt;br&gt;
stop(),&amp;nbsp;suspend(),&amp;nbsp;and&amp;nbsp;resume().&amp;nbsp;These&amp;nbsp;methods&amp;nbsp;operate&amp;nbsp;on&amp;nbsp;all&amp;nbsp;the&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;a&lt;br&gt;
thread&amp;nbsp;group.&amp;nbsp;You&amp;nbsp;can&amp;nbsp;also&amp;nbsp;mark&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;as&amp;nbsp;a&amp;nbsp;“daemon”;&amp;nbsp;a&amp;nbsp;daemon&amp;nbsp;thread&lt;br&gt;
group&amp;nbsp;is&amp;nbsp;automatically&amp;nbsp;removed&amp;nbsp;when&amp;nbsp;all&amp;nbsp;of&amp;nbsp;its&amp;nbsp;children&amp;nbsp;are&amp;nbsp;gone.&amp;nbsp;If&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;group&lt;br&gt;
isn’t&amp;nbsp;a&amp;nbsp;daemon,&amp;nbsp;you&amp;nbsp;have&amp;nbsp;to&amp;nbsp;call&amp;nbsp;destroy()&amp;nbsp;in&amp;nbsp;order&amp;nbsp;to&amp;nbsp;remove&amp;nbsp;it&amp;nbsp;when&amp;nbsp;it&amp;nbsp;is&amp;nbsp;empty.&lt;br&gt;
&lt;br&gt;
We&amp;nbsp;can&amp;nbsp;set&amp;nbsp;the&amp;nbsp;maximum&amp;nbsp;priority&amp;nbsp;for&amp;nbsp;threads&amp;nbsp;created&amp;nbsp;in&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;by&lt;br&gt;
calling&amp;nbsp;setMaximumPriority().&amp;nbsp;Thereafter,&amp;nbsp;no&amp;nbsp;threads&amp;nbsp;can&amp;nbsp;be&amp;nbsp;created&amp;nbsp;in&amp;nbsp;the&amp;nbsp;thread&lt;br&gt;
group&amp;nbsp;with&amp;nbsp;a&amp;nbsp;priority&amp;nbsp;to&amp;nbsp;be&amp;nbsp;higher&amp;nbsp;than&amp;nbsp;the&amp;nbsp;maximum;&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;change&amp;nbsp;their&lt;br&gt;
priority&amp;nbsp;can’t&amp;nbsp;set&amp;nbsp;their&amp;nbsp;new&amp;nbsp;priority&amp;nbsp;to&amp;nbsp;be&amp;nbsp;higher&amp;nbsp;than&amp;nbsp;the&amp;nbsp;maximum.&lt;br&gt;
&lt;br&gt;
Finally,&amp;nbsp;you&amp;nbsp;can&amp;nbsp;get&amp;nbsp;a&amp;nbsp;list&amp;nbsp;of&amp;nbsp;all&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;a&amp;nbsp;group.&amp;nbsp;The&amp;nbsp;method&amp;nbsp;activeCount()&lt;br&gt;
tells&amp;nbsp;you&amp;nbsp;how&amp;nbsp;many&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;in&amp;nbsp;the&amp;nbsp;group;&amp;nbsp;the&amp;nbsp;method&amp;nbsp;enumerate()&amp;nbsp;gives&lt;br&gt;
you&amp;nbsp;a&amp;nbsp;list&amp;nbsp;of&amp;nbsp;them.&amp;nbsp;We&amp;nbsp;used&amp;nbsp;the&amp;nbsp;enumerate()&amp;nbsp;method&amp;nbsp;earlier&amp;nbsp;when&amp;nbsp;we&amp;nbsp;showed&amp;nbsp;the&lt;br&gt;
state&amp;nbsp;of&amp;nbsp;all&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;the&amp;nbsp;default&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;using&amp;nbsp;the&amp;nbsp;static&amp;nbsp;Thread.enumerate()&lt;br&gt;
method.&amp;nbsp;The&amp;nbsp;argument&amp;nbsp;to&amp;nbsp;enumerate()&amp;nbsp;is&amp;nbsp;an&amp;nbsp;array&amp;nbsp;of&amp;nbsp;Threads&amp;nbsp;that&amp;nbsp;enumerate()&lt;br&gt;
fills&amp;nbsp;in&amp;nbsp;with&amp;nbsp;the&amp;nbsp;group’s&amp;nbsp;threads.&amp;nbsp;Both&amp;nbsp;activeCount()&amp;nbsp;and&amp;nbsp;enumerate()&amp;nbsp;operate&lt;br&gt;
recursively&amp;nbsp;on&amp;nbsp;all&amp;nbsp;thread&amp;nbsp;groups&amp;nbsp;that&amp;nbsp;are&amp;nbsp;contained&amp;nbsp;in&amp;nbsp;the&amp;nbsp;group.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Interrupt&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;group&lt;br&gt;
&lt;br&gt;
ThreadGroup's&amp;nbsp;interrupt()&amp;nbsp;method&amp;nbsp;allows&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;interrupt&amp;nbsp;a&amp;nbsp;specific&amp;nbsp;thread&lt;br&gt;
group's&amp;nbsp;threads&amp;nbsp;and&amp;nbsp;subgroups.&amp;nbsp;This&amp;nbsp;technique&amp;nbsp;would&amp;nbsp;prove&amp;nbsp;appropriate&amp;nbsp;in&amp;nbsp;the&lt;br&gt;
following&amp;nbsp;scenario:&amp;nbsp;Your&amp;nbsp;application's&amp;nbsp;main&amp;nbsp;thread&amp;nbsp;creates&amp;nbsp;multiple&amp;nbsp;threads&amp;nbsp;that&lt;br&gt;
each&amp;nbsp;perform&amp;nbsp;a&amp;nbsp;unit&amp;nbsp;of&amp;nbsp;work.&amp;nbsp;Because&amp;nbsp;all&amp;nbsp;threads&amp;nbsp;must&amp;nbsp;complete&amp;nbsp;their&amp;nbsp;respective&lt;br&gt;
work&amp;nbsp;units&amp;nbsp;before&amp;nbsp;any&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;examine&amp;nbsp;the&amp;nbsp;results,&amp;nbsp;each&amp;nbsp;thread&amp;nbsp;waits&amp;nbsp;after&lt;br&gt;
completing&amp;nbsp;its&amp;nbsp;work&amp;nbsp;unit.&amp;nbsp;The&amp;nbsp;main&amp;nbsp;thread&amp;nbsp;monitors&amp;nbsp;the&amp;nbsp;work&amp;nbsp;state.&amp;nbsp;Once&amp;nbsp;all&lt;br&gt;
other&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;waiting,&amp;nbsp;the&amp;nbsp;main&amp;nbsp;thread&amp;nbsp;calls&amp;nbsp;interrupt()&amp;nbsp;to&amp;nbsp;interrupt&amp;nbsp;the&amp;nbsp;other&lt;br&gt;
threads'&amp;nbsp;waits.&amp;nbsp;Then&amp;nbsp;those&amp;nbsp;threads&amp;nbsp;can&amp;nbsp;examine&amp;nbsp;and&amp;nbsp;process&amp;nbsp;the&amp;nbsp;results.&lt;br&gt;
Listing&amp;nbsp;3&amp;nbsp;demonstrates&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;interruption:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;threadgroups;&lt;br&gt;
&lt;br&gt;
//InterruptThreadGroup.java&lt;br&gt;
class&amp;nbsp;InterruptThreadGroup&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadGroup&amp;nbsp;group&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ThreadGroup("A&amp;nbsp;group");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;mt&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(group,&amp;nbsp;new&amp;nbsp;MyThread());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mt.setName("A");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mt.start();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;mt2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(group,&amp;nbsp;new&amp;nbsp;MyThread());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mt2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;MyThread();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mt2.setName("B");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mt2.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(2000);&amp;nbsp;//&amp;nbsp;Wait&amp;nbsp;2&amp;nbsp;seconds&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;Thread&amp;nbsp;is&amp;nbsp;Runnable&amp;nbsp;=)&amp;nbsp;!!!!!!!!!&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;Interrupt&amp;nbsp;all&amp;nbsp;methods&amp;nbsp;in&amp;nbsp;the&amp;nbsp;same&amp;nbsp;thread&amp;nbsp;group&amp;nbsp;as&amp;nbsp;the&amp;nbsp;main&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;thread&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.currentThread().getThreadGroup().interrupt();&amp;nbsp;//&amp;nbsp;interrupt&amp;nbsp;all&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;group&amp;nbsp;after&amp;nbsp;2&amp;nbsp;second&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;MyThread&amp;nbsp;extends&amp;nbsp;Thread&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for(int&amp;nbsp;i=0;i&lt;10000000;i++){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(i%148&amp;nbsp;==&amp;nbsp;0)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"&amp;nbsp;,&amp;nbsp;i&amp;nbsp;=&amp;nbsp;"&amp;nbsp;+&amp;nbsp;i);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(Thread.interrupted()){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
========================================&lt;br&gt;
========================================&lt;br&gt;
&lt;br&gt;
Thread&amp;nbsp;t&amp;nbsp;=&amp;nbsp;new&amp;nbsp;MyThread();&amp;nbsp;//&amp;nbsp;MyThread&amp;nbsp;extends&amp;nbsp;Thread&lt;br&gt;
System.out.println(t&amp;nbsp;instanseof&amp;nbsp;Runnable);&amp;nbsp;&amp;nbsp;//&amp;nbsp;true&lt;br&gt;
&lt;br&gt;
because:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;class&amp;nbsp;Thread&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;extends&amp;nbsp;Object&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;implements&amp;nbsp;Runnable&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
and&amp;nbsp;Runnable.java&amp;nbsp;is&amp;nbsp;:&lt;br&gt;
&amp;nbsp;public&amp;nbsp;interface&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;abstract&amp;nbsp;void&amp;nbsp;run();&lt;br&gt;
}&lt;br&gt;
=============</questionanswer>
  </question>
  <question id="1_0_0_3_0:11" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Daemon&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;Java,&amp;nbsp;describe.&lt;br&gt;
Provide&amp;nbsp;example.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>DEF:&lt;br&gt;
Use&amp;nbsp;thread.setDaemon(true)&amp;nbsp;to&amp;nbsp;tell&amp;nbsp;the&amp;nbsp;JVM&amp;nbsp;to&amp;nbsp;make&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;a&amp;nbsp;daemon&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
According&amp;nbsp;to&amp;nbsp;Webster's,&amp;nbsp;a&amp;nbsp;daemon&amp;nbsp;(variant&amp;nbsp;of&amp;nbsp;demon)&amp;nbsp;is&amp;nbsp;an&amp;nbsp;attendant&amp;nbsp;power&amp;nbsp;or&lt;br&gt;
spirit.&amp;nbsp;Daemon&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;typically&amp;nbsp;used&amp;nbsp;to&amp;nbsp;perform&amp;nbsp;services&amp;nbsp;for&amp;nbsp;your&amp;nbsp;application/applet&lt;br&gt;
(such&amp;nbsp;as&amp;nbsp;loading&amp;nbsp;the&amp;nbsp;"fiddley&amp;nbsp;bits").&amp;nbsp;The&amp;nbsp;core&amp;nbsp;difference&amp;nbsp;between&amp;nbsp;user&amp;nbsp;threads&amp;nbsp;and&lt;br&gt;
daemon&amp;nbsp;threads&amp;nbsp;is&amp;nbsp;that&amp;nbsp;the&amp;nbsp;JVM&amp;nbsp;will&amp;nbsp;only&amp;nbsp;shut&amp;nbsp;down&amp;nbsp;a&amp;nbsp;program&amp;nbsp;when&amp;nbsp;all&amp;nbsp;user&amp;nbsp;threads&lt;br&gt;
have&amp;nbsp;terminated.&amp;nbsp;Daemon&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;terminated&amp;nbsp;by&amp;nbsp;the&amp;nbsp;JVM&amp;nbsp;when&amp;nbsp;there&amp;nbsp;are&amp;nbsp;no&lt;br&gt;
longer&amp;nbsp;any&amp;nbsp;user&amp;nbsp;threads&amp;nbsp;running,&amp;nbsp;including&amp;nbsp;the&amp;nbsp;main&amp;nbsp;thread&amp;nbsp;of&amp;nbsp;execution.&lt;br&gt;
Use&amp;nbsp;daemons&amp;nbsp;as&amp;nbsp;the&amp;nbsp;minions&amp;nbsp;they&amp;nbsp;are.&lt;br&gt;
&lt;br&gt;
[In&amp;nbsp;short:&amp;nbsp;daemon&amp;nbsp;threads&amp;nbsp;do&amp;nbsp;not&amp;nbsp;keep&amp;nbsp;the&amp;nbsp;program&amp;nbsp;from&amp;nbsp;quitting;&amp;nbsp;user&amp;nbsp;threads&lt;br&gt;
keep&amp;nbsp;the&amp;nbsp;program&amp;nbsp;from&amp;nbsp;quitting.&amp;nbsp;-Alex]&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&lt;br&gt;
package&amp;nbsp;daemonthreads;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;DaemonTest&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;WorkerThread().start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(7500);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Main&amp;nbsp;Thread&amp;nbsp;ending");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;WorkerThread&amp;nbsp;extends&amp;nbsp;Thread&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;WorkerThread()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;by&amp;nbsp;default&amp;nbsp;false&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;if&amp;nbsp;FALSE&amp;nbsp;Thread&amp;nbsp;will&amp;nbsp;live&amp;nbsp;even&amp;nbsp;after&amp;nbsp;main&amp;nbsp;thread&amp;nbsp;die&amp;nbsp;=)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;setDaemon(false);&amp;nbsp;//&amp;nbsp;When&amp;nbsp;false,&amp;nbsp;(i.e.&amp;nbsp;when&amp;nbsp;it's&amp;nbsp;a&amp;nbsp;user&amp;nbsp;thread),&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;the&amp;nbsp;Worker&amp;nbsp;thread&amp;nbsp;continues&amp;nbsp;to&amp;nbsp;run.&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;When&amp;nbsp;true,&amp;nbsp;(i.e.&amp;nbsp;when&amp;nbsp;it's&amp;nbsp;a&amp;nbsp;daemon&amp;nbsp;thread),&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;the&amp;nbsp;Worker&amp;nbsp;thread&amp;nbsp;terminates&amp;nbsp;when&amp;nbsp;the&amp;nbsp;main&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;thread&amp;nbsp;terminates.&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;count&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(true)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;"&amp;nbsp;+&amp;nbsp;count++);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep(5000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;0&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;1&lt;br&gt;
Main&amp;nbsp;Thread&amp;nbsp;ending&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;2&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;3&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;4&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;5&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;6&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;7&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;8&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;9&lt;br&gt;
Hello&amp;nbsp;from&amp;nbsp;Worker&amp;nbsp;10&lt;br&gt;
.....&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:12" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;how&amp;nbsp;to&amp;nbsp;implement&amp;nbsp;Lock&amp;nbsp;using&amp;nbsp;synchronized&amp;nbsp;blocks&amp;nbsp;?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;Counter{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;private&amp;nbsp;Lock&amp;nbsp;lock&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Lock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;private&amp;nbsp;int&amp;nbsp;count&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;public&amp;nbsp;int&amp;nbsp;inc(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.lock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;newCount&amp;nbsp;=&amp;nbsp;++count;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.unlock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;newCount;&lt;br&gt;
&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
==&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;Lock{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;private&amp;nbsp;boolean&amp;nbsp;isLocked&amp;nbsp;=&amp;nbsp;false;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;lock()&lt;br&gt;
&amp;nbsp;&amp;nbsp;throws&amp;nbsp;InterruptedException{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while(isLocked){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;isLocked&amp;nbsp;=&amp;nbsp;true;&lt;br&gt;
&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;unlock(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;isLocked&amp;nbsp;=&amp;nbsp;false;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notify();&lt;br&gt;
&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
========================================&lt;br&gt;
Lock&amp;nbsp;Reentrance&lt;br&gt;
Synchronized&amp;nbsp;blocks&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;are&amp;nbsp;reentrant.&amp;nbsp;This&amp;nbsp;means,&amp;nbsp;that&amp;nbsp;if&amp;nbsp;a&amp;nbsp;Java&amp;nbsp;thread&lt;br&gt;
enters&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;block&amp;nbsp;of&amp;nbsp;code,&amp;nbsp;and&amp;nbsp;thereby&amp;nbsp;take&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;the&lt;br&gt;
monitor&amp;nbsp;object&amp;nbsp;the&amp;nbsp;block&amp;nbsp;is&amp;nbsp;synchronized&amp;nbsp;on,&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;enter&amp;nbsp;other&lt;br&gt;
Java&amp;nbsp;code&amp;nbsp;blocks&amp;nbsp;synchronized&amp;nbsp;on&amp;nbsp;the&amp;nbsp;same&amp;nbsp;monitor&amp;nbsp;object.&amp;nbsp;Here&amp;nbsp;is&amp;nbsp;an&amp;nbsp;example:&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;Reentrant{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;outer(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inner();&lt;br&gt;
&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;inner(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//do&amp;nbsp;something&lt;br&gt;
&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:13" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Why&amp;nbsp;thread&amp;nbsp;communication&amp;nbsp;methods&amp;nbsp;wait(),&amp;nbsp;notify()&amp;nbsp;and&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;notifyAll()&amp;nbsp;are&amp;nbsp;in&amp;nbsp;Object&amp;nbsp;class?&lt;br&gt;
Why&amp;nbsp;wait(),&amp;nbsp;notify()&amp;nbsp;and&amp;nbsp;notifyAll()&amp;nbsp;methods&amp;nbsp;have&amp;nbsp;to&amp;nbsp;be&amp;nbsp;called&amp;nbsp;from&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;method&amp;nbsp;or&amp;nbsp;block?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>1&lt;br&gt;
In&amp;nbsp;Java&amp;nbsp;every&amp;nbsp;Object&amp;nbsp;has&amp;nbsp;a&amp;nbsp;monitor&amp;nbsp;and&amp;nbsp;wait,&amp;nbsp;notify&amp;nbsp;methods&amp;nbsp;are&lt;br&gt;
used&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;the&amp;nbsp;Object&amp;nbsp;monitor&amp;nbsp;or&amp;nbsp;to&amp;nbsp;notify&amp;nbsp;other&amp;nbsp;threads&amp;nbsp;that&lt;br&gt;
Object&amp;nbsp;monitor&amp;nbsp;is&amp;nbsp;free&amp;nbsp;now.&amp;nbsp;There&amp;nbsp;is&amp;nbsp;no&amp;nbsp;monitor&amp;nbsp;on&amp;nbsp;threads&amp;nbsp;in&amp;nbsp;java&lt;br&gt;
and&amp;nbsp;synchronization&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;with&amp;nbsp;any&amp;nbsp;Object,&amp;nbsp;that’s&amp;nbsp;why&amp;nbsp;it’s&lt;br&gt;
part&amp;nbsp;of&amp;nbsp;Object&amp;nbsp;class&amp;nbsp;so&amp;nbsp;that&amp;nbsp;every&amp;nbsp;class&amp;nbsp;in&amp;nbsp;java&amp;nbsp;has&amp;nbsp;these&amp;nbsp;essential&lt;br&gt;
methods&amp;nbsp;for&amp;nbsp;inter&amp;nbsp;thread&amp;nbsp;communication.&lt;br&gt;
&lt;br&gt;
=========================================&lt;br&gt;
2&lt;br&gt;
When&amp;nbsp;a&amp;nbsp;Thread&amp;nbsp;calls&amp;nbsp;wait()&amp;nbsp;on&amp;nbsp;any&amp;nbsp;Object,&amp;nbsp;it&amp;nbsp;must&amp;nbsp;have&amp;nbsp;the&amp;nbsp;monitor&amp;nbsp;on&lt;br&gt;
the&amp;nbsp;Object&amp;nbsp;that&amp;nbsp;it&amp;nbsp;will&amp;nbsp;leave&amp;nbsp;and&amp;nbsp;goes&amp;nbsp;in&amp;nbsp;wait&amp;nbsp;state&amp;nbsp;until&amp;nbsp;any&amp;nbsp;other&lt;br&gt;
thread&amp;nbsp;call&amp;nbsp;notify()&amp;nbsp;on&amp;nbsp;this&amp;nbsp;Object.&amp;nbsp;Similarly&amp;nbsp;when&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;calls&amp;nbsp;notify()&lt;br&gt;
on&amp;nbsp;any&amp;nbsp;Object,&amp;nbsp;it&amp;nbsp;leaves&amp;nbsp;the&amp;nbsp;monitor&amp;nbsp;on&amp;nbsp;the&amp;nbsp;Object&amp;nbsp;and&amp;nbsp;other&amp;nbsp;waiting&lt;br&gt;
threads&amp;nbsp;can&amp;nbsp;get&amp;nbsp;the&amp;nbsp;monitor&amp;nbsp;on&amp;nbsp;the&amp;nbsp;Object.&amp;nbsp;Since&amp;nbsp;all&amp;nbsp;these&amp;nbsp;methods&lt;br&gt;
require&amp;nbsp;Thread&amp;nbsp;to&amp;nbsp;have&amp;nbsp;the&amp;nbsp;Object&amp;nbsp;monitor,&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;achieved&amp;nbsp;only&lt;br&gt;
by&amp;nbsp;synchronization,&amp;nbsp;they&amp;nbsp;need&amp;nbsp;to&amp;nbsp;be&amp;nbsp;called&amp;nbsp;from&amp;nbsp;synchronized&amp;nbsp;method&amp;nbsp;or&amp;nbsp;block.</questionanswer>
  </question>
  <question id="1_0_0_3_0:14" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Green&amp;nbsp;Threads&amp;nbsp;vs&amp;nbsp;Non&amp;nbsp;Green&amp;nbsp;Threads.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>1&amp;nbsp;answer&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;Wikipedia&amp;nbsp;article&amp;nbsp;Green&amp;nbsp;Threads&amp;nbsp;explains&amp;nbsp;it&amp;nbsp;very&amp;nbsp;well.&lt;br&gt;
Green&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;"user-level&amp;nbsp;threads".&amp;nbsp;They&amp;nbsp;are&amp;nbsp;scheduled&amp;nbsp;by&amp;nbsp;an&lt;br&gt;
"ordinary"&amp;nbsp;user-level&amp;nbsp;process,&amp;nbsp;not&amp;nbsp;by&amp;nbsp;the&amp;nbsp;kernel.&amp;nbsp;So&amp;nbsp;they&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&lt;br&gt;
to&amp;nbsp;simulate&amp;nbsp;multi-threading&amp;nbsp;on&amp;nbsp;platforms&amp;nbsp;that&amp;nbsp;don't&amp;nbsp;provide&amp;nbsp;that&amp;nbsp;capability.&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;the&amp;nbsp;context&amp;nbsp;of&amp;nbsp;Java&amp;nbsp;specifically,&amp;nbsp;green&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;a&amp;nbsp;thing&amp;nbsp;of&amp;nbsp;the&lt;br&gt;
past.&amp;nbsp;See&amp;nbsp;the&amp;nbsp;Threading&amp;nbsp;article.&amp;nbsp;(It's&amp;nbsp;about&amp;nbsp;Solaris,&amp;nbsp;but&amp;nbsp;the&amp;nbsp;fact&amp;nbsp;that&lt;br&gt;
green&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;not&amp;nbsp;used&amp;nbsp;anymore&amp;nbsp;is&amp;nbsp;valid&amp;nbsp;for&amp;nbsp;the&amp;nbsp;usual&amp;nbsp;platforms).&lt;br&gt;
&lt;br&gt;
Green&amp;nbsp;threads&amp;nbsp;were&amp;nbsp;abandoned&amp;nbsp;in&amp;nbsp;the&amp;nbsp;Sun&amp;nbsp;JVM&amp;nbsp;for&amp;nbsp;Linux&amp;nbsp;as&amp;nbsp;of&amp;nbsp;the&amp;nbsp;release&lt;br&gt;
of&amp;nbsp;version&amp;nbsp;1.3&amp;nbsp;(see&amp;nbsp;Java[tm]&amp;nbsp;Technology&amp;nbsp;on&amp;nbsp;the&amp;nbsp;Linux&amp;nbsp;Platform).&amp;nbsp;That&amp;nbsp;dates&lt;br&gt;
back&amp;nbsp;to&amp;nbsp;2000.&amp;nbsp;For&amp;nbsp;Solaris,&amp;nbsp;native&amp;nbsp;threads&amp;nbsp;were&amp;nbsp;available&amp;nbsp;from&amp;nbsp;JDK&amp;nbsp;1.2.&lt;br&gt;
That&amp;nbsp;dates&amp;nbsp;back&amp;nbsp;to&amp;nbsp;1998.&amp;nbsp;I&amp;nbsp;don't&amp;nbsp;even&amp;nbsp;think&amp;nbsp;there&amp;nbsp;ever&amp;nbsp;was&amp;nbsp;a&amp;nbsp;green&amp;nbsp;thread&lt;br&gt;
implementation&amp;nbsp;for&amp;nbsp;Windows,&amp;nbsp;but&amp;nbsp;I&amp;nbsp;can't&amp;nbsp;find&amp;nbsp;a&amp;nbsp;reference&amp;nbsp;for&amp;nbsp;that.&lt;br&gt;
&lt;br&gt;
There&amp;nbsp;are&amp;nbsp;some&amp;nbsp;exceptions&amp;nbsp;as&amp;nbsp;noted&amp;nbsp;in&amp;nbsp;the&amp;nbsp;Wikipedia&amp;nbsp;article,&amp;nbsp;I&amp;nbsp;gather&lt;br&gt;
mostly&amp;nbsp;for&amp;nbsp;low-power&amp;nbsp;(embedded)&amp;nbsp;devices.&lt;br&gt;
================================================&lt;br&gt;
2&lt;br&gt;
Green&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;threads&amp;nbsp;implemented&amp;nbsp;at&amp;nbsp;the&amp;nbsp;application&amp;nbsp;level&amp;nbsp;rather&amp;nbsp;than&amp;nbsp;in&lt;br&gt;
the&amp;nbsp;OS.&amp;nbsp;This&amp;nbsp;is&amp;nbsp;usually&amp;nbsp;done&amp;nbsp;when&amp;nbsp;the&amp;nbsp;OS&amp;nbsp;does&amp;nbsp;not&amp;nbsp;provide&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;API,&amp;nbsp;or&amp;nbsp;it&lt;br&gt;
doesn't&amp;nbsp;work&amp;nbsp;the&amp;nbsp;way&amp;nbsp;you&amp;nbsp;need.&lt;br&gt;
&lt;br&gt;
Thus,&amp;nbsp;the&amp;nbsp;advantage&amp;nbsp;is&amp;nbsp;that&amp;nbsp;you&amp;nbsp;get&amp;nbsp;thread-like&amp;nbsp;functionality&amp;nbsp;at&amp;nbsp;all.&amp;nbsp;The&amp;nbsp;disadvantage&lt;br&gt;
is&amp;nbsp;that&amp;nbsp;green&amp;nbsp;threads&amp;nbsp;can't&amp;nbsp;actually&amp;nbsp;use&amp;nbsp;multiple&amp;nbsp;cores.&lt;br&gt;
&lt;br&gt;
There&amp;nbsp;were&amp;nbsp;a&amp;nbsp;few&amp;nbsp;early&amp;nbsp;JVMs&amp;nbsp;that&amp;nbsp;used&amp;nbsp;green&amp;nbsp;threads&amp;nbsp;(IIRC&amp;nbsp;the&amp;nbsp;Blackdown&amp;nbsp;JVM&amp;nbsp;port&lt;br&gt;
to&amp;nbsp;Linux&amp;nbsp;did),&amp;nbsp;but&amp;nbsp;nowadays&amp;nbsp;all&amp;nbsp;mainstream&amp;nbsp;JVMs&amp;nbsp;use&amp;nbsp;real&amp;nbsp;threads.&amp;nbsp;There&amp;nbsp;may&amp;nbsp;be&lt;br&gt;
some&amp;nbsp;embedded&amp;nbsp;JVMs&amp;nbsp;that&amp;nbsp;still&amp;nbsp;use&amp;nbsp;green&amp;nbsp;threads.&lt;br&gt;
===============================================&lt;br&gt;
3&amp;nbsp;habrahabr.ru&lt;br&gt;
&lt;br&gt;
Java,&amp;nbsp;&amp;nbsp;brought&amp;nbsp;with&amp;nbsp;it&amp;nbsp;a&amp;nbsp;different&amp;nbsp;type&amp;nbsp;of&amp;nbsp;multi-threading,&amp;nbsp;which&amp;nbsp;is&amp;nbsp;called&amp;nbsp;green&lt;br&gt;
threads.&amp;nbsp;Green&amp;nbsp;threads&amp;nbsp;-&amp;nbsp;is,&amp;nbsp;in&amp;nbsp;fact,&amp;nbsp;the&amp;nbsp;__&amp;nbsp;simulation&amp;nbsp;flows&amp;nbsp;__.&amp;nbsp;The&amp;nbsp;Java&amp;nbsp;Virtual&lt;br&gt;
Machine&amp;nbsp;takes&amp;nbsp;care&amp;nbsp;of&amp;nbsp;switching&amp;nbsp;between&amp;nbsp;different&amp;nbsp;green&amp;nbsp;threads,&amp;nbsp;and&amp;nbsp;the&lt;br&gt;
car&amp;nbsp;runs&amp;nbsp;as&amp;nbsp;a&amp;nbsp;single&amp;nbsp;thread&amp;nbsp;OS.&amp;nbsp;This&amp;nbsp;gives&amp;nbsp;several&amp;nbsp;advantages.&amp;nbsp;OS&amp;nbsp;flows&amp;nbsp;are&lt;br&gt;
relatively&amp;nbsp;expensive&amp;nbsp;in&amp;nbsp;most&amp;nbsp;POSIX-systems.&amp;nbsp;In&amp;nbsp;addition,&amp;nbsp;switching&amp;nbsp;between&amp;nbsp;native&lt;br&gt;
threads&amp;nbsp;is&amp;nbsp;much&amp;nbsp;slower&amp;nbsp;than&amp;nbsp;between&amp;nbsp;green&amp;nbsp;threads.&lt;br&gt;
&lt;br&gt;
However,&amp;nbsp;there&amp;nbsp;are&amp;nbsp;drawbacks.&amp;nbsp;The&amp;nbsp;biggest&amp;nbsp;is&amp;nbsp;that&amp;nbsp;you&amp;nbsp;can&amp;nbsp;not&amp;nbsp;execute&amp;nbsp;two&lt;br&gt;
threads&amp;nbsp;simultaneously.&amp;nbsp;Since&amp;nbsp;there&amp;nbsp;is&amp;nbsp;only&amp;nbsp;one&amp;nbsp;native&amp;nbsp;thread,&amp;nbsp;only&amp;nbsp;he&amp;nbsp;called&lt;br&gt;
OS&amp;nbsp;scheduler.&amp;nbsp;Even&amp;nbsp;if&amp;nbsp;you&amp;nbsp;have&amp;nbsp;multiple&amp;nbsp;processors&amp;nbsp;and&amp;nbsp;multiple&amp;nbsp;green&amp;nbsp;threads,&lt;br&gt;
only&amp;nbsp;one&amp;nbsp;processor&amp;nbsp;can&amp;nbsp;cause&amp;nbsp;green&amp;nbsp;thread.&amp;nbsp;And&amp;nbsp;all&amp;nbsp;because&amp;nbsp;the&amp;nbsp;terms&amp;nbsp;of&amp;nbsp;the&lt;br&gt;
Task&amp;nbsp;Scheduler&amp;nbsp;OS,&amp;nbsp;it&amp;nbsp;looks&amp;nbsp;a&amp;nbsp;single&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
!!&amp;nbsp;Starting&amp;nbsp;with&amp;nbsp;version&amp;nbsp;1.2&amp;nbsp;Java&amp;nbsp;support&amp;nbsp;native&amp;nbsp;threads,&amp;nbsp;and&amp;nbsp;since&amp;nbsp;they&amp;nbsp;are&amp;nbsp;used&amp;nbsp;by&amp;nbsp;default&lt;br&gt;
&lt;br&gt;
Note&amp;nbsp;:&amp;nbsp;C#&amp;nbsp;uses&amp;nbsp;native&amp;nbsp;threads&amp;nbsp;.</questionanswer>
  </question>
  <question id="1_0_0_3_0:15" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;What&amp;nbsp;is&amp;nbsp;Java&amp;nbsp;Timer&amp;nbsp;Class?&amp;nbsp;How&amp;nbsp;to&amp;nbsp;schedule&amp;nbsp;a&amp;nbsp;task&amp;nbsp;to&amp;nbsp;run&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;after&amp;nbsp;specific&amp;nbsp;interval&amp;nbsp;?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
java.util.Timer&amp;nbsp;is&amp;nbsp;a&amp;nbsp;utility&amp;nbsp;class&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;schedule&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;be&lt;br&gt;
executed&amp;nbsp;at&amp;nbsp;certain&amp;nbsp;time&amp;nbsp;in&amp;nbsp;future.&amp;nbsp;Java&amp;nbsp;Timer&amp;nbsp;class&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;schedule&lt;br&gt;
a&amp;nbsp;task&amp;nbsp;to&amp;nbsp;be&amp;nbsp;run&amp;nbsp;one-time&amp;nbsp;or&amp;nbsp;to&amp;nbsp;be&amp;nbsp;run&amp;nbsp;at&amp;nbsp;regular&amp;nbsp;intervals.&lt;br&gt;
&lt;br&gt;
java.util.TimerTask&amp;nbsp;is&amp;nbsp;an&amp;nbsp;abstract&amp;nbsp;class&amp;nbsp;that&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;interface&lt;br&gt;
and&amp;nbsp;we&amp;nbsp;need&amp;nbsp;to&amp;nbsp;extend&amp;nbsp;this&amp;nbsp;class&amp;nbsp;to&amp;nbsp;create&amp;nbsp;our&amp;nbsp;own&amp;nbsp;TimerTask&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&lt;br&gt;
scheduled&amp;nbsp;using&amp;nbsp;java&amp;nbsp;Timer&amp;nbsp;class.&lt;br&gt;
&lt;br&gt;
Timer&amp;nbsp;class&amp;nbsp;is&amp;nbsp;thread&amp;nbsp;safe&amp;nbsp;and&amp;nbsp;multiple&amp;nbsp;threads&amp;nbsp;can&amp;nbsp;share&amp;nbsp;a&amp;nbsp;single&amp;nbsp;Timer&amp;nbsp;object&lt;br&gt;
without&amp;nbsp;need&amp;nbsp;for&amp;nbsp;external&amp;nbsp;synchronization.&amp;nbsp;Timer&amp;nbsp;class&amp;nbsp;uses&amp;nbsp;java.util.TaskQueue&lt;br&gt;
to&amp;nbsp;add&amp;nbsp;tasks&amp;nbsp;at&amp;nbsp;given&amp;nbsp;regular&amp;nbsp;interval&amp;nbsp;and&amp;nbsp;at&amp;nbsp;any&amp;nbsp;time&amp;nbsp;there&amp;nbsp;can&amp;nbsp;be&amp;nbsp;only&amp;nbsp;one&lt;br&gt;
thread&amp;nbsp;running&amp;nbsp;the&amp;nbsp;TimerTask,&amp;nbsp;for&amp;nbsp;example&amp;nbsp;if&amp;nbsp;you&amp;nbsp;are&amp;nbsp;creating&amp;nbsp;a&amp;nbsp;Timer&amp;nbsp;to&amp;nbsp;run&amp;nbsp;every&lt;br&gt;
10&amp;nbsp;seconds&amp;nbsp;but&amp;nbsp;single&amp;nbsp;thread&amp;nbsp;execution&amp;nbsp;takes&amp;nbsp;20&amp;nbsp;seconds,&amp;nbsp;then&amp;nbsp;Timer&amp;nbsp;object&amp;nbsp;will&lt;br&gt;
keep&amp;nbsp;adding&amp;nbsp;tasks&amp;nbsp;to&amp;nbsp;the&amp;nbsp;queue&amp;nbsp;and&amp;nbsp;as&amp;nbsp;soon&amp;nbsp;as&amp;nbsp;one&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;finished,&amp;nbsp;it&amp;nbsp;will&lt;br&gt;
notify&amp;nbsp;the&amp;nbsp;queue&amp;nbsp;and&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;will&amp;nbsp;start&amp;nbsp;executing.&lt;br&gt;
&lt;br&gt;
Timer&amp;nbsp;class&amp;nbsp;uses&amp;nbsp;Object&amp;nbsp;wait&amp;nbsp;and&amp;nbsp;notify&amp;nbsp;methods&amp;nbsp;to&amp;nbsp;schedule&amp;nbsp;the&amp;nbsp;tasks.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&lt;br&gt;
package&amp;nbsp;timerexample;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.Date;&lt;br&gt;
import&amp;nbsp;java.util.Timer;&lt;br&gt;
import&amp;nbsp;java.util.TimerTask;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;MyTimerTask&amp;nbsp;extends&amp;nbsp;TimerTask&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Timer&amp;nbsp;task&amp;nbsp;started&amp;nbsp;at:"&amp;nbsp;+&amp;nbsp;new&amp;nbsp;Date());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;completeTask();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Timer&amp;nbsp;task&amp;nbsp;finished&amp;nbsp;at:"&amp;nbsp;+&amp;nbsp;new&amp;nbsp;Date());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;void&amp;nbsp;completeTask()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;assuming&amp;nbsp;it&amp;nbsp;takes&amp;nbsp;2&amp;nbsp;secs&amp;nbsp;to&amp;nbsp;complete&amp;nbsp;the&amp;nbsp;task&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(2000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String&amp;nbsp;args[])&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TimerTask&amp;nbsp;timerTask&amp;nbsp;=&amp;nbsp;new&amp;nbsp;MyTimerTask();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;running&amp;nbsp;timer&amp;nbsp;task&amp;nbsp;as&amp;nbsp;daemon&amp;nbsp;thread&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Timer&amp;nbsp;timer&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Timer(true);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;timer.scheduleAtFixedRate(timerTask,&amp;nbsp;0,&amp;nbsp;10&amp;nbsp;*&amp;nbsp;1000);&amp;nbsp;//&amp;nbsp;execute&amp;nbsp;timer&amp;nbsp;task&amp;nbsp;every&amp;nbsp;10&amp;nbsp;seconds&amp;nbsp;(as&amp;nbsp;javascript&amp;nbsp;setInterval)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//timer.schedule(timerTask,&amp;nbsp;2000);&amp;nbsp;&amp;nbsp;//&amp;nbsp;execute&amp;nbsp;once&amp;nbsp;,&amp;nbsp;with&amp;nbsp;delay&amp;nbsp;2000&amp;nbsp;seconds&amp;nbsp;(&amp;nbsp;as&amp;nbsp;javascript&amp;nbsp;setTimeout)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("TimerTask&amp;nbsp;started");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;cancel&amp;nbsp;after&amp;nbsp;sometime&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(12000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;timer.cancel();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("TimerTask&amp;nbsp;cancelled");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
TimerTask&amp;nbsp;started&lt;br&gt;
Timer&amp;nbsp;task&amp;nbsp;started&amp;nbsp;at:Mon&amp;nbsp;Mar&amp;nbsp;24&amp;nbsp;22:04:03&amp;nbsp;EET&amp;nbsp;2014&lt;br&gt;
Timer&amp;nbsp;task&amp;nbsp;finished&amp;nbsp;at:Mon&amp;nbsp;Mar&amp;nbsp;24&amp;nbsp;22:04:05&amp;nbsp;EET&amp;nbsp;2014&lt;br&gt;
Timer&amp;nbsp;task&amp;nbsp;started&amp;nbsp;at:Mon&amp;nbsp;Mar&amp;nbsp;24&amp;nbsp;22:04:13&amp;nbsp;EET&amp;nbsp;2014&lt;br&gt;
Timer&amp;nbsp;task&amp;nbsp;finished&amp;nbsp;at:Mon&amp;nbsp;Mar&amp;nbsp;24&amp;nbsp;22:04:15&amp;nbsp;EET&amp;nbsp;2014&lt;br&gt;
TimerTask&amp;nbsp;cancelled</questionanswer>
  </question>
  <question id="1_0_0_3_0:16" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;What&amp;nbsp;is&amp;nbsp;Deadlock?&amp;nbsp;How&amp;nbsp;to&amp;nbsp;analyze&amp;nbsp;and&amp;nbsp;avoid&amp;nbsp;deadlock&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;situation?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>Deadlock&amp;nbsp;describes&amp;nbsp;a&amp;nbsp;situation&amp;nbsp;where&amp;nbsp;two&amp;nbsp;or&amp;nbsp;more&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;blocked&lt;br&gt;
forever,&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;each&amp;nbsp;other.&lt;br&gt;
!!!&amp;nbsp;Deadlock&amp;nbsp;occurs&amp;nbsp;when&amp;nbsp;multiple&amp;nbsp;threads&amp;nbsp;need&amp;nbsp;the&amp;nbsp;same&amp;nbsp;locks&amp;nbsp;but&amp;nbsp;obtain&amp;nbsp;them&lt;br&gt;
in&amp;nbsp;different&amp;nbsp;order.&lt;br&gt;
&lt;br&gt;
Simple&amp;nbsp;Example&amp;nbsp;(funny)&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;deadlocks;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;DeadLockExampleFriends&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;Friend&amp;nbsp;ivan&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Friend("Ivan");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;Friend&amp;nbsp;petro&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Friend("Petro");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ivan.bow(petro);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;petro.bow(ivan);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Friend&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;final&amp;nbsp;String&amp;nbsp;name;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Friend(String&amp;nbsp;name)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.name&amp;nbsp;=&amp;nbsp;name;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;String&amp;nbsp;getName(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;this.name;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;bow(Friend&amp;nbsp;bower){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.format("%s:&amp;nbsp;%s&amp;nbsp;has&amp;nbsp;bowed&amp;nbsp;to&amp;nbsp;me!\n",this.name,bower.getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bower.bowBack(this);&amp;nbsp;&amp;nbsp;//&amp;nbsp;this&amp;nbsp;line&amp;nbsp;causes&amp;nbsp;DeadLock&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;bowBack(Friend&amp;nbsp;bower){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.format("%s:&amp;nbsp;%s&amp;nbsp;has&amp;nbsp;bowed&amp;nbsp;back&amp;nbsp;to&amp;nbsp;me!\n",this.name,bower.getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Ivan:&amp;nbsp;Petro&amp;nbsp;has&amp;nbsp;bowed&amp;nbsp;to&amp;nbsp;me!&lt;br&gt;
Petro:&amp;nbsp;Ivan&amp;nbsp;has&amp;nbsp;bowed&amp;nbsp;to&amp;nbsp;me!&lt;br&gt;
===========================================&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Deadlock&amp;nbsp;Example&amp;nbsp;:&amp;nbsp;bank&amp;nbsp;account&amp;nbsp;:&amp;nbsp;&lt;br&gt;
class&amp;nbsp;Account&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double&amp;nbsp;balance;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;id;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Account(int&amp;nbsp;id,&amp;nbsp;double&amp;nbsp;balance){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.balance&amp;nbsp;=&amp;nbsp;balance;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.id&amp;nbsp;=&amp;nbsp;id;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void&amp;nbsp;withdraw(double&amp;nbsp;amount){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;balance&amp;nbsp;-=&amp;nbsp;amount;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void&amp;nbsp;deposit(double&amp;nbsp;amount){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;balance&amp;nbsp;+=&amp;nbsp;amount;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
class&amp;nbsp;Main{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String&amp;nbsp;[]&amp;nbsp;args){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;Account&amp;nbsp;a&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Account(1,1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;Account&amp;nbsp;b&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Account(2,300);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;a&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transfer(a,b,200);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;b&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transfer(b,a,300);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;transfer(Account&amp;nbsp;from,&amp;nbsp;Account&amp;nbsp;to,&amp;nbsp;double&amp;nbsp;amount){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized(from){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized(to){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;from.withdraw(amount);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;to.deposit(amount);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;addition&amp;nbsp;to&amp;nbsp;the&amp;nbsp;solution&amp;nbsp;of&amp;nbsp;lock&amp;nbsp;ordered&amp;nbsp;you&amp;nbsp;can&amp;nbsp;also&amp;nbsp;avoids&amp;nbsp;deadlock&lt;br&gt;
by&amp;nbsp;synchronizing&amp;nbsp;on&amp;nbsp;a&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;lock&amp;nbsp;object&amp;nbsp;before&amp;nbsp;performing&lt;br&gt;
any&amp;nbsp;account&amp;nbsp;transfers.&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Account{&lt;br&gt;
&amp;nbsp;double&amp;nbsp;balance;&lt;br&gt;
&amp;nbsp;int&amp;nbsp;id;&lt;br&gt;
&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;Object&amp;nbsp;lock&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Object();&lt;br&gt;
&amp;nbsp;&amp;nbsp;....&lt;br&gt;
&lt;br&gt;
&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;transfer(Account&amp;nbsp;from,&amp;nbsp;Account&amp;nbsp;to,&amp;nbsp;double&amp;nbsp;amount){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized(lock)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;from.withdraw(amount);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;to.deposit(amount);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
This&amp;nbsp;solution&amp;nbsp;have&amp;nbsp;the&amp;nbsp;problem&amp;nbsp;that&amp;nbsp;a&amp;nbsp;private&amp;nbsp;static&amp;nbsp;lock&amp;nbsp;restricts&amp;nbsp;the&lt;br&gt;
system&amp;nbsp;to&amp;nbsp;performing&amp;nbsp;transfers&amp;nbsp;"sequentially".&lt;br&gt;
&lt;br&gt;
==========================================&lt;br&gt;
Another&amp;nbsp;DeadLock&amp;nbsp;Example&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;deadlocks;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ThreadDeadlock&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object&amp;nbsp;obj1&amp;nbsp;=&amp;nbsp;"OBJECT&amp;nbsp;1";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object&amp;nbsp;obj2&amp;nbsp;=&amp;nbsp;"OBJECT&amp;nbsp;2";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object&amp;nbsp;obj3&amp;nbsp;=&amp;nbsp;"OBJECT&amp;nbsp;3";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;SyncThread(obj1,&amp;nbsp;obj2),&amp;nbsp;"t1");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;SyncThread(obj2,&amp;nbsp;obj3),&amp;nbsp;"t2");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t3&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;SyncThread(obj3,&amp;nbsp;obj1),&amp;nbsp;"t3");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(500);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(500);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t3.start();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;SyncThread&amp;nbsp;implements&amp;nbsp;Runnable{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;Object&amp;nbsp;obj1;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;Object&amp;nbsp;obj2;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;SyncThread(Object&amp;nbsp;obj1,&amp;nbsp;Object&amp;nbsp;obj2)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.obj1&amp;nbsp;=&amp;nbsp;obj1;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.obj2&amp;nbsp;=&amp;nbsp;obj2;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String&amp;nbsp;name&amp;nbsp;=&amp;nbsp;Thread.currentThread().getName();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;"&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;"+obj1);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;(obj1)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;"&amp;nbsp;acquired&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;"&amp;nbsp;+&amp;nbsp;obj1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;work();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;"&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;"&amp;nbsp;+&amp;nbsp;obj2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;(obj2)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;"&amp;nbsp;acquired&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;"&amp;nbsp;+&amp;nbsp;obj2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;work();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;"&amp;nbsp;released&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;"+obj2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;"&amp;nbsp;released&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;"+obj1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;"&amp;nbsp;finished&amp;nbsp;execution.");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;void&amp;nbsp;work(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(3000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
t1&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;1&lt;br&gt;
t1&amp;nbsp;acquired&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;1&lt;br&gt;
t2&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;2&lt;br&gt;
t2&amp;nbsp;acquired&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;2&lt;br&gt;
t3&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;3&lt;br&gt;
t3&amp;nbsp;acquired&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;3&lt;br&gt;
t1&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;2&lt;br&gt;
t2&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;3&lt;br&gt;
t3&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;OBJECT&amp;nbsp;1&lt;br&gt;
&lt;br&gt;
(ANALYZE&amp;nbsp;THIS&amp;nbsp;EXAMPLE&amp;nbsp;in&amp;nbsp;JVM&amp;nbsp;section&amp;nbsp;using&amp;nbsp;VisualVM&amp;nbsp;!!!!!!)&lt;br&gt;
&lt;br&gt;
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&lt;br&gt;
Avoid&amp;nbsp;deadlock&lt;br&gt;
-&amp;nbsp;&amp;nbsp;Avoid&amp;nbsp;Nested&amp;nbsp;Locks:&amp;nbsp;This&amp;nbsp;is&amp;nbsp;the&amp;nbsp;most&amp;nbsp;common&amp;nbsp;reason&amp;nbsp;for&amp;nbsp;deadlocks,&lt;br&gt;
avoid&amp;nbsp;locking&amp;nbsp;another&amp;nbsp;resource&amp;nbsp;if&amp;nbsp;you&amp;nbsp;already&amp;nbsp;hold&amp;nbsp;one.&amp;nbsp;It’s&amp;nbsp;almost&amp;nbsp;impossible&lt;br&gt;
to&amp;nbsp;get&amp;nbsp;deadlock&amp;nbsp;situation&amp;nbsp;if&amp;nbsp;you&amp;nbsp;are&amp;nbsp;working&amp;nbsp;with&amp;nbsp;only&amp;nbsp;one&amp;nbsp;object&amp;nbsp;lock.&amp;nbsp;For&lt;br&gt;
example,&amp;nbsp;here&amp;nbsp;is&amp;nbsp;the&amp;nbsp;another&amp;nbsp;implementation&amp;nbsp;of&amp;nbsp;run()&amp;nbsp;method&amp;nbsp;without&amp;nbsp;nested&lt;br&gt;
lock&amp;nbsp;and&amp;nbsp;program&amp;nbsp;runs&amp;nbsp;successfully&amp;nbsp;without&amp;nbsp;deadlock&amp;nbsp;situation.&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String&amp;nbsp;name&amp;nbsp;=&amp;nbsp;Thread.currentThread().getName();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;'&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;'&amp;nbsp;+&amp;nbsp;obj1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;(obj1)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;'&amp;nbsp;acquired&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;'&amp;nbsp;+&amp;nbsp;obj1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;work();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;'&amp;nbsp;released&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;'&amp;nbsp;+&amp;nbsp;obj1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;'&amp;nbsp;acquiring&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;'&amp;nbsp;+&amp;nbsp;obj2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;(obj2)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;'&amp;nbsp;acquired&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;'&amp;nbsp;+&amp;nbsp;obj2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;work();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;'&amp;nbsp;released&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;'&amp;nbsp;+&amp;nbsp;obj2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(name&amp;nbsp;+&amp;nbsp;'&amp;nbsp;finished&amp;nbsp;execution.');&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Lock&amp;nbsp;Only&amp;nbsp;What&amp;nbsp;is&amp;nbsp;Required:&amp;nbsp;You&amp;nbsp;should&amp;nbsp;acquire&amp;nbsp;lock&amp;nbsp;only&amp;nbsp;on&amp;nbsp;the&amp;nbsp;resources&lt;br&gt;
you&amp;nbsp;have&amp;nbsp;to&amp;nbsp;work&amp;nbsp;on,&amp;nbsp;for&amp;nbsp;example&amp;nbsp;in&amp;nbsp;above&amp;nbsp;program&amp;nbsp;I&amp;nbsp;am&amp;nbsp;locking&amp;nbsp;the&amp;nbsp;complete&lt;br&gt;
Object&amp;nbsp;resource&amp;nbsp;but&amp;nbsp;if&amp;nbsp;we&amp;nbsp;are&amp;nbsp;only&amp;nbsp;interested&amp;nbsp;in&amp;nbsp;one&amp;nbsp;of&amp;nbsp;it’s&amp;nbsp;fields,&amp;nbsp;then&amp;nbsp;we&lt;br&gt;
should&amp;nbsp;lock&amp;nbsp;only&amp;nbsp;that&amp;nbsp;specific&amp;nbsp;field&amp;nbsp;not&amp;nbsp;complete&amp;nbsp;object.&lt;br&gt;
-&amp;nbsp;Avoid&amp;nbsp;waiting&amp;nbsp;indefinitely:&amp;nbsp;You&amp;nbsp;can&amp;nbsp;get&amp;nbsp;deadlock&amp;nbsp;if&amp;nbsp;two&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;waiting&amp;nbsp;for&lt;br&gt;
each&amp;nbsp;other&amp;nbsp;to&amp;nbsp;finish&amp;nbsp;indefinitely&amp;nbsp;using&amp;nbsp;thread&amp;nbsp;join.&amp;nbsp;If&amp;nbsp;your&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;for&lt;br&gt;
another&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;finish,&amp;nbsp;it’s&amp;nbsp;always&amp;nbsp;best&amp;nbsp;to&amp;nbsp;use&amp;nbsp;join&amp;nbsp;with&amp;nbsp;maximum&amp;nbsp;time&amp;nbsp;you&amp;nbsp;want&lt;br&gt;
to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;finish.&lt;br&gt;
=======</questionanswer>
  </question>
  <question id="1_0_0_3_0:17" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;concurency&amp;nbsp;:&amp;nbsp;what&amp;nbsp;is&amp;nbsp;java.util.concurrent&amp;nbsp;package&amp;nbsp;,&amp;nbsp;describe&amp;nbsp;features.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>We’ve&amp;nbsp;demonstrated&amp;nbsp;how&amp;nbsp;to&amp;nbsp;create&amp;nbsp;and&amp;nbsp;synchronize&amp;nbsp;threads&amp;nbsp;at&amp;nbsp;a&lt;br&gt;
low&amp;nbsp;level,&amp;nbsp;using&amp;nbsp;Java&amp;nbsp;language&amp;nbsp;primitives.&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;java.util.concurrent&amp;nbsp;package&amp;nbsp;and&lt;br&gt;
subpackages&amp;nbsp;introduced&amp;nbsp;with&amp;nbsp;Java&amp;nbsp;5.0&amp;nbsp;build&amp;nbsp;on&amp;nbsp;this&amp;nbsp;functionality,&lt;br&gt;
adding&amp;nbsp;important&amp;nbsp;threading&amp;nbsp;utilities&amp;nbsp;and&amp;nbsp;codifying&amp;nbsp;some&amp;nbsp;common&lt;br&gt;
design&amp;nbsp;patterns&amp;nbsp;by&amp;nbsp;supplying&amp;nbsp;standard&amp;nbsp;implementations.&amp;nbsp;Roughly&lt;br&gt;
in&amp;nbsp;order&amp;nbsp;of&amp;nbsp;generality,&amp;nbsp;these&amp;nbsp;areas&amp;nbsp;include&amp;nbsp;:&amp;nbsp;&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Thread-aware&amp;nbsp;Collections&amp;nbsp;implementations&lt;br&gt;
The&amp;nbsp;java.util.concurrent&amp;nbsp;package&amp;nbsp;augments&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;Collections&amp;nbsp;API&lt;br&gt;
with&amp;nbsp;several&amp;nbsp;implementations&amp;nbsp;for&amp;nbsp;specific&amp;nbsp;threading&amp;nbsp;models.&amp;nbsp;These&amp;nbsp;include&lt;br&gt;
timed&amp;nbsp;wait&amp;nbsp;and&amp;nbsp;blocking&amp;nbsp;implementations&amp;nbsp;of&amp;nbsp;the&amp;nbsp;Queue&amp;nbsp;interface,&amp;nbsp;as&amp;nbsp;well&amp;nbsp;as&lt;br&gt;
nonblocking,&amp;nbsp;concurrent-access&amp;nbsp;optimized&amp;nbsp;implementations&amp;nbsp;of&amp;nbsp;the&amp;nbsp;Queue&amp;nbsp;and&amp;nbsp;Map&lt;br&gt;
interfaces.&amp;nbsp;The&amp;nbsp;package&amp;nbsp;also&amp;nbsp;adds&amp;nbsp;“copy&amp;nbsp;on&amp;nbsp;write”&amp;nbsp;List&amp;nbsp;and&amp;nbsp;Set&amp;nbsp;implementations&lt;br&gt;
for&amp;nbsp;extremely&amp;nbsp;efficient&amp;nbsp;“almost&amp;nbsp;always&amp;nbsp;read”&amp;nbsp;cases.&amp;nbsp;These&amp;nbsp;may&amp;nbsp;sound&amp;nbsp;complex,&amp;nbsp;but&lt;br&gt;
actually&amp;nbsp;cover&amp;nbsp;some&amp;nbsp;fairly&amp;nbsp;simple&amp;nbsp;cases&amp;nbsp;very&amp;nbsp;well.&lt;br&gt;
(BlockingQueue,&amp;nbsp;ConcurrentMap,&amp;nbsp;ConcurrentHashMap,&amp;nbsp;)&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Executors&lt;br&gt;
Executors&amp;nbsp;run&amp;nbsp;tasks,&amp;nbsp;including&amp;nbsp;Runnables,&amp;nbsp;and&amp;nbsp;abstract&amp;nbsp;the&amp;nbsp;concept&amp;nbsp;of&amp;nbsp;thread&lt;br&gt;
creation&amp;nbsp;and&amp;nbsp;pooling&amp;nbsp;from&amp;nbsp;the&amp;nbsp;user.&amp;nbsp;Executors&amp;nbsp;are&amp;nbsp;intended&amp;nbsp;to&amp;nbsp;be&amp;nbsp;a&amp;nbsp;high-level&lt;br&gt;
replacement&amp;nbsp;for&amp;nbsp;the&amp;nbsp;idiom&amp;nbsp;of&amp;nbsp;creating&amp;nbsp;new&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;service&amp;nbsp;a&amp;nbsp;series&amp;nbsp;of&amp;nbsp;jobs.&lt;br&gt;
Along&amp;nbsp;with&amp;nbsp;Executors,&amp;nbsp;the&amp;nbsp;Callable&amp;nbsp;and&amp;nbsp;Future&amp;nbsp;interfaces&amp;nbsp;are&amp;nbsp;introduced,&amp;nbsp;which&lt;br&gt;
expand&amp;nbsp;upon&amp;nbsp;Runnable&amp;nbsp;to&amp;nbsp;allow&amp;nbsp;management,&amp;nbsp;value&amp;nbsp;return,&amp;nbsp;and&amp;nbsp;exception&lt;br&gt;
handling.&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Low-level&amp;nbsp;synchronization&amp;nbsp;constructs&lt;br&gt;
The&amp;nbsp;java.util.concurrent.locks&amp;nbsp;package&amp;nbsp;holds&amp;nbsp;a&amp;nbsp;set&amp;nbsp;of&amp;nbsp;classes,&amp;nbsp;including&lt;br&gt;
__&amp;nbsp;Lock&amp;nbsp;__&amp;nbsp;and&amp;nbsp;_&amp;nbsp;Condition&amp;nbsp;_,&amp;nbsp;that&amp;nbsp;parallels&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;language-level&amp;nbsp;synchronization&lt;br&gt;
primitives&amp;nbsp;and&amp;nbsp;promotes&amp;nbsp;them&amp;nbsp;to&amp;nbsp;the&amp;nbsp;level&amp;nbsp;of&amp;nbsp;a&amp;nbsp;concrete&amp;nbsp;API.&amp;nbsp;The&amp;nbsp;locks&amp;nbsp;package&lt;br&gt;
also&amp;nbsp;adds&amp;nbsp;the&amp;nbsp;concept&amp;nbsp;of&amp;nbsp;nonexclusive&amp;nbsp;reader/writer&amp;nbsp;locks,&amp;nbsp;allowing&amp;nbsp;for&amp;nbsp;greater&lt;br&gt;
concurrency&amp;nbsp;in&amp;nbsp;synchronized&amp;nbsp;data&amp;nbsp;access.&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;High-level&amp;nbsp;synchronization&amp;nbsp;constructs&lt;br&gt;
This&amp;nbsp;includes&amp;nbsp;the&amp;nbsp;classes&amp;nbsp;__&amp;nbsp;CyclicBarrier,&amp;nbsp;__&amp;nbsp;CountDownLatch,&amp;nbsp;__&amp;nbsp;Semaphore,&amp;nbsp;and&lt;br&gt;
__&amp;nbsp;Exchanger.&amp;nbsp;These&amp;nbsp;classes&amp;nbsp;implement&amp;nbsp;common&amp;nbsp;synchronization&amp;nbsp;patterns&amp;nbsp;drawn&lt;br&gt;
from&amp;nbsp;other&amp;nbsp;languages&amp;nbsp;and&amp;nbsp;systems&amp;nbsp;and&amp;nbsp;can&amp;nbsp;serve&amp;nbsp;as&amp;nbsp;the&amp;nbsp;basis&amp;nbsp;for&amp;nbsp;new&amp;nbsp;high-level&lt;br&gt;
tools.&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Atomic&amp;nbsp;operations&amp;nbsp;(sounds&amp;nbsp;very&amp;nbsp;James&amp;nbsp;Bond,&amp;nbsp;doesn’t&amp;nbsp;it?)&lt;br&gt;
The&amp;nbsp;java.util.concurrent.atomic&amp;nbsp;package&amp;nbsp;provides&amp;nbsp;wrappers&amp;nbsp;and&amp;nbsp;utilities&amp;nbsp;for&lt;br&gt;
atomic,&amp;nbsp;“all-or-nothing”&amp;nbsp;operations&amp;nbsp;on&amp;nbsp;primitive&amp;nbsp;types&amp;nbsp;and&amp;nbsp;references.&amp;nbsp;This&lt;br&gt;
includes&amp;nbsp;simple&amp;nbsp;combination&amp;nbsp;atomic&amp;nbsp;operations&amp;nbsp;like&amp;nbsp;testing&amp;nbsp;a&amp;nbsp;value&amp;nbsp;before&lt;br&gt;
setting&amp;nbsp;it&amp;nbsp;and&amp;nbsp;getting&amp;nbsp;and&amp;nbsp;incrementing&amp;nbsp;a&amp;nbsp;number&amp;nbsp;in&amp;nbsp;one&amp;nbsp;operation.&lt;br&gt;
&lt;br&gt;
================================================&lt;br&gt;
List&amp;nbsp;of&amp;nbsp;classes&amp;nbsp;in&amp;nbsp;packages&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java.util.concurrent&lt;br&gt;
&lt;br&gt;
Interfaces:&lt;br&gt;
BlockingDeque&lt;br&gt;
BlockingQueue&lt;br&gt;
Callable&lt;br&gt;
CompletionService&lt;br&gt;
ConcurrentMap&lt;br&gt;
ConcurrentNavigableMap&lt;br&gt;
Delayed&lt;br&gt;
Executor&lt;br&gt;
ExecutorService&lt;br&gt;
ForkJoinPool.ForkJoinWorkerThreadFactory&lt;br&gt;
ForkJoinPool.ManagedBlocker&lt;br&gt;
Future&lt;br&gt;
RejectedExecutionHandler&lt;br&gt;
RunnableFuture&lt;br&gt;
RunnableScheduledFuture&lt;br&gt;
ScheduledExecutorService&lt;br&gt;
ScheduledFuture&lt;br&gt;
ThreadFactory&lt;br&gt;
TransferQueue&lt;br&gt;
&lt;br&gt;
Classes&lt;br&gt;
AbstractExecutorService&lt;br&gt;
ArrayBlockingQueue&lt;br&gt;
ConcurrentHashMap&lt;br&gt;
ConcurrentLinkedDeque&lt;br&gt;
ConcurrentLinkedQueue&lt;br&gt;
ConcurrentSkipListMap&lt;br&gt;
ConcurrentSkipListSet&lt;br&gt;
CopyOnWriteArrayList&lt;br&gt;
CopyOnWriteArraySet&lt;br&gt;
CountDownLatch&lt;br&gt;
CyclicBarrier&lt;br&gt;
DelayQueue&lt;br&gt;
Exchanger&lt;br&gt;
ExecutorCompletionService&lt;br&gt;
Executors&lt;br&gt;
ForkJoinPool&lt;br&gt;
ForkJoinTask&lt;br&gt;
ForkJoinWorkerThread&lt;br&gt;
FutureTask&lt;br&gt;
LinkedBlockingDeque&lt;br&gt;
LinkedBlockingQueue&lt;br&gt;
LinkedTransferQueue&lt;br&gt;
Phaser&lt;br&gt;
PriorityBlockingQueue&lt;br&gt;
RecursiveAction&lt;br&gt;
RecursiveTask&lt;br&gt;
ScheduledThreadPoolExecutor&lt;br&gt;
Semaphore&lt;br&gt;
SynchronousQueue&lt;br&gt;
ThreadLocalRandom&lt;br&gt;
ThreadPoolExecutor&lt;br&gt;
ThreadPoolExecutor.AbortPolicy&lt;br&gt;
ThreadPoolExecutor.CallerRunsPolicy&lt;br&gt;
ThreadPoolExecutor.DiscardOldestPolicy&lt;br&gt;
ThreadPoolExecutor.DiscardPolicy&lt;br&gt;
&lt;br&gt;
Enums:&lt;br&gt;
TimeUnit&lt;br&gt;
&lt;br&gt;
Exceptions:&lt;br&gt;
BrokenBarrierException&lt;br&gt;
CancellationException&lt;br&gt;
ExecutionException&lt;br&gt;
RejectedExecutionException&lt;br&gt;
TimeoutException&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
==========&lt;br&gt;
java.util.concurrent.atomic&lt;br&gt;
&amp;nbsp;Classes:&lt;br&gt;
AtomicBoolean&lt;br&gt;
AtomicInteger&lt;br&gt;
AtomicIntegerArray&lt;br&gt;
AtomicIntegerFieldUpdater&lt;br&gt;
AtomicLong&lt;br&gt;
AtomicLongArray&lt;br&gt;
AtomicLongFieldUpdater&lt;br&gt;
AtomicMarkableReference&lt;br&gt;
AtomicReference&lt;br&gt;
AtomicReferenceArray&lt;br&gt;
AtomicReferenceFieldUpdater&lt;br&gt;
AtomicStampedReference&lt;br&gt;
&lt;br&gt;
============&lt;br&gt;
java.util.concurrent.locks&lt;br&gt;
&amp;nbsp;Interfaces:&lt;br&gt;
Condition&lt;br&gt;
Lock&lt;br&gt;
ReadWriteLock&lt;br&gt;
&lt;br&gt;
Classes:&amp;nbsp;&lt;br&gt;
AbstractOwnableSynchronizer&lt;br&gt;
AbstractQueuedLongSynchronizer&lt;br&gt;
AbstractQueuedSynchronizer&lt;br&gt;
LockSupport&lt;br&gt;
ReentrantLock&lt;br&gt;
ReentrantReadWriteLock&lt;br&gt;
ReentrantReadWriteLock.ReadLock&lt;br&gt;
ReentrantReadWriteLock.WriteLock</questionanswer>
  </question>
  <question id="1_0_0_3_0:18" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;java.util.concurent&amp;nbsp;:&amp;nbsp;Executors,&amp;nbsp;describe.Describe&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Executor&amp;nbsp;and&amp;nbsp;ExecutorService&amp;nbsp;interfaces.&lt;br&gt;
Which&amp;nbsp;pools&amp;nbsp;'Executors'&amp;nbsp;class&amp;nbsp;can&amp;nbsp;create&amp;nbsp;?&amp;nbsp;What&amp;nbsp;is&amp;nbsp;ScheduledExecutorService&amp;nbsp;?&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>When&amp;nbsp;we&amp;nbsp;recognize&amp;nbsp;certain&amp;nbsp;common&amp;nbsp;patterns&amp;nbsp;that&amp;nbsp;developers&lt;br&gt;
reproduce&amp;nbsp;over&amp;nbsp;and&amp;nbsp;over&amp;nbsp;again&amp;nbsp;using&amp;nbsp;threads,&amp;nbsp;it’s&amp;nbsp;natural&amp;nbsp;to&amp;nbsp;want&lt;br&gt;
to&amp;nbsp;elevate&amp;nbsp;a&amp;nbsp;pattern&amp;nbsp;to&amp;nbsp;the&amp;nbsp;level&amp;nbsp;of&amp;nbsp;an&amp;nbsp;API.&lt;br&gt;
&lt;br&gt;
One&amp;nbsp;such&amp;nbsp;related&amp;nbsp;pair&amp;nbsp;of&amp;nbsp;patterns&amp;nbsp;is&amp;nbsp;the&amp;nbsp;concept&amp;nbsp;of&amp;nbsp;an&amp;nbsp;executor&lt;br&gt;
service&amp;nbsp;that&amp;nbsp;manages&amp;nbsp;tasks&amp;nbsp;and&amp;nbsp;that&amp;nbsp;of&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;that&amp;nbsp;services&lt;br&gt;
tasks&amp;nbsp;in&amp;nbsp;an&amp;nbsp;efficient&amp;nbsp;way.&lt;br&gt;
&lt;br&gt;
!!!The&amp;nbsp;java.util.concurrent&amp;nbsp;package&amp;nbsp;includes&amp;nbsp;interfaces&amp;nbsp;for&amp;nbsp;many&amp;nbsp;default&lt;br&gt;
implementations&amp;nbsp;of&amp;nbsp;the&amp;nbsp;executor&amp;nbsp;pattern&amp;nbsp;for&amp;nbsp;common&amp;nbsp;threading&amp;nbsp;models.&amp;nbsp;This&lt;br&gt;
includes&amp;nbsp;sophisticated&amp;nbsp;scheduling&amp;nbsp;as&amp;nbsp;well&amp;nbsp;as&amp;nbsp;asynchronous&amp;nbsp;collection&amp;nbsp;of&amp;nbsp;results&lt;br&gt;
from&amp;nbsp;the&amp;nbsp;tasks,&amp;nbsp;if&amp;nbsp;they&amp;nbsp;require&amp;nbsp;it.&amp;nbsp;In&amp;nbsp;general,&amp;nbsp;you&amp;nbsp;can&amp;nbsp;use&amp;nbsp;an&amp;nbsp;Executor&amp;nbsp;as&amp;nbsp;a&lt;br&gt;
replacement&amp;nbsp;for&amp;nbsp;creating&amp;nbsp;one-off&amp;nbsp;threads&amp;nbsp;anywhere&amp;nbsp;you&amp;nbsp;need&amp;nbsp;to&amp;nbsp;execute&amp;nbsp;Runnable&lt;br&gt;
objects.&amp;nbsp;The&amp;nbsp;advantage&amp;nbsp;is&amp;nbsp;that&amp;nbsp;understanding&amp;nbsp;and&amp;nbsp;modifying&amp;nbsp;the&amp;nbsp;behavior&amp;nbsp;of&amp;nbsp;your&lt;br&gt;
code&amp;nbsp;later&amp;nbsp;is&amp;nbsp;a&amp;nbsp;lot&amp;nbsp;easier&amp;nbsp;when&amp;nbsp;you&amp;nbsp;work&amp;nbsp;at&amp;nbsp;this&amp;nbsp;level.&lt;br&gt;
&lt;br&gt;
For&amp;nbsp;the&amp;nbsp;simple&amp;nbsp;case&amp;nbsp;of&amp;nbsp;running&amp;nbsp;a&amp;nbsp;number&amp;nbsp;of&amp;nbsp;tasks&amp;nbsp;and&amp;nbsp;watching&amp;nbsp;for&amp;nbsp;their&amp;nbsp;completion,&lt;br&gt;
we&amp;nbsp;can&amp;nbsp;consider&amp;nbsp;the&amp;nbsp;base&amp;nbsp;__&amp;nbsp;Executor&amp;nbsp;interface&amp;nbsp;__,&amp;nbsp;which&amp;nbsp;executes&amp;nbsp;Runnable&lt;br&gt;
objects&amp;nbsp;for&amp;nbsp;us.&amp;nbsp;A&amp;nbsp;convenient&amp;nbsp;thing&amp;nbsp;about&amp;nbsp;Executor&amp;nbsp;is&amp;nbsp;that&amp;nbsp;its&amp;nbsp;companion&amp;nbsp;utility&amp;nbsp;class&lt;br&gt;
Executors&amp;nbsp;is&amp;nbsp;a&amp;nbsp;factory&amp;nbsp;for&amp;nbsp;creating&amp;nbsp;different&amp;nbsp;kinds&amp;nbsp;of&amp;nbsp;Executor&amp;nbsp;implementations.&lt;br&gt;
We’ll&amp;nbsp;talk&amp;nbsp;about&amp;nbsp;the&amp;nbsp;various&amp;nbsp;types&amp;nbsp;it&amp;nbsp;can&amp;nbsp;produce&amp;nbsp;in&amp;nbsp;a&amp;nbsp;bit,&amp;nbsp;but&amp;nbsp;for&amp;nbsp;now&amp;nbsp;let’s&amp;nbsp;use&amp;nbsp;the&lt;br&gt;
method&amp;nbsp;called&amp;nbsp;newFixed&amp;nbsp;ThreadPool(),&amp;nbsp;which,&amp;nbsp;as&amp;nbsp;its&amp;nbsp;name&amp;nbsp;suggests,&amp;nbsp;returns&amp;nbsp;an&lt;br&gt;
Executor&amp;nbsp;that&amp;nbsp;is&amp;nbsp;implemented&amp;nbsp;using&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;of&amp;nbsp;a&amp;nbsp;fixed&amp;nbsp;size:&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&amp;nbsp;Executor&amp;nbsp;executor&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(&amp;nbsp;3&amp;nbsp;)&amp;nbsp;;&amp;nbsp;//&amp;nbsp;3&amp;nbsp;threads&lt;br&gt;
&amp;nbsp;List&lt;Runnable&gt;&amp;nbsp;runnables&amp;nbsp;=&amp;nbsp;...&amp;nbsp;;&lt;br&gt;
&amp;nbsp;for(&amp;nbsp;Runnable&amp;nbsp;task&amp;nbsp;:&amp;nbsp;runnables&amp;nbsp;)&lt;br&gt;
&amp;nbsp;executor.execute(&amp;nbsp;task&amp;nbsp;);&lt;br&gt;
&lt;br&gt;
Here,&amp;nbsp;we&amp;nbsp;are&amp;nbsp;submitting&amp;nbsp;a&amp;nbsp;number&amp;nbsp;of&amp;nbsp;Runnable&amp;nbsp;tasks&amp;nbsp;to&amp;nbsp;our&amp;nbsp;Executor,&amp;nbsp;which&lt;br&gt;
executes&amp;nbsp;them&amp;nbsp;using&amp;nbsp;a&amp;nbsp;pool&amp;nbsp;with&amp;nbsp;a&amp;nbsp;maximum&amp;nbsp;of&amp;nbsp;three&amp;nbsp;threads.&amp;nbsp;If&amp;nbsp;our&amp;nbsp;list&amp;nbsp;contains&lt;br&gt;
more&amp;nbsp;than&amp;nbsp;three&amp;nbsp;tasks,&amp;nbsp;then&amp;nbsp;some&amp;nbsp;of&amp;nbsp;them&amp;nbsp;will&amp;nbsp;have&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;until&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;free&lt;br&gt;
to&amp;nbsp;service&amp;nbsp;it.&amp;nbsp;So,&amp;nbsp;what&amp;nbsp;happens&amp;nbsp;when&amp;nbsp;we&amp;nbsp;submit&amp;nbsp;the&amp;nbsp;fourth&amp;nbsp;item?&amp;nbsp;The&amp;nbsp;Executor&lt;br&gt;
interface&amp;nbsp;doesn’t&amp;nbsp;really&amp;nbsp;specify&amp;nbsp;that.&amp;nbsp;It’s&amp;nbsp;up&amp;nbsp;to&amp;nbsp;the&amp;nbsp;particular&amp;nbsp;implementation&amp;nbsp;to&lt;br&gt;
decide.&amp;nbsp;Without&amp;nbsp;specifying&amp;nbsp;more&amp;nbsp;about&amp;nbsp;its&amp;nbsp;type,&amp;nbsp;we&amp;nbsp;don’t&amp;nbsp;know&amp;nbsp;if&amp;nbsp;an&amp;nbsp;Executor&amp;nbsp;is&amp;nbsp;going&lt;br&gt;
to&amp;nbsp;queue&amp;nbsp;tasks,&amp;nbsp;or&amp;nbsp;if&amp;nbsp;it&amp;nbsp;will&amp;nbsp;use&amp;nbsp;a&amp;nbsp;pool&amp;nbsp;to&amp;nbsp;service&amp;nbsp;them.&amp;nbsp;Some&amp;nbsp;Executor&lt;br&gt;
implementations&amp;nbsp;may&amp;nbsp;block&amp;nbsp;or&amp;nbsp;even&amp;nbsp;execute&amp;nbsp;the&amp;nbsp;Runnable&amp;nbsp;right&amp;nbsp;on&amp;nbsp;the&amp;nbsp;execute()&lt;br&gt;
call&amp;nbsp;in&amp;nbsp;the&amp;nbsp;caller’s&amp;nbsp;thread.&amp;nbsp;But&amp;nbsp;in&amp;nbsp;this&amp;nbsp;case&amp;nbsp;(and&amp;nbsp;for&amp;nbsp;allExecutor&amp;nbsp;implementations&amp;nbsp;created&lt;br&gt;
for&amp;nbsp;us&amp;nbsp;by&amp;nbsp;the&amp;nbsp;Executors&amp;nbsp;factory&amp;nbsp;methods),&amp;nbsp;tasks&amp;nbsp;are&amp;nbsp;effectively&amp;nbsp;put&amp;nbsp;onto&amp;nbsp;an&amp;nbsp;unbounded&lt;br&gt;
queue.&amp;nbsp;In&amp;nbsp;the&amp;nbsp;example,&amp;nbsp;our&amp;nbsp;loop&amp;nbsp;submits&amp;nbsp;all&amp;nbsp;of&amp;nbsp;the&amp;nbsp;tasks&amp;nbsp;immediately&amp;nbsp;and&amp;nbsp;they&amp;nbsp;are&lt;br&gt;
queued&amp;nbsp;by&amp;nbsp;the&amp;nbsp;executor&amp;nbsp;until&amp;nbsp;the&amp;nbsp;three&amp;nbsp;threads&amp;nbsp;have&amp;nbsp;serviced&amp;nbsp;them.&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&amp;nbsp;&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;javautilconcurent;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.Random;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Executor;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ExecutorService;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Executors;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;HelloExecutors&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ExecutorService&amp;nbsp;executor&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(3);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(executor.getClass());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.execute(new&amp;nbsp;MyThread());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.shutdown();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(!executor.isTerminated())&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Finished&amp;nbsp;all&amp;nbsp;threads");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;MyThread&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Executing&amp;nbsp;thread&amp;nbsp;"&amp;nbsp;+&amp;nbsp;new&amp;nbsp;Random().nextInt(100));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
class&amp;nbsp;java.util.concurrent.ThreadPoolExecutor&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;42&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;20&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;60&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;8&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;46&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;4&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;32&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;74&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;45&lt;br&gt;
Executing&amp;nbsp;thread&amp;nbsp;46&lt;br&gt;
Finished&amp;nbsp;all&amp;nbsp;threads&lt;br&gt;
&lt;br&gt;
==============================&lt;br&gt;
&amp;nbsp;&amp;nbsp;ExecutorService&lt;br&gt;
&lt;br&gt;
&amp;nbsp;Our&amp;nbsp;first&amp;nbsp;Executor&amp;nbsp;was&amp;nbsp;little&amp;nbsp;more&amp;nbsp;than&amp;nbsp;a&amp;nbsp;sinkhole&amp;nbsp;for&amp;nbsp;Runnables&amp;nbsp;and,&amp;nbsp;as&amp;nbsp;we&lt;br&gt;
described,&amp;nbsp;required&amp;nbsp;knowledge&amp;nbsp;of&amp;nbsp;the&amp;nbsp;implementation&amp;nbsp;to&amp;nbsp;know&amp;nbsp;how&amp;nbsp;it&amp;nbsp;would&amp;nbsp;handle&lt;br&gt;
tasks.&amp;nbsp;By&amp;nbsp;contrast,&amp;nbsp;an&amp;nbsp;ExecutorService&amp;nbsp;is&amp;nbsp;intended&amp;nbsp;to&amp;nbsp;be&amp;nbsp;an&amp;nbsp;asynchronous&amp;nbsp;task&amp;nbsp;handler.&lt;br&gt;
Instead&amp;nbsp;of&amp;nbsp;an&amp;nbsp;execute()&amp;nbsp;method,&amp;nbsp;it&amp;nbsp;has&amp;nbsp;submit()&amp;nbsp;methods&amp;nbsp;that&amp;nbsp;accept&amp;nbsp;a&amp;nbsp;Callable&amp;nbsp;(or&lt;br&gt;
Runnable)&amp;nbsp;and&amp;nbsp;return&amp;nbsp;immediately&amp;nbsp;with&amp;nbsp;a&amp;nbsp;Future&amp;nbsp;object&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;manage&amp;nbsp;the&lt;br&gt;
task&amp;nbsp;and&amp;nbsp;collect&amp;nbsp;the&amp;nbsp;result&amp;nbsp;later.&amp;nbsp;In&amp;nbsp;addition&amp;nbsp;to&amp;nbsp;that,&amp;nbsp;an&amp;nbsp;ExecutorService&amp;nbsp;has&amp;nbsp;a&amp;nbsp;lifecycle&lt;br&gt;
defined&amp;nbsp;by&amp;nbsp;its&amp;nbsp;shutdown()&amp;nbsp;method&amp;nbsp;and&amp;nbsp;related&amp;nbsp;methods&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;stop&amp;nbsp;the&lt;br&gt;
service&amp;nbsp;gracefully&amp;nbsp;after&amp;nbsp;tasks&amp;nbsp;are&amp;nbsp;completed.&lt;br&gt;
&lt;br&gt;
ExecutorService&amp;nbsp;extends&amp;nbsp;Executor.&amp;nbsp;In&amp;nbsp;fact,&amp;nbsp;___&amp;nbsp;all&amp;nbsp;of&amp;nbsp;the&amp;nbsp;implementations&amp;nbsp;returned&amp;nbsp;by&lt;br&gt;
the&amp;nbsp;Executors&amp;nbsp;factory&amp;nbsp;methods&amp;nbsp;are&amp;nbsp;actually&amp;nbsp;ExecutorServices&amp;nbsp;___&amp;nbsp;—including&amp;nbsp;the&amp;nbsp;one&amp;nbsp;we&lt;br&gt;
used&amp;nbsp;in&amp;nbsp;our&amp;nbsp;first&amp;nbsp;example.&amp;nbsp;We’ll&amp;nbsp;look&amp;nbsp;at&amp;nbsp;these&amp;nbsp;factory&amp;nbsp;methods&amp;nbsp;to&amp;nbsp;see&amp;nbsp;what&amp;nbsp;kind&amp;nbsp;of&lt;br&gt;
services&amp;nbsp;are&amp;nbsp;offered.&lt;br&gt;
&lt;br&gt;
!!!!&lt;br&gt;
Executors&amp;nbsp;offers&amp;nbsp;three&amp;nbsp;types&amp;nbsp;of&amp;nbsp;ExecutorService&amp;nbsp;implementations&amp;nbsp;:&lt;br&gt;
-&amp;nbsp;newFixedThreadPool(int)&lt;br&gt;
This&amp;nbsp;is&amp;nbsp;the&amp;nbsp;classic&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;with&amp;nbsp;a&amp;nbsp;specified&amp;nbsp;maximum&amp;nbsp;pool&amp;nbsp;size&amp;nbsp;and&amp;nbsp;an&lt;br&gt;
unbounded&amp;nbsp;queue&amp;nbsp;for&amp;nbsp;task&amp;nbsp;submission.&amp;nbsp;If&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;dies&amp;nbsp;for&amp;nbsp;some&amp;nbsp;reason&amp;nbsp;while&lt;br&gt;
handling&amp;nbsp;a&amp;nbsp;task,&amp;nbsp;a&amp;nbsp;new&amp;nbsp;one&amp;nbsp;will&amp;nbsp;be&amp;nbsp;created&amp;nbsp;to&amp;nbsp;replace&amp;nbsp;it.&amp;nbsp;Threads&amp;nbsp;are&amp;nbsp;never&lt;br&gt;
removed&amp;nbsp;from&amp;nbsp;the&amp;nbsp;pool&amp;nbsp;until&amp;nbsp;the&amp;nbsp;service&amp;nbsp;is&amp;nbsp;shut&amp;nbsp;down.&lt;br&gt;
-&amp;nbsp;newCachedThreadPool()&lt;br&gt;
This&amp;nbsp;pool&amp;nbsp;uses&amp;nbsp;an&amp;nbsp;open-ended&amp;nbsp;number&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;grows&amp;nbsp;and&amp;nbsp;shrinks&amp;nbsp;with&lt;br&gt;
demand.&amp;nbsp;The&amp;nbsp;main&amp;nbsp;advantage&amp;nbsp;of&amp;nbsp;this&amp;nbsp;service&amp;nbsp;is&amp;nbsp;that&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;cached&amp;nbsp;for&amp;nbsp;a&lt;br&gt;
period&amp;nbsp;of&amp;nbsp;time&amp;nbsp;and&amp;nbsp;reused,&amp;nbsp;eliminating&amp;nbsp;the&amp;nbsp;overhead&amp;nbsp;of&amp;nbsp;creating&amp;nbsp;new&amp;nbsp;threads&amp;nbsp;for&lt;br&gt;
short-lived&amp;nbsp;tasks.&amp;nbsp;Threads&amp;nbsp;that&amp;nbsp;are&amp;nbsp;not&amp;nbsp;used&amp;nbsp;for&amp;nbsp;one&amp;nbsp;minute&amp;nbsp;are&amp;nbsp;removed.&amp;nbsp;Tasks&lt;br&gt;
are&amp;nbsp;submitted&amp;nbsp;directly&amp;nbsp;to&amp;nbsp;threads;&amp;nbsp;there&amp;nbsp;is&amp;nbsp;no&amp;nbsp;real&amp;nbsp;queuing.&lt;br&gt;
-&amp;nbsp;newSingleThreadExecutor()&lt;br&gt;
This&amp;nbsp;ExecutorService&amp;nbsp;uses&amp;nbsp;a&amp;nbsp;single&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;execute&amp;nbsp;tasks&amp;nbsp;from&amp;nbsp;an&amp;nbsp;unbounded&lt;br&gt;
queue.&amp;nbsp;In&amp;nbsp;this&amp;nbsp;sense,&amp;nbsp;it&amp;nbsp;is&amp;nbsp;identical&amp;nbsp;to&amp;nbsp;a&amp;nbsp;fixed&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;with&amp;nbsp;a&amp;nbsp;pool&amp;nbsp;size&amp;nbsp;of&amp;nbsp;1.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
=======&lt;br&gt;
Collective&amp;nbsp;tasks&lt;br&gt;
In&amp;nbsp;addition&amp;nbsp;to&amp;nbsp;its&amp;nbsp;individual&amp;nbsp;task&amp;nbsp;submit()&amp;nbsp;methods,&amp;nbsp;ExecutorService&amp;nbsp;also&amp;nbsp;offers&amp;nbsp;a&lt;br&gt;
set&amp;nbsp;of&amp;nbsp;collective&amp;nbsp;invokeAll()&amp;nbsp;and&amp;nbsp;invokeAny()&amp;nbsp;executor&amp;nbsp;methods&amp;nbsp;that&amp;nbsp;submit&amp;nbsp;multiple&lt;br&gt;
tasks&amp;nbsp;as&amp;nbsp;a&amp;nbsp;group&amp;nbsp;and&amp;nbsp;return&amp;nbsp;results&amp;nbsp;either&amp;nbsp;when&amp;nbsp;they&amp;nbsp;are&amp;nbsp;all&amp;nbsp;complete&amp;nbsp;or&amp;nbsp;when&amp;nbsp;the&lt;br&gt;
first&amp;nbsp;one&amp;nbsp;completes,&amp;nbsp;respectively.&amp;nbsp;With&amp;nbsp;this,&amp;nbsp;we&amp;nbsp;could&amp;nbsp;reproduce&amp;nbsp;our&amp;nbsp;first&amp;nbsp;example&lt;br&gt;
using&amp;nbsp;a&amp;nbsp;List&amp;nbsp;of&amp;nbsp;Callables&amp;nbsp;like&amp;nbsp;this:&lt;br&gt;
&amp;nbsp;&lt;br&gt;
&amp;nbsp;List&lt;Callable&lt;Integer&gt;&gt;&amp;nbsp;taskList&amp;nbsp;=&amp;nbsp;...;&lt;br&gt;
&amp;nbsp;ExecutorService&amp;nbsp;execService&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(3);&lt;br&gt;
&amp;nbsp;List&lt;Future&lt;Integer&gt;&gt;&amp;nbsp;resultList&amp;nbsp;=&amp;nbsp;execService.invokeAll(&amp;nbsp;taskList&amp;nbsp;);&lt;br&gt;
&lt;br&gt;
By&amp;nbsp;contrast,&amp;nbsp;the&amp;nbsp;invokeAny()&amp;nbsp;method&amp;nbsp;returns&amp;nbsp;just&amp;nbsp;the&amp;nbsp;first&amp;nbsp;successfully&amp;nbsp;completed&lt;br&gt;
task’s&amp;nbsp;result&amp;nbsp;(cancelling&amp;nbsp;all&amp;nbsp;the&amp;nbsp;remaining&amp;nbsp;unexecuted&amp;nbsp;tasks):&lt;br&gt;
&amp;nbsp;int&amp;nbsp;result&amp;nbsp;=&amp;nbsp;execService.invokeAny(&amp;nbsp;taskList&amp;nbsp;);&lt;br&gt;
&lt;br&gt;
Both&amp;nbsp;methods&amp;nbsp;also&amp;nbsp;offer&amp;nbsp;timed&amp;nbsp;wait&amp;nbsp;versions&amp;nbsp;that&amp;nbsp;time&amp;nbsp;out&amp;nbsp;after&amp;nbsp;a&amp;nbsp;specified&lt;br&gt;
period&amp;nbsp;of&amp;nbsp;time.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
============================================================&lt;br&gt;
Executor&amp;nbsp;and&amp;nbsp;ExecutorService&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='920'&amp;nbsp;height='660'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ExecutorServices.png'/&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='800'&amp;nbsp;height='680'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ThreadPoolExecutorandFactory.png'/&gt;&lt;br&gt;
============================================================&lt;br&gt;
Collective&amp;nbsp;tasks&lt;br&gt;
In&amp;nbsp;addition&amp;nbsp;to&amp;nbsp;its&amp;nbsp;individual&amp;nbsp;task&amp;nbsp;submit()&amp;nbsp;methods,&amp;nbsp;ExecutorService&amp;nbsp;also&amp;nbsp;offers&amp;nbsp;a&amp;nbsp;set&lt;br&gt;
of&amp;nbsp;collective&amp;nbsp;invokeAll()&amp;nbsp;and&amp;nbsp;invokeAny()&amp;nbsp;executor&amp;nbsp;methods&amp;nbsp;that&amp;nbsp;submit&amp;nbsp;multiple&lt;br&gt;
tasks&amp;nbsp;as&amp;nbsp;a&amp;nbsp;group&amp;nbsp;and&amp;nbsp;return&amp;nbsp;results&amp;nbsp;either&amp;nbsp;when&amp;nbsp;they&amp;nbsp;are&amp;nbsp;all&amp;nbsp;complete&amp;nbsp;or&amp;nbsp;when&amp;nbsp;the&amp;nbsp;first&lt;br&gt;
one&amp;nbsp;completes,&amp;nbsp;respectively.&amp;nbsp;With&amp;nbsp;this,&amp;nbsp;we&amp;nbsp;could&amp;nbsp;reproduce&amp;nbsp;our&amp;nbsp;first&amp;nbsp;example&amp;nbsp;using&amp;nbsp;a&lt;br&gt;
List&amp;nbsp;of&amp;nbsp;Callables&amp;nbsp;like&amp;nbsp;this:&lt;br&gt;
&lt;br&gt;
List&lt;Callable&lt;Integer&gt;&gt;&amp;nbsp;taskList&amp;nbsp;=&amp;nbsp;...;&lt;br&gt;
ExecutorService&amp;nbsp;execService&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(3);&lt;br&gt;
List&lt;Future&lt;Integer&gt;&gt;&amp;nbsp;resultList&amp;nbsp;=&amp;nbsp;execService.invokeAll(&amp;nbsp;taskList&amp;nbsp;);&lt;br&gt;
&lt;br&gt;
By&amp;nbsp;contrast,&amp;nbsp;the&amp;nbsp;invokeAny()&amp;nbsp;method&amp;nbsp;returns&amp;nbsp;just&amp;nbsp;the&amp;nbsp;first&amp;nbsp;successfully&amp;nbsp;completed&lt;br&gt;
task’s&amp;nbsp;result&amp;nbsp;(cancelling&amp;nbsp;all&amp;nbsp;the&amp;nbsp;remaining&amp;nbsp;unexecuted&amp;nbsp;tasks):&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;int&amp;nbsp;result&amp;nbsp;=&amp;nbsp;execService.invokeAny(&amp;nbsp;taskList&amp;nbsp;);&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;javautilconcurent;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.HashSet;&lt;br&gt;
import&amp;nbsp;java.util.List;&lt;br&gt;
import&amp;nbsp;java.util.Set;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Callable;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ExecutionException;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ExecutorService;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Executors;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Future;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ExecutorsInvokeAll&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;throws&amp;nbsp;InterruptedException,&amp;nbsp;ExecutionException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ExecutorService&amp;nbsp;executorService&amp;nbsp;=&amp;nbsp;Executors.newSingleThreadExecutor();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Set&lt;Callable&lt;String&gt;&gt;&amp;nbsp;callables&amp;nbsp;=&amp;nbsp;new&amp;nbsp;HashSet&lt;Callable&lt;String&gt;&gt;();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;callables.add(new&amp;nbsp;Callable&lt;String&gt;()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;String&amp;nbsp;call()&amp;nbsp;throws&amp;nbsp;Exception&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;"Task&amp;nbsp;1";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;callables.add(new&amp;nbsp;Callable&lt;String&gt;()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;String&amp;nbsp;call()&amp;nbsp;throws&amp;nbsp;Exception&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;"Task&amp;nbsp;3";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List&lt;Future&lt;String&gt;&gt;&amp;nbsp;futures&amp;nbsp;=&amp;nbsp;executorService.invokeAll(callables);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(Future&lt;String&gt;&amp;nbsp;future&amp;nbsp;:&amp;nbsp;futures)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(future.get());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executorService.shutdown();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Task&amp;nbsp;1&lt;br&gt;
Task&amp;nbsp;3&lt;br&gt;
====================================================&lt;br&gt;
&lt;br&gt;
Scheduled&amp;nbsp;tasks&lt;br&gt;
&lt;br&gt;
For&amp;nbsp;tasks&amp;nbsp;that&amp;nbsp;you’d&amp;nbsp;like&amp;nbsp;to&amp;nbsp;run&amp;nbsp;at&amp;nbsp;a&amp;nbsp;future&amp;nbsp;time&amp;nbsp;or&amp;nbsp;on&amp;nbsp;a&amp;nbsp;periodic&amp;nbsp;basis,&amp;nbsp;use&amp;nbsp;the&lt;br&gt;
ScheduledExecutorService.&amp;nbsp;ScheduledExecutorService&amp;nbsp;is&amp;nbsp;an&amp;nbsp;ExecutorService&amp;nbsp;with&lt;br&gt;
additional&amp;nbsp;“schedule”&amp;nbsp;methods&amp;nbsp;that&amp;nbsp;take&amp;nbsp;a&amp;nbsp;delay&amp;nbsp;for&amp;nbsp;a&amp;nbsp;Runnable&amp;nbsp;or&amp;nbsp;Callable&amp;nbsp;or&amp;nbsp;a&amp;nbsp;period&lt;br&gt;
specification&amp;nbsp;for&amp;nbsp;a&amp;nbsp;Runnable.&amp;nbsp;Two&amp;nbsp;additional&amp;nbsp;factory&amp;nbsp;methods&amp;nbsp;of&amp;nbsp;Executors&amp;nbsp;produce&lt;br&gt;
scheduled&amp;nbsp;executors:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Executors.newScheduledThreadPool(int);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Executors.newSingleThreadScheduledExecutor();&lt;br&gt;
&lt;br&gt;
These&amp;nbsp;are&amp;nbsp;exactly&amp;nbsp;like&amp;nbsp;the&amp;nbsp;similarly&amp;nbsp;named&amp;nbsp;methods&amp;nbsp;for&amp;nbsp;regular&amp;nbsp;executor&amp;nbsp;services,&amp;nbsp;with&lt;br&gt;
the&amp;nbsp;exception&amp;nbsp;of&amp;nbsp;returning&amp;nbsp;a&amp;nbsp;scheduled&amp;nbsp;executor&amp;nbsp;type.&lt;br&gt;
To&amp;nbsp;execute&amp;nbsp;a&amp;nbsp;task&amp;nbsp;in&amp;nbsp;the&amp;nbsp;future,&amp;nbsp;you&amp;nbsp;specify&amp;nbsp;a&amp;nbsp;delay&amp;nbsp;from&amp;nbsp;the&amp;nbsp;current&amp;nbsp;time.&amp;nbsp;For&amp;nbsp;example:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;ScheduledExecutorService&amp;nbsp;exec&amp;nbsp;=&amp;nbsp;Executors.newScheduledThreadPool(3);&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&amp;nbsp;&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;javautilconcurent;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Executors;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ScheduledExecutorService;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.TimeUnit;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ExecutorsScheduledThreadPoolExecutor&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ScheduledExecutorService&amp;nbsp;scheduledPool&amp;nbsp;=&amp;nbsp;Executors.newScheduledThreadPool(4);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Start&amp;nbsp;thread&amp;nbsp;"&amp;nbsp;+&amp;nbsp;Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(400);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;TODO&amp;nbsp;Auto-generated&amp;nbsp;catch&amp;nbsp;block&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("End&amp;nbsp;thread&amp;nbsp;"&amp;nbsp;+&amp;nbsp;Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Start&amp;nbsp;thread&amp;nbsp;"&amp;nbsp;+&amp;nbsp;Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(400);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;TODO&amp;nbsp;Auto-generated&amp;nbsp;catch&amp;nbsp;block&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("End&amp;nbsp;thread&amp;nbsp;"&amp;nbsp;+&amp;nbsp;Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;scheduledPool.schedule(t1,&amp;nbsp;10,&amp;nbsp;TimeUnit.SECONDS);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;scheduledPool.schedule(t2,&amp;nbsp;3,&amp;nbsp;TimeUnit.SECONDS);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;scheduledPool.shutdown();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;///&amp;nbsp;shutdown&amp;nbsp;VS&amp;nbsp;shutdownNow&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/*In&amp;nbsp;summary,&amp;nbsp;you&amp;nbsp;can&amp;nbsp;think&amp;nbsp;of&amp;nbsp;it&amp;nbsp;that&amp;nbsp;way:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;shutdown()&amp;nbsp;will&amp;nbsp;just&amp;nbsp;tell&amp;nbsp;the&amp;nbsp;executor&amp;nbsp;service&amp;nbsp;that&amp;nbsp;it&amp;nbsp;can't&amp;nbsp;accept&amp;nbsp;new&amp;nbsp;tasks,&amp;nbsp;but&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;the&amp;nbsp;already&amp;nbsp;submitted&amp;nbsp;tasks&amp;nbsp;continue&amp;nbsp;to&amp;nbsp;run&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;shutdownNow()&amp;nbsp;will&amp;nbsp;do&amp;nbsp;the&amp;nbsp;same&amp;nbsp;AND&amp;nbsp;will&amp;nbsp;try&amp;nbsp;to&amp;nbsp;cancel&amp;nbsp;the&amp;nbsp;already&amp;nbsp;submitted&amp;nbsp;tasks&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;by&amp;nbsp;interrupting&amp;nbsp;the&amp;nbsp;relevant&amp;nbsp;threads.&amp;nbsp;Note&amp;nbsp;that&amp;nbsp;if&amp;nbsp;your&amp;nbsp;tasks&amp;nbsp;ignore&amp;nbsp;the&amp;nbsp;interruption,&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;shutdownNow&amp;nbsp;will&amp;nbsp;behave&amp;nbsp;exactly&amp;nbsp;the&amp;nbsp;same&amp;nbsp;way&amp;nbsp;as&amp;nbsp;shutdown.*/&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Start&amp;nbsp;thread&amp;nbsp;pool-1-thread-1&lt;br&gt;
End&amp;nbsp;thread&amp;nbsp;pool-1-thread-1&lt;br&gt;
Start&amp;nbsp;thread&amp;nbsp;pool-1-thread-2&lt;br&gt;
End&amp;nbsp;thread&amp;nbsp;pool-1-thread-2&lt;br&gt;
&lt;br&gt;
===============================================&lt;br&gt;
&amp;nbsp;CompletionService&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;CompletionService&amp;nbsp;is&amp;nbsp;a&amp;nbsp;lightweight&amp;nbsp;queue-like&amp;nbsp;frontend&amp;nbsp;to&amp;nbsp;an&amp;nbsp;executor.&amp;nbsp;The&amp;nbsp;Comple&lt;br&gt;
tionService&amp;nbsp;provides&amp;nbsp;submit()&amp;nbsp;methods,&amp;nbsp;which&amp;nbsp;delegate&amp;nbsp;their&amp;nbsp;tasks&amp;nbsp;to&amp;nbsp;a&amp;nbsp;particular&lt;br&gt;
instance&amp;nbsp;of&amp;nbsp;Executor,&amp;nbsp;and&amp;nbsp;then&amp;nbsp;provides&amp;nbsp;take()&amp;nbsp;and&amp;nbsp;poll()&amp;nbsp;methods&amp;nbsp;for&amp;nbsp;retrieving&lt;br&gt;
Future&amp;nbsp;results&amp;nbsp;for&amp;nbsp;completed&amp;nbsp;tasks.&amp;nbsp;Think&amp;nbsp;of&amp;nbsp;a&amp;nbsp;CompletionService&amp;nbsp;as&amp;nbsp;a&amp;nbsp;babysitter&amp;nbsp;for&lt;br&gt;
the&amp;nbsp;Futures,&amp;nbsp;allowing&amp;nbsp;you&amp;nbsp;to&amp;nbsp;easily&amp;nbsp;gather&amp;nbsp;up&amp;nbsp;only&amp;nbsp;completed&amp;nbsp;results&amp;nbsp;(as&amp;nbsp;opposed&amp;nbsp;to&lt;br&gt;
having&amp;nbsp;to&amp;nbsp;check&amp;nbsp;each&amp;nbsp;Future&amp;nbsp;yourself&amp;nbsp;to&amp;nbsp;see&amp;nbsp;which&amp;nbsp;ones&amp;nbsp;have&amp;nbsp;finished&amp;nbsp;and&amp;nbsp;in&amp;nbsp;what&amp;nbsp;order).&lt;br&gt;
ExecutorCompletionService&amp;nbsp;is&amp;nbsp;a&amp;nbsp;concrete&amp;nbsp;implementation&amp;nbsp;of&amp;nbsp;CompletionService&amp;nbsp;that&lt;br&gt;
takes&amp;nbsp;an&amp;nbsp;Executor&amp;nbsp;in&amp;nbsp;its&amp;nbsp;constructor:&lt;br&gt;
&lt;br&gt;
Executor&amp;nbsp;executor&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(3);&lt;br&gt;
CompletionService&lt;Integer&gt;&amp;nbsp;completionService&amp;nbsp;=&lt;br&gt;
new&amp;nbsp;ExecutorCompletionService&lt;Integer&gt;(&amp;nbsp;executor&amp;nbsp;);&lt;br&gt;
completionService.submit(&amp;nbsp;callable&amp;nbsp;);&lt;br&gt;
completionService.submit(&amp;nbsp;runnable,&amp;nbsp;resultValue&amp;nbsp;);&lt;br&gt;
//&amp;nbsp;poll&amp;nbsp;for&amp;nbsp;result&lt;br&gt;
Future&lt;Integer&gt;&amp;nbsp;result&amp;nbsp;=&amp;nbsp;completionService.poll();&lt;br&gt;
if&amp;nbsp;(&amp;nbsp;result&amp;nbsp;!=&amp;nbsp;null&amp;nbsp;)&lt;br&gt;
//&amp;nbsp;use&amp;nbsp;value...&lt;br&gt;
//&amp;nbsp;block,&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;result&lt;br&gt;
Future&lt;Integer&gt;&amp;nbsp;result&amp;nbsp;=&amp;nbsp;completionService.take();&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:19" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Runnable&amp;nbsp;VS&amp;nbsp;Callable,&amp;nbsp;describe.&lt;br&gt;
What&amp;nbsp;is&amp;nbsp;Future&amp;nbsp;class&amp;nbsp;?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
The&amp;nbsp;Callable&amp;nbsp;interface&amp;nbsp;is&amp;nbsp;similar&amp;nbsp;to&amp;nbsp;Runnable,&amp;nbsp;in&amp;nbsp;that&amp;nbsp;both&amp;nbsp;are&amp;nbsp;designed&amp;nbsp;for&lt;br&gt;
classes&amp;nbsp;whose&amp;nbsp;instances&amp;nbsp;are&amp;nbsp;potentially&amp;nbsp;executed&amp;nbsp;by&amp;nbsp;another&amp;nbsp;thread.&amp;nbsp;A&amp;nbsp;Runnable,&lt;br&gt;
however,&amp;nbsp;does&amp;nbsp;not&amp;nbsp;return&amp;nbsp;a&amp;nbsp;result&amp;nbsp;and&amp;nbsp;cannot&amp;nbsp;throw&amp;nbsp;a&amp;nbsp;checked&amp;nbsp;exception.&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;interface&amp;nbsp;Callable&amp;nbsp;{&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;V&amp;nbsp;call()&amp;nbsp;throws&amp;nbsp;Exception;&amp;nbsp;&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;interface&amp;nbsp;Future&amp;nbsp;{&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;boolean&amp;nbsp;cancel(boolean&amp;nbsp;mayInterruptIfRunning);&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;boolean&amp;nbsp;isCancelled();&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;boolean&amp;nbsp;isDone();&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;V&amp;nbsp;get()&amp;nbsp;throws&amp;nbsp;InterruptedException,&amp;nbsp;ExecutionException;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;V&amp;nbsp;get(long&amp;nbsp;timeout,&amp;nbsp;TimeUnit&amp;nbsp;unit)&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;throws&amp;nbsp;InterruptedException,&amp;nbsp;ExecutionException,&amp;nbsp;TimeoutException;&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
!!!!!&lt;br&gt;
In&amp;nbsp;order&amp;nbsp;to&amp;nbsp;convert&amp;nbsp;Runnable&amp;nbsp;to&amp;nbsp;Callable&amp;nbsp;use&amp;nbsp;the&amp;nbsp;following&amp;nbsp;utility&amp;nbsp;method&amp;nbsp;provided&lt;br&gt;
by&amp;nbsp;Executors&amp;nbsp;class&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Callable&amp;nbsp;callable&amp;nbsp;=&amp;nbsp;Executors.callable(Runnable&amp;nbsp;task);&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Callable,&amp;nbsp;however&amp;nbsp;must&amp;nbsp;be&amp;nbsp;executed&amp;nbsp;using&amp;nbsp;a&amp;nbsp;ExecutorService&amp;nbsp;instead&amp;nbsp;of&amp;nbsp;Thread&lt;br&gt;
as&amp;nbsp;shown&amp;nbsp;below.&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result&amp;nbsp;=&amp;nbsp;exec.submit(aCallable).get();&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Submitting&amp;nbsp;a&amp;nbsp;callable&amp;nbsp;to&amp;nbsp;ExecutorService&amp;nbsp;returns&amp;nbsp;Future&amp;nbsp;Object&amp;nbsp;which&amp;nbsp;represents&lt;br&gt;
the&amp;nbsp;lifecycle&amp;nbsp;of&amp;nbsp;a&amp;nbsp;task&amp;nbsp;and&amp;nbsp;provides&amp;nbsp;methods&amp;nbsp;to&amp;nbsp;check&amp;nbsp;if&amp;nbsp;the&amp;nbsp;task&amp;nbsp;has&amp;nbsp;been&amp;nbsp;completed&lt;br&gt;
or&amp;nbsp;cancelled,&amp;nbsp;retrieve&amp;nbsp;the&amp;nbsp;results&amp;nbsp;and&amp;nbsp;cancel&amp;nbsp;the&amp;nbsp;task.&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
======&lt;br&gt;
The&amp;nbsp;new&amp;nbsp;Future&amp;nbsp;class&amp;nbsp;is&amp;nbsp;used&amp;nbsp;with&amp;nbsp;Callable&amp;nbsp;and&amp;nbsp;serves&amp;nbsp;as&amp;nbsp;a&amp;nbsp;handle&amp;nbsp;to&amp;nbsp;wait&lt;br&gt;
for&amp;nbsp;and&amp;nbsp;retrieve&amp;nbsp;the&amp;nbsp;result&amp;nbsp;of&amp;nbsp;the&amp;nbsp;task&amp;nbsp;or&amp;nbsp;cancel&amp;nbsp;the&amp;nbsp;task&amp;nbsp;before&amp;nbsp;it&amp;nbsp;is&amp;nbsp;executed.&lt;br&gt;
A&amp;nbsp;Future&amp;nbsp;is&amp;nbsp;returned&amp;nbsp;by&amp;nbsp;the&amp;nbsp;submit()&amp;nbsp;methods&amp;nbsp;of&amp;nbsp;an&amp;nbsp;ExecutorService,&amp;nbsp;which&amp;nbsp;is&lt;br&gt;
essentially&amp;nbsp;a&amp;nbsp;beefed-up&amp;nbsp;Executor.&amp;nbsp;We’ll&amp;nbsp;discuss&amp;nbsp;ExecutorServices&amp;nbsp;in&amp;nbsp;the&amp;nbsp;next&amp;nbsp;section.&lt;br&gt;
&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Future&lt;Integer&gt;&amp;nbsp;result&amp;nbsp;=&amp;nbsp;executorService.submit(&amp;nbsp;callable&amp;nbsp;);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;val&amp;nbsp;=&amp;nbsp;result.get();&amp;nbsp;//&amp;nbsp;blocks&amp;nbsp;until&amp;nbsp;ready&lt;br&gt;
&amp;nbsp;&lt;br&gt;
==============================================&lt;br&gt;
Examples&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;javautilconcurent.CallableAndRunnable;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Callable;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ExecutionException;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ExecutorService;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Executors;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;CallableExample&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;throws&amp;nbsp;InterruptedException,&amp;nbsp;ExecutionException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ExecutorService&amp;nbsp;pool&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(3);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;result&amp;nbsp;=&amp;nbsp;pool.submit(new&amp;nbsp;WordLengthCallable("hello")).get();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;pool.submit(new&amp;nbsp;WordLengthCallable("hello"))&amp;nbsp;&amp;nbsp;//&amp;nbsp;returns&amp;nbsp;Future&lt;Integer&gt;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(result);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pool.shutdown();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;WordLengthCallable&amp;nbsp;implements&amp;nbsp;Callable&lt;Integer&gt;&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;String&amp;nbsp;word;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;WordLengthCallable(String&amp;nbsp;word)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.word&amp;nbsp;=&amp;nbsp;word;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Integer&amp;nbsp;call()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;Integer.valueOf(word.length());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
5&lt;br&gt;
&lt;br&gt;
==============================================</questionanswer>
  </question>
  <question id="1_0_0_3_0:20" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;What&amp;nbsp;is&amp;nbsp;java.util.executors&amp;nbsp;Class&amp;nbsp;?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>Class&amp;nbsp;Executors:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;java.lang.Object&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java.util.concurrent.Executors&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Executors&amp;nbsp;class&amp;nbsp;provide&amp;nbsp;utility&amp;nbsp;methods&amp;nbsp;for&amp;nbsp;Executor,&amp;nbsp;ExecutorService,&lt;br&gt;
ScheduledExecutorService,&amp;nbsp;ThreadFactory,&amp;nbsp;and&amp;nbsp;Callable&amp;nbsp;classes.&lt;br&gt;
&lt;br&gt;
Executors&amp;nbsp;class&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;easily&amp;nbsp;create&amp;nbsp;Thread&amp;nbsp;Pool&amp;nbsp;in&amp;nbsp;java,&amp;nbsp;also&lt;br&gt;
this&amp;nbsp;is&amp;nbsp;the&amp;nbsp;only&amp;nbsp;class&amp;nbsp;supporting&amp;nbsp;execution&amp;nbsp;of&amp;nbsp;Callable&amp;nbsp;implementations.&lt;br&gt;
&lt;br&gt;
=====&lt;br&gt;
-&amp;nbsp;Factory&amp;nbsp;and&amp;nbsp;utility&amp;nbsp;methods&amp;nbsp;for&amp;nbsp;Executor,&amp;nbsp;ExecutorService,&amp;nbsp;ScheduledExecutorService,&lt;br&gt;
ThreadFactory,&amp;nbsp;and&amp;nbsp;Callable&amp;nbsp;classes&amp;nbsp;defined&amp;nbsp;in&amp;nbsp;this&amp;nbsp;package.&amp;nbsp;This&amp;nbsp;class&amp;nbsp;supports&lt;br&gt;
the&amp;nbsp;following&amp;nbsp;kinds&amp;nbsp;of&amp;nbsp;methods:&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Methods&amp;nbsp;that&amp;nbsp;create&amp;nbsp;and&amp;nbsp;return&amp;nbsp;an&amp;nbsp;ExecutorService&amp;nbsp;set&amp;nbsp;up&amp;nbsp;with&amp;nbsp;commonly&amp;nbsp;useful&lt;br&gt;
configuration&amp;nbsp;settings.&lt;br&gt;
-&amp;nbsp;Methods&amp;nbsp;that&amp;nbsp;create&amp;nbsp;and&amp;nbsp;return&amp;nbsp;a&amp;nbsp;ScheduledExecutorService&amp;nbsp;set&amp;nbsp;up&amp;nbsp;with&amp;nbsp;commonly&lt;br&gt;
useful&amp;nbsp;configuration&amp;nbsp;settings.&lt;br&gt;
-&amp;nbsp;Methods&amp;nbsp;that&amp;nbsp;create&amp;nbsp;and&amp;nbsp;return&amp;nbsp;a&amp;nbsp;"wrapped"&amp;nbsp;ExecutorService,&amp;nbsp;that&amp;nbsp;disables&amp;nbsp;reconfiguration&lt;br&gt;
by&amp;nbsp;making&amp;nbsp;implementation-specific&amp;nbsp;methods&amp;nbsp;inaccessible.&lt;br&gt;
-&amp;nbsp;Methods&amp;nbsp;that&amp;nbsp;create&amp;nbsp;and&amp;nbsp;return&amp;nbsp;a&amp;nbsp;ThreadFactory&amp;nbsp;that&amp;nbsp;sets&amp;nbsp;newly&amp;nbsp;created&amp;nbsp;threads&amp;nbsp;to&lt;br&gt;
a&amp;nbsp;known&amp;nbsp;state.&lt;br&gt;
-&amp;nbsp;Methods&amp;nbsp;that&amp;nbsp;create&amp;nbsp;and&amp;nbsp;return&amp;nbsp;a&amp;nbsp;Callable&amp;nbsp;out&amp;nbsp;of&amp;nbsp;other&amp;nbsp;closure-like&amp;nbsp;forms,&amp;nbsp;so&amp;nbsp;they&amp;nbsp;can&lt;br&gt;
be&amp;nbsp;used&amp;nbsp;in&amp;nbsp;execution&amp;nbsp;methods&amp;nbsp;requiring&amp;nbsp;Callable.&lt;br&gt;
&lt;br&gt;
=========================================&lt;br&gt;
Methods&amp;nbsp;Summary&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;Callable&lt;Object&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;callable(PrivilegedAction&lt;?&gt;&amp;nbsp;action)&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;Callable&amp;nbsp;object&amp;nbsp;that,&amp;nbsp;when&amp;nbsp;called,&amp;nbsp;runs&amp;nbsp;the&amp;nbsp;given&amp;nbsp;privileged&amp;nbsp;action&amp;nbsp;and&amp;nbsp;returns&amp;nbsp;its&amp;nbsp;result.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;Callable&lt;Object&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;callable(PrivilegedExceptionAction&lt;?&gt;&amp;nbsp;action)&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;Callable&amp;nbsp;object&amp;nbsp;that,&amp;nbsp;when&amp;nbsp;called,&amp;nbsp;runs&amp;nbsp;the&amp;nbsp;given&amp;nbsp;privileged&amp;nbsp;exception&amp;nbsp;action&amp;nbsp;and&amp;nbsp;returns&lt;br&gt;
its&amp;nbsp;result.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;Callable&lt;Object&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;callable(Runnable&amp;nbsp;task)&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;Callable&amp;nbsp;object&amp;nbsp;that,&amp;nbsp;when&amp;nbsp;called,&amp;nbsp;runs&amp;nbsp;the&amp;nbsp;given&amp;nbsp;task&amp;nbsp;and&amp;nbsp;returns&amp;nbsp;null.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;&lt;T&gt;&amp;nbsp;Callable&lt;T&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;callable(Runnable&amp;nbsp;task,&amp;nbsp;T&amp;nbsp;result)&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;Callable&amp;nbsp;object&amp;nbsp;that,&amp;nbsp;when&amp;nbsp;called,&amp;nbsp;runs&amp;nbsp;the&amp;nbsp;given&amp;nbsp;task&amp;nbsp;and&amp;nbsp;returns&amp;nbsp;the&amp;nbsp;given&amp;nbsp;result.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ThreadFactory&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;defaultThreadFactory()&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;default&amp;nbsp;thread&amp;nbsp;factory&amp;nbsp;used&amp;nbsp;to&amp;nbsp;create&amp;nbsp;new&amp;nbsp;threads.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newCachedThreadPool()&lt;br&gt;
Creates&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;that&amp;nbsp;creates&amp;nbsp;new&amp;nbsp;threads&amp;nbsp;as&amp;nbsp;needed,&amp;nbsp;but&amp;nbsp;will&amp;nbsp;reuse&amp;nbsp;previously&amp;nbsp;constructed&lt;br&gt;
threads&amp;nbsp;when&amp;nbsp;they&amp;nbsp;are&amp;nbsp;available.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newCachedThreadPool(ThreadFactory&amp;nbsp;threadFactory)&lt;br&gt;
Creates&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;that&amp;nbsp;creates&amp;nbsp;new&amp;nbsp;threads&amp;nbsp;as&amp;nbsp;needed,&amp;nbsp;but&amp;nbsp;will&amp;nbsp;reuse&amp;nbsp;previously&amp;nbsp;constructed&lt;br&gt;
threads&amp;nbsp;when&amp;nbsp;they&amp;nbsp;are&amp;nbsp;available,&amp;nbsp;and&amp;nbsp;uses&amp;nbsp;the&amp;nbsp;provided&amp;nbsp;ThreadFactory&amp;nbsp;to&amp;nbsp;create&amp;nbsp;new&amp;nbsp;threads&amp;nbsp;when&amp;nbsp;needed.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newFixedThreadPool(int&amp;nbsp;nThreads)&lt;br&gt;
Creates&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;that&amp;nbsp;reuses&amp;nbsp;a&amp;nbsp;fixed&amp;nbsp;number&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;operating&amp;nbsp;off&amp;nbsp;a&amp;nbsp;shared&amp;nbsp;unbounded&amp;nbsp;queue.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newFixedThreadPool(int&amp;nbsp;nThreads,&amp;nbsp;ThreadFactory&amp;nbsp;threadFactory)&lt;br&gt;
Creates&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;that&amp;nbsp;reuses&amp;nbsp;a&amp;nbsp;fixed&amp;nbsp;number&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;operating&amp;nbsp;off&amp;nbsp;a&amp;nbsp;shared&amp;nbsp;unbounded&amp;nbsp;queue,&lt;br&gt;
using&amp;nbsp;the&amp;nbsp;provided&amp;nbsp;ThreadFactory&amp;nbsp;to&amp;nbsp;create&amp;nbsp;new&amp;nbsp;threads&amp;nbsp;when&amp;nbsp;needed.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ScheduledExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newScheduledThreadPool(int&amp;nbsp;corePoolSize)&lt;br&gt;
Creates&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;that&amp;nbsp;can&amp;nbsp;schedule&amp;nbsp;commands&amp;nbsp;to&amp;nbsp;run&amp;nbsp;after&amp;nbsp;a&amp;nbsp;given&amp;nbsp;delay,&amp;nbsp;or&amp;nbsp;to&amp;nbsp;execute&amp;nbsp;periodically.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ScheduledExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newScheduledThreadPool(int&amp;nbsp;corePoolSize,&amp;nbsp;ThreadFactory&amp;nbsp;threadFactory)&lt;br&gt;
Creates&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;pool&amp;nbsp;that&amp;nbsp;can&amp;nbsp;schedule&amp;nbsp;commands&amp;nbsp;to&amp;nbsp;run&amp;nbsp;after&amp;nbsp;a&amp;nbsp;given&amp;nbsp;delay,&amp;nbsp;or&amp;nbsp;to&amp;nbsp;execute&amp;nbsp;periodically.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newSingleThreadExecutor()&lt;br&gt;
Creates&amp;nbsp;an&amp;nbsp;Executor&amp;nbsp;that&amp;nbsp;uses&amp;nbsp;a&amp;nbsp;single&amp;nbsp;worker&amp;nbsp;thread&amp;nbsp;operating&amp;nbsp;off&amp;nbsp;an&amp;nbsp;unbounded&amp;nbsp;queue.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newSingleThreadExecutor(ThreadFactory&amp;nbsp;threadFactory)&lt;br&gt;
Creates&amp;nbsp;an&amp;nbsp;Executor&amp;nbsp;that&amp;nbsp;uses&amp;nbsp;a&amp;nbsp;single&amp;nbsp;worker&amp;nbsp;thread&amp;nbsp;operating&amp;nbsp;off&amp;nbsp;an&amp;nbsp;unbounded&amp;nbsp;queue,&amp;nbsp;and&amp;nbsp;uses&amp;nbsp;the&lt;br&gt;
provided&amp;nbsp;ThreadFactory&amp;nbsp;to&amp;nbsp;create&amp;nbsp;a&amp;nbsp;new&amp;nbsp;thread&amp;nbsp;when&amp;nbsp;needed.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ScheduledExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newSingleThreadScheduledExecutor()&lt;br&gt;
Creates&amp;nbsp;a&amp;nbsp;single-threaded&amp;nbsp;executor&amp;nbsp;that&amp;nbsp;can&amp;nbsp;schedule&amp;nbsp;commands&amp;nbsp;to&amp;nbsp;run&amp;nbsp;after&amp;nbsp;a&amp;nbsp;given&amp;nbsp;delay,&amp;nbsp;or&amp;nbsp;to&amp;nbsp;execute&amp;nbsp;periodically.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ScheduledExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newSingleThreadScheduledExecutor(ThreadFactory&amp;nbsp;threadFactory)&lt;br&gt;
Creates&amp;nbsp;a&amp;nbsp;single-threaded&amp;nbsp;executor&amp;nbsp;that&amp;nbsp;can&amp;nbsp;schedule&amp;nbsp;commands&amp;nbsp;to&amp;nbsp;run&amp;nbsp;after&amp;nbsp;a&amp;nbsp;given&amp;nbsp;delay,&amp;nbsp;or&amp;nbsp;to&amp;nbsp;execute&lt;br&gt;
periodically.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;&lt;T&gt;&amp;nbsp;Callable&lt;T&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;privilegedCallable(Callable&lt;T&gt;&amp;nbsp;callable)&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;Callable&amp;nbsp;object&amp;nbsp;that&amp;nbsp;will,&amp;nbsp;when&amp;nbsp;called,&amp;nbsp;execute&amp;nbsp;the&amp;nbsp;given&amp;nbsp;callable&amp;nbsp;under&amp;nbsp;the&amp;nbsp;current&amp;nbsp;access&amp;nbsp;control&amp;nbsp;context.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;&lt;T&gt;&amp;nbsp;Callable&lt;T&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt;&amp;nbsp;callable)&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;Callable&amp;nbsp;object&amp;nbsp;that&amp;nbsp;will,&amp;nbsp;when&amp;nbsp;called,&amp;nbsp;execute&amp;nbsp;the&amp;nbsp;given&amp;nbsp;callable&amp;nbsp;under&amp;nbsp;the&amp;nbsp;current&amp;nbsp;access&amp;nbsp;control&lt;br&gt;
context,&amp;nbsp;with&amp;nbsp;the&amp;nbsp;current&amp;nbsp;context&amp;nbsp;class&amp;nbsp;loader&amp;nbsp;as&amp;nbsp;the&amp;nbsp;context&amp;nbsp;class&amp;nbsp;loader.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ThreadFactory&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;privilegedThreadFactory()&lt;br&gt;
Returns&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;factory&amp;nbsp;used&amp;nbsp;to&amp;nbsp;create&amp;nbsp;new&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;have&amp;nbsp;the&amp;nbsp;same&amp;nbsp;permissions&amp;nbsp;as&amp;nbsp;the&lt;br&gt;
current&amp;nbsp;thread.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;unconfigurableExecutorService(ExecutorService&amp;nbsp;executor)&lt;br&gt;
Returns&amp;nbsp;an&amp;nbsp;object&amp;nbsp;that&amp;nbsp;delegates&amp;nbsp;all&amp;nbsp;defined&amp;nbsp;ExecutorService&amp;nbsp;methods&amp;nbsp;to&amp;nbsp;the&amp;nbsp;given&amp;nbsp;executor,&lt;br&gt;
but&amp;nbsp;not&amp;nbsp;any&amp;nbsp;other&amp;nbsp;methods&amp;nbsp;that&amp;nbsp;might&amp;nbsp;otherwise&amp;nbsp;be&amp;nbsp;accessible&amp;nbsp;using&amp;nbsp;casts.&lt;br&gt;
-&amp;nbsp;static&amp;nbsp;ScheduledExecutorService&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;unconfigurableScheduledExecutorService(ScheduledExecutorService&amp;nbsp;executor)&lt;br&gt;
Returns&amp;nbsp;an&amp;nbsp;object&amp;nbsp;that&amp;nbsp;delegates&amp;nbsp;all&amp;nbsp;defined&amp;nbsp;ScheduledExecutorService&amp;nbsp;methods&amp;nbsp;to&amp;nbsp;the&amp;nbsp;given&lt;br&gt;
executor,&amp;nbsp;but&amp;nbsp;not&amp;nbsp;any&amp;nbsp;other&amp;nbsp;methods&amp;nbsp;that&amp;nbsp;might&amp;nbsp;otherwise&amp;nbsp;be&amp;nbsp;accessible&amp;nbsp;using&amp;nbsp;casts.</questionanswer>
  </question>
  <question id="1_0_0_3_0:21" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;What&amp;nbsp;is&amp;nbsp;FutureTask&amp;nbsp;Class?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
FutureTask&amp;nbsp;is&amp;nbsp;the&amp;nbsp;base&amp;nbsp;implementation&amp;nbsp;class&amp;nbsp;of&amp;nbsp;Future&amp;nbsp;interface&amp;nbsp;and&lt;br&gt;
we&amp;nbsp;can&amp;nbsp;use&amp;nbsp;it&amp;nbsp;with&amp;nbsp;Executors&amp;nbsp;for&amp;nbsp;__&amp;nbsp;asynchronous&amp;nbsp;processing&amp;nbsp;__.&amp;nbsp;&lt;br&gt;
&lt;br&gt;
As&amp;nbsp;such&amp;nbsp;there&amp;nbsp;is&amp;nbsp;no&amp;nbsp;benefit&amp;nbsp;of&amp;nbsp;FutureTask&amp;nbsp;but&amp;nbsp;it&amp;nbsp;comes&amp;nbsp;handy&amp;nbsp;when&amp;nbsp;we&amp;nbsp;want&amp;nbsp;to&lt;br&gt;
override&amp;nbsp;some&amp;nbsp;of&amp;nbsp;Future&amp;nbsp;interface&amp;nbsp;methods&amp;nbsp;and&amp;nbsp;don’t&amp;nbsp;want&amp;nbsp;to&amp;nbsp;implement&amp;nbsp;every&amp;nbsp;method&lt;br&gt;
of&amp;nbsp;Future&amp;nbsp;interface.&lt;br&gt;
&lt;br&gt;
Most&amp;nbsp;of&amp;nbsp;the&amp;nbsp;time&amp;nbsp;we&amp;nbsp;don’t&amp;nbsp;need&amp;nbsp;to&amp;nbsp;use&amp;nbsp;FutureTask&amp;nbsp;class&amp;nbsp;but&amp;nbsp;it&amp;nbsp;comes&amp;nbsp;real&lt;br&gt;
handy&amp;nbsp;if&amp;nbsp;we&amp;nbsp;want&amp;nbsp;to&amp;nbsp;override&amp;nbsp;some&amp;nbsp;of&amp;nbsp;the&amp;nbsp;methods&amp;nbsp;of&amp;nbsp;Future&amp;nbsp;interface&amp;nbsp;and&lt;br&gt;
want&amp;nbsp;to&amp;nbsp;keep&amp;nbsp;most&amp;nbsp;of&amp;nbsp;the&amp;nbsp;base&amp;nbsp;implementation.&amp;nbsp;We&amp;nbsp;can&amp;nbsp;just&amp;nbsp;extend&amp;nbsp;this&lt;br&gt;
class&amp;nbsp;and&amp;nbsp;override&amp;nbsp;the&amp;nbsp;methods&amp;nbsp;according&amp;nbsp;to&amp;nbsp;our&amp;nbsp;requirements.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;following&amp;nbsp;example&amp;nbsp;illustrates&amp;nbsp;the&amp;nbsp;use&amp;nbsp;of&amp;nbsp;the&amp;nbsp;Futuretask&amp;nbsp;together&amp;nbsp;with&lt;br&gt;
the&amp;nbsp;Callable.&lt;br&gt;
It&amp;nbsp;reverses&amp;nbsp;the&amp;nbsp;submitted&amp;nbsp;string&amp;nbsp;slowly&amp;nbsp;at&amp;nbsp;a&amp;nbsp;rate&amp;nbsp;of&amp;nbsp;one&amp;nbsp;char&amp;nbsp;per&amp;nbsp;second.&lt;br&gt;
In&amp;nbsp;the&amp;nbsp;mean&amp;nbsp;time,&amp;nbsp;the&amp;nbsp;main&amp;nbsp;thread&amp;nbsp;keeps&amp;nbsp;polling&amp;nbsp;to&amp;nbsp;see&amp;nbsp;if&amp;nbsp;the&amp;nbsp;task&amp;nbsp;is&amp;nbsp;completed.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Example&amp;nbsp;:&lt;br&gt;
package&amp;nbsp;futuretaskclass;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Callable;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ExecutionException;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ExecutorService;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Executors;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.FutureTask;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;FutureTaskClassHelloWorld&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ExecutorService&amp;nbsp;executor&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(1);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;SlowStringReverser&amp;nbsp;reverser&amp;nbsp;=&amp;nbsp;new&amp;nbsp;SlowStringReverser();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;String&amp;nbsp;target&amp;nbsp;=&amp;nbsp;"hell";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;FutureTask&lt;String&gt;&amp;nbsp;future&amp;nbsp;=&amp;nbsp;new&amp;nbsp;FutureTask&lt;String&gt;(new&amp;nbsp;Callable&lt;String&gt;()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;String&amp;nbsp;call()&amp;nbsp;throws&amp;nbsp;Exception&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String&amp;nbsp;result&amp;nbsp;=&amp;nbsp;reverser.reverseString(target);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(".....");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;result;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.execute(future);&amp;nbsp;//&amp;nbsp;doesn't&amp;nbsp;block&amp;nbsp;main&amp;nbsp;THREAD&amp;nbsp;!!!!!!!!!!!!!!!!!&amp;nbsp;!!!!&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.shutdown();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while&amp;nbsp;(!future.isDone())&amp;nbsp;{&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;BLOCK&amp;nbsp;main&amp;nbsp;thread&amp;nbsp;,&amp;nbsp;and&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;result&amp;nbsp;!&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;Play&amp;nbsp;framework&amp;nbsp;has&amp;nbsp;'await'&amp;nbsp;method&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Result&amp;nbsp;"&amp;nbsp;+&amp;nbsp;future.get());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(ExecutionException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("end&amp;nbsp;of&amp;nbsp;main");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;SlowStringReverser&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;StringBuffer&amp;nbsp;orgString;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;StringBuffer&amp;nbsp;reversedString;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SlowStringReverser(String&amp;nbsp;orgStr)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;orgString&amp;nbsp;=&amp;nbsp;new&amp;nbsp;StringBuffer(orgStr);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SlowStringReverser()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;String&amp;nbsp;reverseString(String&amp;nbsp;str)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;orgString&amp;nbsp;=&amp;nbsp;new&amp;nbsp;StringBuffer(str);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reversedString&amp;nbsp;=&amp;nbsp;new&amp;nbsp;StringBuffer();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;(orgString.length()&amp;nbsp;-&amp;nbsp;1);&amp;nbsp;i&amp;nbsp;&gt;=&amp;nbsp;0;&amp;nbsp;i--)&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reversedString.append(orgString.charAt(i));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;ie)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;reversedString.toString();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Result&amp;nbsp;lleh&lt;br&gt;
end&amp;nbsp;of&amp;nbsp;main&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
========================================================&lt;br&gt;
Notice&amp;nbsp;:&lt;br&gt;
As&amp;nbsp;such&amp;nbsp;there&amp;nbsp;is&amp;nbsp;no&amp;nbsp;benefit&amp;nbsp;of&amp;nbsp;FutureTask&amp;nbsp;but&amp;nbsp;it&amp;nbsp;comes&amp;nbsp;handy&amp;nbsp;when&amp;nbsp;we&amp;nbsp;want&amp;nbsp;to&lt;br&gt;
override&amp;nbsp;some&amp;nbsp;of&amp;nbsp;Future&amp;nbsp;interface&amp;nbsp;methods&amp;nbsp;and&amp;nbsp;don’t&amp;nbsp;want&amp;nbsp;to&amp;nbsp;implement&amp;nbsp;every&amp;nbsp;method&lt;br&gt;
of&amp;nbsp;Future&amp;nbsp;interface.&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:22" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Fork&amp;nbsp;Join,&amp;nbsp;describe.&amp;nbsp;Provide&amp;nbsp;example.&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>Fork&amp;nbsp;Join&amp;nbsp;Classes:&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='670'&amp;nbsp;height='640'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ForkJoin1.png'/&gt;&lt;br&gt;
ForkJoin&amp;nbsp;framework&amp;nbsp;main&amp;nbsp;classes&amp;nbsp;:&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='670'&amp;nbsp;height='270'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ForkJoin2.png'/&gt;&lt;br&gt;
======&lt;br&gt;
&lt;br&gt;
So&amp;nbsp;far&amp;nbsp;we’ve&amp;nbsp;seen&amp;nbsp;how&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;concurrency&amp;nbsp;utilities&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;manage&lt;br&gt;
simple&amp;nbsp;parallel&amp;nbsp;programming&amp;nbsp;scenarios.&amp;nbsp;We’ve&amp;nbsp;seen&amp;nbsp;that&amp;nbsp;we&amp;nbsp;can&amp;nbsp;submit&amp;nbsp;many&lt;br&gt;
tasks&amp;nbsp;to&amp;nbsp;an&amp;nbsp;ExecutorService&amp;nbsp;and&amp;nbsp;collect&amp;nbsp;result&amp;nbsp;values&amp;nbsp;if&amp;nbsp;needed&amp;nbsp;through&amp;nbsp;Futures.&lt;br&gt;
&lt;br&gt;
We’ve&amp;nbsp;seen&amp;nbsp;that&amp;nbsp;we&amp;nbsp;can&amp;nbsp;schedule&amp;nbsp;tasks&amp;nbsp;to&amp;nbsp;run&amp;nbsp;at&amp;nbsp;specified&amp;nbsp;times&amp;nbsp;and&amp;nbsp;with&lt;br&gt;
specified&amp;nbsp;frequencies.&lt;br&gt;
&lt;br&gt;
We’ve&amp;nbsp;seen&amp;nbsp;that&amp;nbsp;we&amp;nbsp;can&amp;nbsp;delve&amp;nbsp;into&amp;nbsp;the&amp;nbsp;details&amp;nbsp;of&amp;nbsp;the&amp;nbsp;pooling&amp;nbsp;and&amp;nbsp;control&amp;nbsp;the&lt;br&gt;
degree&amp;nbsp;of&amp;nbsp;parallelism&amp;nbsp;(how&amp;nbsp;many&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;used)&amp;nbsp;if&amp;nbsp;we&amp;nbsp;wish.&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;this&amp;nbsp;section,&amp;nbsp;we’ll&amp;nbsp;look&amp;nbsp;at&amp;nbsp;an&amp;nbsp;API&amp;nbsp;that&amp;nbsp;helps&amp;nbsp;you&amp;nbsp;coordinate&amp;nbsp;tasks&amp;nbsp;in&amp;nbsp;another&lt;br&gt;
way—by&amp;nbsp;helping&amp;nbsp;you&amp;nbsp;take&amp;nbsp;“scaleable”&amp;nbsp;tasks&amp;nbsp;and&amp;nbsp;divide&amp;nbsp;them&amp;nbsp;up&amp;nbsp;to&amp;nbsp;match&amp;nbsp;the&lt;br&gt;
processing&amp;nbsp;power&amp;nbsp;available&amp;nbsp;at&amp;nbsp;any&amp;nbsp;given&amp;nbsp;time.&lt;br&gt;
&lt;br&gt;
Let’s&amp;nbsp;imagine&amp;nbsp;that&amp;nbsp;you&amp;nbsp;have&amp;nbsp;a&amp;nbsp;task&amp;nbsp;that&amp;nbsp;performs&amp;nbsp;a&amp;nbsp;complex&amp;nbsp;computation&amp;nbsp;like&lt;br&gt;
rendering&amp;nbsp;video&amp;nbsp;or&amp;nbsp;generating&amp;nbsp;a&amp;nbsp;complicated&amp;nbsp;image.&amp;nbsp;A&amp;nbsp;natural&amp;nbsp;place&amp;nbsp;to&amp;nbsp;start&amp;nbsp;in&lt;br&gt;
parallizing&amp;nbsp;it&amp;nbsp;would&amp;nbsp;be&amp;nbsp;to&amp;nbsp;__&amp;nbsp;divide&amp;nbsp;__&amp;nbsp;the&amp;nbsp;work&amp;nbsp;for&amp;nbsp;one&amp;nbsp;frame&amp;nbsp;or&amp;nbsp;image&amp;nbsp;into&amp;nbsp;a&amp;nbsp;fixed&amp;nbsp;number&lt;br&gt;
of&amp;nbsp;parts&amp;nbsp;and&amp;nbsp;feed&amp;nbsp;them&amp;nbsp;to&amp;nbsp;an&amp;nbsp;executor&amp;nbsp;service.&amp;nbsp;The&amp;nbsp;executor&amp;nbsp;service&amp;nbsp;would&amp;nbsp;be&amp;nbsp;tuned&lt;br&gt;
to&amp;nbsp;have&amp;nbsp;as&amp;nbsp;many&amp;nbsp;threads&amp;nbsp;as&amp;nbsp;you&amp;nbsp;wish&amp;nbsp;to&amp;nbsp;use&amp;nbsp;(perhaps&amp;nbsp;the&amp;nbsp;same&amp;nbsp;number&amp;nbsp;as&amp;nbsp;the&lt;br&gt;
number&amp;nbsp;of&amp;nbsp;CPUs&amp;nbsp;or&amp;nbsp;“cores”&amp;nbsp;on&amp;nbsp;your&amp;nbsp;machine)&amp;nbsp;and&amp;nbsp;would&amp;nbsp;assign&amp;nbsp;each&amp;nbsp;part&amp;nbsp;to&amp;nbsp;its&lt;br&gt;
own&amp;nbsp;thread.&lt;br&gt;
We’d&amp;nbsp;expect&amp;nbsp;that&amp;nbsp;each&amp;nbsp;part&amp;nbsp;of&amp;nbsp;the&amp;nbsp;image&amp;nbsp;would&amp;nbsp;be&amp;nbsp;finished&amp;nbsp;at&amp;nbsp;about&amp;nbsp;the&amp;nbsp;same&amp;nbsp;time&lt;br&gt;
and&amp;nbsp;we’ll&amp;nbsp;be&amp;nbsp;able&amp;nbsp;to&amp;nbsp;stitch&amp;nbsp;them&amp;nbsp;all&amp;nbsp;together&amp;nbsp;effectively.&amp;nbsp;But&amp;nbsp;what&amp;nbsp;if&amp;nbsp;some&amp;nbsp;parts&amp;nbsp;of&lt;br&gt;
the&amp;nbsp;image&amp;nbsp;are&amp;nbsp;dramatically&amp;nbsp;harder&amp;nbsp;to&amp;nbsp;render&amp;nbsp;than&amp;nbsp;other&amp;nbsp;parts?&amp;nbsp;What&amp;nbsp;if&amp;nbsp;one&amp;nbsp;chunk&lt;br&gt;
takes&amp;nbsp;ten&amp;nbsp;or&amp;nbsp;a&amp;nbsp;hundred&amp;nbsp;or&amp;nbsp;a&amp;nbsp;thousand&amp;nbsp;times&amp;nbsp;as&amp;nbsp;much&amp;nbsp;CPU&amp;nbsp;power&amp;nbsp;as&amp;nbsp;another?&lt;br&gt;
Then&amp;nbsp;we&amp;nbsp;may&amp;nbsp;find&amp;nbsp;ourselves&amp;nbsp;in&amp;nbsp;a&amp;nbsp;situation&amp;nbsp;where&amp;nbsp;many&amp;nbsp;of&amp;nbsp;the&amp;nbsp;threads&amp;nbsp;sit&amp;nbsp;idle,&amp;nbsp;while&lt;br&gt;
a&amp;nbsp;few&amp;nbsp;threads&amp;nbsp;churn&amp;nbsp;away&amp;nbsp;doing&amp;nbsp;all&amp;nbsp;of&amp;nbsp;the&amp;nbsp;hard&amp;nbsp;work.&amp;nbsp;What&amp;nbsp;can&amp;nbsp;we&amp;nbsp;do&amp;nbsp;to&amp;nbsp;address&amp;nbsp;this?&lt;br&gt;
&lt;br&gt;
Well,&amp;nbsp;one&amp;nbsp;approach&amp;nbsp;would&amp;nbsp;be&amp;nbsp;to&amp;nbsp;simply&amp;nbsp;make&amp;nbsp;our&amp;nbsp;tasks&amp;nbsp;more&amp;nbsp;finely&amp;nbsp;grained.&lt;br&gt;
We&amp;nbsp;could&amp;nbsp;make&amp;nbsp;our&amp;nbsp;individual&amp;nbsp;jobs&amp;nbsp;so&amp;nbsp;small&amp;nbsp;that&amp;nbsp;no&amp;nbsp;single&amp;nbsp;one&amp;nbsp;could&amp;nbsp;possibly&amp;nbsp;monopolize&lt;br&gt;
a&amp;nbsp;thread&amp;nbsp;for&amp;nbsp;long.&amp;nbsp;However,&amp;nbsp;when&amp;nbsp;tasks&amp;nbsp;can&amp;nbsp;vary&amp;nbsp;in&amp;nbsp;degree&amp;nbsp;of&amp;nbsp;difficulty&amp;nbsp;by&amp;nbsp;many&amp;nbsp;orders&lt;br&gt;
of&amp;nbsp;magnitude,&amp;nbsp;this&amp;nbsp;could&amp;nbsp;lead&amp;nbsp;to&amp;nbsp;creating&amp;nbsp;a&amp;nbsp;very&amp;nbsp;large&amp;nbsp;number&amp;nbsp;of&amp;nbsp;tiny&amp;nbsp;tasks&amp;nbsp;and&amp;nbsp;would&lt;br&gt;
probably&amp;nbsp;be&amp;nbsp;very&amp;nbsp;inefficient,&amp;nbsp;with&amp;nbsp;threads&amp;nbsp;switching&amp;nbsp;jobs&amp;nbsp;and,&amp;nbsp;even&amp;nbsp;worse,&amp;nbsp;moving&amp;nbsp;data&lt;br&gt;
around&amp;nbsp;to&amp;nbsp;accommodate&amp;nbsp;the&amp;nbsp;somewhat&amp;nbsp;random&amp;nbsp;order&amp;nbsp;in&amp;nbsp;which&amp;nbsp;they&amp;nbsp;would&amp;nbsp;service&lt;br&gt;
the&amp;nbsp;work&amp;nbsp;requests.&amp;nbsp;What&amp;nbsp;is&amp;nbsp;needed&amp;nbsp;is&amp;nbsp;a&amp;nbsp;way&amp;nbsp;for&amp;nbsp;each&amp;nbsp;task&amp;nbsp;to&amp;nbsp;keep&amp;nbsp;itself&amp;nbsp;busy,&amp;nbsp;but&amp;nbsp;allow&lt;br&gt;
other&amp;nbsp;tasks&amp;nbsp;to&amp;nbsp;help&amp;nbsp;when&amp;nbsp;they&amp;nbsp;get&amp;nbsp;overloaded.&amp;nbsp;Ideally,&amp;nbsp;we’d&amp;nbsp;also&amp;nbsp;like&amp;nbsp;to&amp;nbsp;minimize&lt;br&gt;
discontinuities&amp;nbsp;in&amp;nbsp;the&amp;nbsp;workflow&amp;nbsp;and&amp;nbsp;for&amp;nbsp;data-intensive&amp;nbsp;tasks,&amp;nbsp;to&amp;nbsp;avoid&amp;nbsp;giving&amp;nbsp;threads&amp;nbsp;jobs&lt;br&gt;
that&amp;nbsp;require&amp;nbsp;completely&amp;nbsp;new&amp;nbsp;data&amp;nbsp;to&amp;nbsp;be&amp;nbsp;loaded&amp;nbsp;at&amp;nbsp;each&amp;nbsp;turn.&lt;br&gt;
&lt;br&gt;
==&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;Fork/Join&amp;nbsp;framework&amp;nbsp;is&amp;nbsp;a&amp;nbsp;new&amp;nbsp;API&amp;nbsp;added&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;7&amp;nbsp;that&amp;nbsp;provides&amp;nbsp;just&amp;nbsp;_&amp;nbsp;this—a&amp;nbsp;way&lt;br&gt;
for&amp;nbsp;you&amp;nbsp;to&amp;nbsp;structure&amp;nbsp;your&amp;nbsp;tasks&amp;nbsp;so&amp;nbsp;that&amp;nbsp;they&amp;nbsp;can&amp;nbsp;be&amp;nbsp;split&amp;nbsp;up&amp;nbsp;as&amp;nbsp;needed&amp;nbsp;to&amp;nbsp;keep&amp;nbsp;all&amp;nbsp;of&amp;nbsp;the&lt;br&gt;
available&amp;nbsp;threads&amp;nbsp;busy&amp;nbsp;working&amp;nbsp;on&amp;nbsp;data&amp;nbsp;with&amp;nbsp;as&amp;nbsp;much&amp;nbsp;continuity&amp;nbsp;as&amp;nbsp;possible.&lt;br&gt;
&lt;br&gt;
Specifically,&lt;br&gt;
the&amp;nbsp;Fork/Join&amp;nbsp;framework&amp;nbsp;relies&amp;nbsp;on&amp;nbsp;tasks&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;split&amp;nbsp;up&amp;nbsp;recursively&amp;nbsp;(i.e.,&amp;nbsp;divided&amp;nbsp;in&lt;br&gt;
two&amp;nbsp;or&amp;nbsp;more&amp;nbsp;parts,&amp;nbsp;with&amp;nbsp;those&amp;nbsp;parts&amp;nbsp;then&amp;nbsp;subdivided&amp;nbsp;if&amp;nbsp;needed,&amp;nbsp;and&amp;nbsp;so&amp;nbsp;on).&amp;nbsp;When&amp;nbsp;a&amp;nbsp;task&lt;br&gt;
is&amp;nbsp;deemed&amp;nbsp;too&amp;nbsp;large&amp;nbsp;to&amp;nbsp;be&amp;nbsp;completed&amp;nbsp;quickly,&amp;nbsp;the&amp;nbsp;task&amp;nbsp;is&amp;nbsp;simply&amp;nbsp;split&amp;nbsp;up&amp;nbsp;and&amp;nbsp;the&amp;nbsp;(now&lt;br&gt;
smaller)&amp;nbsp;pieces&amp;nbsp;are&amp;nbsp;placed&amp;nbsp;into&amp;nbsp;a&amp;nbsp;queue&amp;nbsp;for&amp;nbsp;the&amp;nbsp;current&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;framework&amp;nbsp;then&lt;br&gt;
implements&amp;nbsp;what&amp;nbsp;is&amp;nbsp;known&amp;nbsp;as&amp;nbsp;a&amp;nbsp;_&amp;nbsp;“work&amp;nbsp;stealing”&amp;nbsp;_&amp;nbsp;algorithm,&amp;nbsp;allowing&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;are&lt;br&gt;
free&amp;nbsp;to&amp;nbsp;grab&amp;nbsp;unstarted&amp;nbsp;tasks&amp;nbsp;from&amp;nbsp;their&amp;nbsp;neighbors’&amp;nbsp;queues.&amp;nbsp;The&amp;nbsp;combination&amp;nbsp;of&amp;nbsp;these&lt;br&gt;
techniques&amp;nbsp;has&amp;nbsp;some&amp;nbsp;powerful&amp;nbsp;advantages.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
==&lt;br&gt;
Example&amp;nbsp;:&amp;nbsp;Matrix&amp;nbsp;multiplying&amp;nbsp;using&amp;nbsp;ForkJoin&lt;br&gt;
package&amp;nbsp;javautilconcurent.forkjoin;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.ArrayList;&lt;br&gt;
import&amp;nbsp;java.util.List;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ForkJoinPool;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.RecursiveAction;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;MatrixMultiplyingForkJoin&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;Matrix&amp;nbsp;multiplying&amp;nbsp;without&amp;nbsp;Fork&amp;nbsp;Join&amp;nbsp;Framework&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix&amp;nbsp;a&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Matrix(2,&amp;nbsp;2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a.setValues("1,2;3,4");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix&amp;nbsp;b&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Matrix(2,&amp;nbsp;3);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.setValues("1,1,1;2,2,2");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Matrix.multiply(a,&amp;nbsp;b));&amp;nbsp;//&amp;nbsp;Result&amp;nbsp;:&amp;nbsp;5,5,5;11,11,11&lt;br&gt;
*/&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ForkJoinPool&amp;nbsp;pool&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ForkJoinPool();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix&amp;nbsp;a&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Matrix(2,&amp;nbsp;2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a.setValues("1,2;3,4");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix&amp;nbsp;b&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Matrix(2,&amp;nbsp;3);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.setValues("1,1,1;2,2,2");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix&amp;nbsp;c&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Matrix(a.getRows(),&amp;nbsp;b.getCols());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pool.invoke(new&amp;nbsp;MatMult(a,&amp;nbsp;b,&amp;nbsp;c));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(c);&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
//ForkJoin&amp;nbsp;Class&lt;br&gt;
class&amp;nbsp;MatMult&amp;nbsp;extends&amp;nbsp;RecursiveAction{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;Matrix&amp;nbsp;a,&amp;nbsp;b,&amp;nbsp;c;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;int&amp;nbsp;row;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MatMult(Matrix&amp;nbsp;a,&amp;nbsp;Matrix&amp;nbsp;b,&amp;nbsp;Matrix&amp;nbsp;c)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this(a,&amp;nbsp;b,&amp;nbsp;c,&amp;nbsp;-1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MatMult(Matrix&amp;nbsp;a,&amp;nbsp;Matrix&amp;nbsp;b,&amp;nbsp;Matrix&amp;nbsp;c,&amp;nbsp;int&amp;nbsp;row)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(a.getCols()&amp;nbsp;!=&amp;nbsp;b.getRows())&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw&amp;nbsp;new&amp;nbsp;IllegalArgumentException("rows/columns&amp;nbsp;mismatch");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.a&amp;nbsp;=&amp;nbsp;a;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.b&amp;nbsp;=&amp;nbsp;b;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.c&amp;nbsp;=&amp;nbsp;c;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.row&amp;nbsp;=&amp;nbsp;row;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;protected&amp;nbsp;void&amp;nbsp;compute()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(row&amp;nbsp;==&amp;nbsp;-1){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List&lt;MatMult&gt;&amp;nbsp;tasks&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ArrayList&lt;&gt;();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;row&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;row&amp;nbsp;&lt;&amp;nbsp;a.getRows();&amp;nbsp;row++)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tasks.add(new&amp;nbsp;MatMult(a,&amp;nbsp;b,&amp;nbsp;c,&amp;nbsp;row));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;invokeAll(tasks);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}else&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;multiplyRowByColumn(a,&amp;nbsp;b,&amp;nbsp;c,&amp;nbsp;row);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;void&amp;nbsp;multiplyRowByColumn(Matrix&amp;nbsp;a,&amp;nbsp;Matrix&amp;nbsp;b,&amp;nbsp;Matrix&amp;nbsp;c,&amp;nbsp;int&amp;nbsp;row)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;j&amp;nbsp;&lt;&amp;nbsp;b.getCols();&amp;nbsp;j++)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;k&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;k&amp;nbsp;&lt;&amp;nbsp;a.getCols();&amp;nbsp;k++)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c.setValue(row,j,c.getValue(row,&amp;nbsp;j)&amp;nbsp;+&amp;nbsp;a.getValue(row,&amp;nbsp;k)&amp;nbsp;*&amp;nbsp;b.getValue(k,&amp;nbsp;j));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Matrix&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;double[][]&amp;nbsp;matrix;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix(int&amp;nbsp;nrows,&amp;nbsp;int&amp;nbsp;ncols)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;matrix&amp;nbsp;=&amp;nbsp;new&amp;nbsp;double[nrows][ncols];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;getCols()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;matrix[0].length;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;getRows()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;matrix.length;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double&amp;nbsp;getValue(int&amp;nbsp;row,&amp;nbsp;int&amp;nbsp;col)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;matrix[row][col];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void&amp;nbsp;setValue(int&amp;nbsp;row,&amp;nbsp;int&amp;nbsp;col,&amp;nbsp;double&amp;nbsp;value)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;matrix[row][col]&amp;nbsp;=&amp;nbsp;value;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void&amp;nbsp;setValues(String&amp;nbsp;val)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val&amp;nbsp;=&amp;nbsp;val.replaceAll("&amp;nbsp;",&amp;nbsp;"");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String[]&amp;nbsp;rows&amp;nbsp;=&amp;nbsp;val.split(";");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double[][]&amp;nbsp;mas&amp;nbsp;=&amp;nbsp;new&amp;nbsp;double[rows.length][rows[0].split(",").length];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;rows.length;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String[]&amp;nbsp;columns&amp;nbsp;=&amp;nbsp;rows[i].split(",");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for(int&amp;nbsp;j=0;j&lt;columns.length;j++){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mas[i][j]&amp;nbsp;=&amp;nbsp;Double.parseDouble(columns[j]);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.matrix&amp;nbsp;=&amp;nbsp;mas;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;String&amp;nbsp;toString()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String&amp;nbsp;result&amp;nbsp;=&amp;nbsp;"";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;this.matrix.length;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;j&amp;nbsp;&lt;&amp;nbsp;this.matrix[i].length;&amp;nbsp;j++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result&amp;nbsp;+=&amp;nbsp;this.matrix[i][j]&amp;nbsp;+&amp;nbsp;"&amp;nbsp;";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result&amp;nbsp;+=&amp;nbsp;"\n";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;result;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static&amp;nbsp;Matrix&amp;nbsp;multiply(Matrix&amp;nbsp;a,&amp;nbsp;Matrix&amp;nbsp;b){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(a.getCols()&amp;nbsp;!=&amp;nbsp;b.getRows())&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw&amp;nbsp;new&amp;nbsp;IllegalArgumentException("Wrong&amp;nbsp;matrixes&amp;nbsp;:&amp;nbsp;a.getCols()&amp;nbsp;should&amp;nbsp;be&amp;nbsp;equal&amp;nbsp;to&amp;nbsp;b.getRows()");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix&amp;nbsp;result&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Matrix(a.getRows(),&amp;nbsp;b.getCols());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;a.getRows();&amp;nbsp;i++)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;j&amp;nbsp;&lt;&amp;nbsp;b.getCols();&amp;nbsp;j++){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;k&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;k&amp;nbsp;&lt;&amp;nbsp;a.getCols();&amp;nbsp;k++)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result.setValue(i,&amp;nbsp;j,&amp;nbsp;result.getValue(i,&amp;nbsp;j)+a.getValue(i,&amp;nbsp;k)*&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.getValue(k,&amp;nbsp;j));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;result;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
==&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
5.0&amp;nbsp;5.0&amp;nbsp;5.0&amp;nbsp;&lt;br&gt;
11.0&amp;nbsp;11.0&amp;nbsp;11.0&amp;nbsp;&lt;br&gt;
&lt;br&gt;
===============================================================================</questionanswer>
  </question>
  <question id="1_0_0_3_0:23" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Fork&amp;nbsp;Join&amp;nbsp;framework,&amp;nbsp;what&amp;nbsp;is&amp;nbsp;wrong&amp;nbsp;in&amp;nbsp;following&amp;nbsp;&lt;br&gt;
computation&amp;nbsp;of&amp;nbsp;Fibonacci&amp;nbsp;number&amp;nbsp;using&amp;nbsp;Fork&amp;nbsp;Join&amp;nbsp;?&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;javautilconcurent.forkjoin;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.ArrayList;&lt;br&gt;
import&amp;nbsp;java.util.List;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ForkJoinPool;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.RecursiveAction;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;class&amp;nbsp;WWWWWrongFibonacciForkJoin{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;using&amp;nbsp;FibonacciForkJoin&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;result&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;&amp;nbsp;//&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;n&amp;nbsp;=&amp;nbsp;7;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ForkJoinPool&amp;nbsp;pool&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ForkJoinPool();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;FibonacciForkJoin1&amp;nbsp;fibonacciForkJoin&amp;nbsp;=&amp;nbsp;new&amp;nbsp;FibonacciForkJoin1(n,&amp;nbsp;result);&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;(2)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pool.invoke(fibonacciForkJoin);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(result);&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;OUTPUT&amp;nbsp;is&amp;nbsp;0&amp;nbsp;,&amp;nbsp;but&amp;nbsp;should&amp;nbsp;be&amp;nbsp;13&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class&amp;nbsp;FibonacciForkJoin1&amp;nbsp;extends&amp;nbsp;RecursiveAction{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;n&amp;nbsp;;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;result;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;FibonacciForkJoin1(Integer&amp;nbsp;n&amp;nbsp;,&amp;nbsp;Integer&amp;nbsp;result)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.n&amp;nbsp;=&amp;nbsp;n;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.result&amp;nbsp;=&amp;nbsp;result;&amp;nbsp;(3)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;protected&amp;nbsp;void&amp;nbsp;compute()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(n.equals(1)&amp;nbsp;||&amp;nbsp;n.equals(0)){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result&amp;nbsp;+=&amp;nbsp;n;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;(4)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}else&amp;nbsp;if(n&gt;1){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List&lt;FibonacciForkJoin1&gt;&amp;nbsp;tasks&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ArrayList&lt;&gt;();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tasks.add(new&amp;nbsp;FibonacciForkJoin1(n-1,&amp;nbsp;result));&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tasks.add(new&amp;nbsp;FibonacciForkJoin1(n-2,&amp;nbsp;result));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;invokeAll(tasks);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&amp;nbsp;0&amp;nbsp;,&amp;nbsp;should&amp;nbsp;be&amp;nbsp;13&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>We&amp;nbsp;use&amp;nbsp;Integer&amp;nbsp;as&amp;nbsp;result&amp;nbsp;of&amp;nbsp;operation&amp;nbsp;in&amp;nbsp;(1)&amp;nbsp;&lt;br&gt;
&lt;br&gt;
Lets&amp;nbsp;look&amp;nbsp;on&amp;nbsp;simply&amp;nbsp;example&amp;nbsp;:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;p&amp;nbsp;=&amp;nbsp;100;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;k&amp;nbsp;=&amp;nbsp;p&amp;nbsp;;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;k&amp;nbsp;+=&amp;nbsp;10;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(p);&amp;nbsp;//&amp;nbsp;100&amp;nbsp;&amp;nbsp;!!!&lt;br&gt;
&lt;br&gt;
So&amp;nbsp;our&amp;nbsp;problem&amp;nbsp;is&amp;nbsp;:&amp;nbsp;&amp;nbsp;on&amp;nbsp;&amp;nbsp;(4)&amp;nbsp;we&amp;nbsp;dont&amp;nbsp;change&amp;nbsp;the&amp;nbsp;final&amp;nbsp;result&amp;nbsp;,&amp;nbsp;but&amp;nbsp;create&amp;nbsp;another&amp;nbsp;place&amp;nbsp;in&amp;nbsp;memory&amp;nbsp;for&amp;nbsp;local&amp;nbsp;varialbe&lt;br&gt;
and&amp;nbsp;this&amp;nbsp;value&amp;nbsp;will&amp;nbsp;be&amp;nbsp;lost&amp;nbsp;=)&lt;br&gt;
=============================&lt;br&gt;
Stackoverflow&amp;nbsp;question&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
How&amp;nbsp;to&amp;nbsp;Increment&amp;nbsp;a&amp;nbsp;class&amp;nbsp;Integer&amp;nbsp;references&amp;nbsp;value&amp;nbsp;in&amp;nbsp;java&amp;nbsp;from&amp;nbsp;another&amp;nbsp;method&amp;nbsp;?&lt;br&gt;
&lt;br&gt;
No,&amp;nbsp;objects&amp;nbsp;aren't&amp;nbsp;passed&amp;nbsp;by&amp;nbsp;reference.&amp;nbsp;References&amp;nbsp;are&amp;nbsp;passed&amp;nbsp;by&amp;nbsp;value&amp;nbsp;-&amp;nbsp;there's&amp;nbsp;a&lt;br&gt;
big&amp;nbsp;difference.&amp;nbsp;Integer&amp;nbsp;is&amp;nbsp;an&amp;nbsp;immutable&amp;nbsp;type,&amp;nbsp;therefore&amp;nbsp;you&amp;nbsp;can't&amp;nbsp;change&amp;nbsp;the&amp;nbsp;value&lt;br&gt;
within&amp;nbsp;the&amp;nbsp;method.&lt;br&gt;
&lt;br&gt;
Your&amp;nbsp;n++;&amp;nbsp;statement&amp;nbsp;is&amp;nbsp;effectively&lt;br&gt;
&lt;br&gt;
n&amp;nbsp;=&amp;nbsp;Integer.valueOf(n.intValue()&amp;nbsp;+&amp;nbsp;1);&lt;br&gt;
So,&amp;nbsp;that&amp;nbsp;assigns&amp;nbsp;a&amp;nbsp;different&amp;nbsp;value&amp;nbsp;to&amp;nbsp;the&amp;nbsp;variable&amp;nbsp;n&amp;nbsp;in&amp;nbsp;Increment&amp;nbsp;-&amp;nbsp;but&amp;nbsp;as&amp;nbsp;Java&amp;nbsp;only&amp;nbsp;has&lt;br&gt;
pass-by-value,&amp;nbsp;that&amp;nbsp;doesn't&amp;nbsp;affect&amp;nbsp;the&amp;nbsp;value&amp;nbsp;of&amp;nbsp;n&amp;nbsp;in&amp;nbsp;the&amp;nbsp;calling&amp;nbsp;method.&lt;br&gt;
&lt;br&gt;
================&lt;br&gt;
Solution&amp;nbsp;of&amp;nbsp;our&amp;nbsp;program&amp;nbsp;using&amp;nbsp;AtomicInteger:&amp;nbsp;&lt;br&gt;
package&amp;nbsp;javautilconcurent.forkjoin;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.ArrayList;&lt;br&gt;
import&amp;nbsp;java.util.List;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ForkJoinPool;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.RecursiveAction;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.atomic.AtomicInteger;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;class&amp;nbsp;WWWWWrongFibonacciForkJoin{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;using&amp;nbsp;FibonacciForkJoin&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;n&amp;nbsp;=&amp;nbsp;&amp;nbsp;&amp;nbsp;7;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;AtomicInteger&amp;nbsp;result&amp;nbsp;=&amp;nbsp;new&amp;nbsp;AtomicInteger(0);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ForkJoinPool&amp;nbsp;pool&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ForkJoinPool();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;FibonacciForkJoin1&amp;nbsp;fibonacciForkJoin&amp;nbsp;=&amp;nbsp;new&amp;nbsp;FibonacciForkJoin1(n,&amp;nbsp;result);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pool.invoke(fibonacciForkJoin);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(result);&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;OUTPUT&amp;nbsp;is&amp;nbsp;0&amp;nbsp;,&amp;nbsp;but&amp;nbsp;should&amp;nbsp;be&amp;nbsp;13&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class&amp;nbsp;FibonacciForkJoin1&amp;nbsp;extends&amp;nbsp;RecursiveAction{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;n&amp;nbsp;;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;AtomicInteger&amp;nbsp;result&amp;nbsp;;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;FibonacciForkJoin1(Integer&amp;nbsp;n&amp;nbsp;,&amp;nbsp;AtomicInteger&amp;nbsp;result)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.n&amp;nbsp;=&amp;nbsp;n;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.result&amp;nbsp;=&amp;nbsp;result;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;protected&amp;nbsp;void&amp;nbsp;compute()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(n.equals(1)&amp;nbsp;||&amp;nbsp;n.equals(0)){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//result&amp;nbsp;+=&amp;nbsp;n;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result.addAndGet(n);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}else&amp;nbsp;if(n&gt;1){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List&lt;FibonacciForkJoin1&gt;&amp;nbsp;tasks&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ArrayList&lt;&gt;();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tasks.add(new&amp;nbsp;FibonacciForkJoin1(n-1,&amp;nbsp;result));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tasks.add(new&amp;nbsp;FibonacciForkJoin1(n-2,&amp;nbsp;result));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;invokeAll(tasks);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
===&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
BUT&amp;nbsp;you&amp;nbsp;can&amp;nbsp;use&amp;nbsp;RecursiveTask&lt;V&gt;&amp;nbsp;to&amp;nbsp;solve&amp;nbsp;this&amp;nbsp;problem&amp;nbsp;&lt;br&gt;
RecursiveTask&amp;nbsp;&amp;nbsp;return&amp;nbsp;value,&amp;nbsp;but&amp;nbsp;Recursive&amp;nbsp;action&amp;nbsp;doesn't&amp;nbsp;.&lt;br&gt;
&lt;br&gt;
For&amp;nbsp;a&amp;nbsp;classic&amp;nbsp;example,&amp;nbsp;here&amp;nbsp;is&amp;nbsp;a&amp;nbsp;task&amp;nbsp;computing&amp;nbsp;Fibonacci&amp;nbsp;numbers:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;class&amp;nbsp;Fibonacci&amp;nbsp;extends&amp;nbsp;RecursiveTask&lt;Integer&gt;&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;int&amp;nbsp;n;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Fibonacci(int&amp;nbsp;n)&amp;nbsp;{&amp;nbsp;this.n&amp;nbsp;=&amp;nbsp;n;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Integer&amp;nbsp;compute()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(n&amp;nbsp;&lt;=&amp;nbsp;1)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;n;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Fibonacci&amp;nbsp;f1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Fibonacci(n&amp;nbsp;-&amp;nbsp;1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;f1.fork();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Fibonacci&amp;nbsp;f2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Fibonacci(n&amp;nbsp;-&amp;nbsp;2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;f2.compute()&amp;nbsp;+&amp;nbsp;f1.join();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;}&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:24" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;java.util.concurrent.locks&amp;nbsp;package&amp;nbsp;,&amp;nbsp;describe.&amp;nbsp;Provide&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;examples.&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>java.util.concurrent.locks&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='696'&amp;nbsp;height='658'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/LocksPackage1.png'/&gt;&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='704'&amp;nbsp;height='559'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/LockPackage2.png'/&gt;&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;java.util.concurrent.locks&amp;nbsp;package&amp;nbsp;holds&amp;nbsp;classes&amp;nbsp;that&amp;nbsp;mimic&amp;nbsp;and&amp;nbsp;expand&amp;nbsp;upon&lt;br&gt;
the&amp;nbsp;built-in&amp;nbsp;Java&amp;nbsp;language&amp;nbsp;synchronization&amp;nbsp;primitives,&amp;nbsp;adding&amp;nbsp;“read/write”&amp;nbsp;locks&amp;nbsp;among&lt;br&gt;
other&amp;nbsp;things.&lt;br&gt;
&lt;br&gt;
As&amp;nbsp;we&amp;nbsp;mentioned,&amp;nbsp;these&amp;nbsp;classes&amp;nbsp;are&amp;nbsp;utilities&amp;nbsp;written&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;and&amp;nbsp;don’t&amp;nbsp;strictly&lt;br&gt;
add&amp;nbsp;anything&amp;nbsp;new&amp;nbsp;to&amp;nbsp;the&amp;nbsp;language&amp;nbsp;semantics.&amp;nbsp;However,&amp;nbsp;they&amp;nbsp;do&amp;nbsp;provide&amp;nbsp;more&amp;nbsp;flexible&lt;br&gt;
usage&amp;nbsp;at&amp;nbsp;the&amp;nbsp;expense&amp;nbsp;of&amp;nbsp;some&amp;nbsp;of&amp;nbsp;the&amp;nbsp;built-in&amp;nbsp;safety&amp;nbsp;of&amp;nbsp;Java&amp;nbsp;language&amp;nbsp;synchronization.&lt;br&gt;
&lt;br&gt;
!!!!!&lt;br&gt;
At&amp;nbsp;the&amp;nbsp;heart&amp;nbsp;of&amp;nbsp;the&amp;nbsp;locks&amp;nbsp;package&amp;nbsp;are&amp;nbsp;the&amp;nbsp;Lock&amp;nbsp;and&amp;nbsp;Condition&amp;nbsp;interfaces.&lt;br&gt;
!!!!!!&lt;br&gt;
&lt;br&gt;
Interfaces:&lt;br&gt;
Condition&lt;br&gt;
Lock&lt;br&gt;
ReadWriteLock&lt;br&gt;
&lt;br&gt;
Classes:&lt;br&gt;
&lt;br&gt;
AbstractOwnableSynchronizer&lt;br&gt;
AbstractQueuedLongSynchronizer&lt;br&gt;
AbstractQueuedSynchronizer&lt;br&gt;
LockSupport&lt;br&gt;
ReentrantLock&lt;br&gt;
ReentrantReadWriteLock&lt;br&gt;
ReentrantReadWriteLock.ReadLock&lt;br&gt;
ReentrantReadWriteLock.WriteLock&lt;br&gt;
&lt;br&gt;
-=========================================&lt;br&gt;
Lock&amp;nbsp;represents&amp;nbsp;the&amp;nbsp;same&amp;nbsp;concept&amp;nbsp;as&amp;nbsp;a&amp;nbsp;Java&amp;nbsp;lock&amp;nbsp;(monitor)&amp;nbsp;that&amp;nbsp;is&amp;nbsp;associated&amp;nbsp;with&amp;nbsp;each&lt;br&gt;
object&amp;nbsp;and&amp;nbsp;class&amp;nbsp;for&amp;nbsp;use&amp;nbsp;with&amp;nbsp;synchronized&amp;nbsp;methods&amp;nbsp;and&amp;nbsp;blocks.&amp;nbsp;The&amp;nbsp;Lock&amp;nbsp;class&amp;nbsp;provides&lt;br&gt;
for&amp;nbsp;exclusive&amp;nbsp;access&amp;nbsp;by&amp;nbsp;the&amp;nbsp;owner&amp;nbsp;of&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;by&amp;nbsp;allowing&amp;nbsp;only&amp;nbsp;one&amp;nbsp;party&amp;nbsp;to&amp;nbsp;hold&amp;nbsp;the&amp;nbsp;lock&lt;br&gt;
at&amp;nbsp;a&amp;nbsp;time&amp;nbsp;through&amp;nbsp;the&amp;nbsp;lock()&amp;nbsp;and&amp;nbsp;unlock()&amp;nbsp;methods.&amp;nbsp;In&amp;nbsp;Java&amp;nbsp;language&amp;nbsp;synchronization,&amp;nbsp;this&lt;br&gt;
is&amp;nbsp;accomplished&amp;nbsp;implicitly&amp;nbsp;with&amp;nbsp;the&amp;nbsp;synchronized&amp;nbsp;keyword:&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;synchronized&amp;nbsp;method&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;writeData()&amp;nbsp;{&amp;nbsp;...&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;synchronized&amp;nbsp;block&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;(&amp;nbsp;someObject&amp;nbsp;)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Upon&amp;nbsp;entry&amp;nbsp;to&amp;nbsp;the&amp;nbsp;synchronized&amp;nbsp;method&amp;nbsp;or&amp;nbsp;block,&amp;nbsp;Java&amp;nbsp;acquires&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;automatically&lt;br&gt;
releases&amp;nbsp;it&amp;nbsp;upon&amp;nbsp;exiting.&amp;nbsp;Even&amp;nbsp;if&amp;nbsp;an&amp;nbsp;exception&amp;nbsp;is&amp;nbsp;thrown&amp;nbsp;or&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;dies&amp;nbsp;unexpectedly,&lt;br&gt;
Java&amp;nbsp;automatically&amp;nbsp;releases&amp;nbsp;all&amp;nbsp;of&amp;nbsp;the&amp;nbsp;locks&amp;nbsp;it&amp;nbsp;acquired.&amp;nbsp;Using&amp;nbsp;the&amp;nbsp;Lock&amp;nbsp;class&lt;br&gt;
instead&amp;nbsp;requires&amp;nbsp;us&amp;nbsp;(or&amp;nbsp;allows&amp;nbsp;us,&amp;nbsp;depending&amp;nbsp;on&amp;nbsp;how&amp;nbsp;you&amp;nbsp;look&amp;nbsp;at&amp;nbsp;it)&amp;nbsp;to&amp;nbsp;explicitly&amp;nbsp;lock&lt;br&gt;
when&amp;nbsp;we&amp;nbsp;want&amp;nbsp;the&amp;nbsp;resource&amp;nbsp;and&amp;nbsp;remember&amp;nbsp;to&amp;nbsp;unlock&amp;nbsp;it&amp;nbsp;when&amp;nbsp;we&amp;nbsp;are&amp;nbsp;through.&amp;nbsp;The&amp;nbsp;locking&lt;br&gt;
is&amp;nbsp;not&amp;nbsp;tied&amp;nbsp;to&amp;nbsp;any&amp;nbsp;particular&amp;nbsp;scope,&amp;nbsp;such&amp;nbsp;as&amp;nbsp;a&amp;nbsp;single&amp;nbsp;method&amp;nbsp;or&amp;nbsp;code&amp;nbsp;block.&amp;nbsp;To&amp;nbsp;reproduce&lt;br&gt;
the&amp;nbsp;effect&amp;nbsp;of&amp;nbsp;the&amp;nbsp;synchronized&amp;nbsp;method&amp;nbsp;in&amp;nbsp;the&amp;nbsp;example,&amp;nbsp;we’d&amp;nbsp;use&amp;nbsp;something&amp;nbsp;like:&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Lock&amp;nbsp;lock&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ReentrantLock();&lt;br&gt;
//&amp;nbsp;method&amp;nbsp;or&amp;nbsp;block&lt;br&gt;
lock.lock();&lt;br&gt;
try&amp;nbsp;{&lt;br&gt;
//&amp;nbsp;body&amp;nbsp;of&amp;nbsp;method&amp;nbsp;or&amp;nbsp;block&amp;nbsp;...&lt;br&gt;
}&amp;nbsp;finally&amp;nbsp;{&lt;br&gt;
lock.unlock()&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;first&amp;nbsp;caller&amp;nbsp;to&amp;nbsp;lock()&amp;nbsp;acquires&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;proceeds.&amp;nbsp;Subsequent&amp;nbsp;calls&amp;nbsp;by&lt;br&gt;
other&amp;nbsp;threads&amp;nbsp;block&amp;nbsp;until&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;released.&amp;nbsp;We&amp;nbsp;perform&amp;nbsp;the&amp;nbsp;body&amp;nbsp;of&amp;nbsp;our&amp;nbsp;locked&lt;br&gt;
operation&amp;nbsp;in&amp;nbsp;a&amp;nbsp;try/finally&amp;nbsp;block.&amp;nbsp;This&amp;nbsp;is&amp;nbsp;generally&amp;nbsp;important&amp;nbsp;in&amp;nbsp;order&amp;nbsp;to&amp;nbsp;ensure&amp;nbsp;that&lt;br&gt;
we&amp;nbsp;always&amp;nbsp;unlock&amp;nbsp;before&amp;nbsp;we&amp;nbsp;leave,&amp;nbsp;but&amp;nbsp;you&amp;nbsp;are&amp;nbsp;free&amp;nbsp;to&amp;nbsp;implement&amp;nbsp;arbitrary&amp;nbsp;protocols&lt;br&gt;
at&amp;nbsp;your&amp;nbsp;own&amp;nbsp;risk.&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;lock&amp;nbsp;implementation&amp;nbsp;in&amp;nbsp;this&amp;nbsp;example&amp;nbsp;is&amp;nbsp;called&amp;nbsp;___ReentrantLock.&amp;nbsp;The&amp;nbsp;name&lt;br&gt;
implies&amp;nbsp;that&amp;nbsp;this&amp;nbsp;kind&amp;nbsp;of&amp;nbsp;lock&amp;nbsp;acts&amp;nbsp;like&amp;nbsp;Java&amp;nbsp;locks&amp;nbsp;do&amp;nbsp;in&amp;nbsp;that&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;associated&amp;nbsp;with&lt;br&gt;
the&amp;nbsp;caller’s&amp;nbsp;thread.&amp;nbsp;The&amp;nbsp;owner&amp;nbsp;of&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;may&amp;nbsp;reacquire&amp;nbsp;(“relock”)&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;as&amp;nbsp;many&amp;nbsp;times&lt;br&gt;
as&amp;nbsp;it&amp;nbsp;wishes.&amp;nbsp;For&amp;nbsp;example,&amp;nbsp;a&amp;nbsp;recursive&amp;nbsp;method&amp;nbsp;that&amp;nbsp;locks&amp;nbsp;a&amp;nbsp;resource&amp;nbsp;upon&amp;nbsp;entry&amp;nbsp;is&amp;nbsp;fine.&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;addition&amp;nbsp;to&amp;nbsp;the&amp;nbsp;standard-looking&amp;nbsp;lock()&amp;nbsp;method,&amp;nbsp;the&amp;nbsp;Lock&amp;nbsp;interface&amp;nbsp;has&amp;nbsp;tryLock()&lt;br&gt;
methods&amp;nbsp;that&amp;nbsp;do&amp;nbsp;not&amp;nbsp;block&amp;nbsp;or&amp;nbsp;that&amp;nbsp;block&amp;nbsp;for&amp;nbsp;a&amp;nbsp;specified&amp;nbsp;period&amp;nbsp;of&amp;nbsp;time&amp;nbsp;in&amp;nbsp;order&amp;nbsp;to&lt;br&gt;
acquire&amp;nbsp;the&amp;nbsp;lock.&amp;nbsp;These&amp;nbsp;conditional&amp;nbsp;and&amp;nbsp;timed&amp;nbsp;wait&amp;nbsp;locking&amp;nbsp;forms&amp;nbsp;are&amp;nbsp;something&amp;nbsp;that&lt;br&gt;
ordinary&amp;nbsp;Java&amp;nbsp;locks&amp;nbsp;do&amp;nbsp;not&amp;nbsp;provide.&amp;nbsp;The&amp;nbsp;ReentrantLock&amp;nbsp;implementation&amp;nbsp;also&amp;nbsp;has&amp;nbsp;a&lt;br&gt;
notion&amp;nbsp;of&amp;nbsp;“fairness”&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;turned&amp;nbsp;on&amp;nbsp;or&amp;nbsp;off&amp;nbsp;when&amp;nbsp;it&amp;nbsp;is&amp;nbsp;constructed.&amp;nbsp;When&amp;nbsp;fair&amp;nbsp;is&lt;br&gt;
on,&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;attempts&amp;nbsp;to&amp;nbsp;hand&amp;nbsp;out&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;to&amp;nbsp;callers&amp;nbsp;in&amp;nbsp;the&amp;nbsp;order&amp;nbsp;in&amp;nbsp;which&amp;nbsp;they&lt;br&gt;
request&amp;nbsp;it.&amp;nbsp;Normal&amp;nbsp;Java&amp;nbsp;locks&amp;nbsp;(and&amp;nbsp;the&amp;nbsp;default,&amp;nbsp;unfair&amp;nbsp;policy&amp;nbsp;of&amp;nbsp;ReentrantLock)&amp;nbsp;do&amp;nbsp;not&lt;br&gt;
make&amp;nbsp;this&amp;nbsp;guarantee.&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&amp;nbsp;&lt;br&gt;
package&amp;nbsp;javautilconcurent.locks;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.locks.Lock;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.locks.ReentrantLock;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;UtilConcurentLocksHelloWorld&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue&amp;nbsp;printQueue=new&amp;nbsp;PrintQueue();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;thread[]&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread[10];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread[i]&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;Job(printQueue),&amp;nbsp;"Thread&amp;nbsp;"&amp;nbsp;+&amp;nbsp;i);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread[i].start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;PrintQueue&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;final&amp;nbsp;Lock&amp;nbsp;queueLock=new&amp;nbsp;ReentrantLock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;printJob(Object&amp;nbsp;document)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;queueLock.lock();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Long&amp;nbsp;duration&amp;nbsp;=&amp;nbsp;(long)&amp;nbsp;(Math.random()&amp;nbsp;*&amp;nbsp;10000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;":&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;"&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;(duration&amp;nbsp;/&amp;nbsp;1000)&amp;nbsp;+&amp;nbsp;"&amp;nbsp;seconds");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(duration);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;finally&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;queueLock.unlock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Job&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;PrintQueue&amp;nbsp;printQueue;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Job(PrintQueue&amp;nbsp;printQueue){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.printQueue=printQueue;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("%s:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document\n",&amp;nbsp;Thread&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.currentThread().getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printQueue.printJob(new&amp;nbsp;Object());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("%s:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed\n",&amp;nbsp;Thread&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.currentThread().getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
POSSIBLE&amp;nbsp;OUTPUT&amp;nbsp;:&lt;br&gt;
Thread&amp;nbsp;0:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;3:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;2:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;2:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;5&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;1:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;4:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;5:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;6:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;7:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;8:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;9:&amp;nbsp;Going&amp;nbsp;to&amp;nbsp;print&amp;nbsp;a&amp;nbsp;document&lt;br&gt;
Thread&amp;nbsp;2:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;1:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;6&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;1:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;3:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;5&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;3:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;5&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;0:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;7&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;4:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;5:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;3&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;5:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;6:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;1&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;6:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;7:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;0&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;7:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;4&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;8:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
Thread&amp;nbsp;9:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PrintQueue:&amp;nbsp;Printing&amp;nbsp;a&amp;nbsp;Job&amp;nbsp;during&amp;nbsp;1&amp;nbsp;seconds&lt;br&gt;
Thread&amp;nbsp;9:&amp;nbsp;The&amp;nbsp;document&amp;nbsp;has&amp;nbsp;been&amp;nbsp;printed&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
============================================&lt;br&gt;
&amp;nbsp;Read&amp;nbsp;and&amp;nbsp;write&amp;nbsp;locks&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;ReadWriteLock&amp;nbsp;maintains&amp;nbsp;a&amp;nbsp;pair&amp;nbsp;of&amp;nbsp;associated&amp;nbsp;locks,&amp;nbsp;one&amp;nbsp;for&amp;nbsp;read-only&amp;nbsp;operations&lt;br&gt;
and&amp;nbsp;one&amp;nbsp;for&amp;nbsp;writing.&amp;nbsp;The&amp;nbsp;read&amp;nbsp;lock&amp;nbsp;may&amp;nbsp;be&amp;nbsp;held&amp;nbsp;simultaneously&amp;nbsp;by&amp;nbsp;multiple&lt;br&gt;
reader&amp;nbsp;threads,&amp;nbsp;so&amp;nbsp;long&amp;nbsp;as&amp;nbsp;there&amp;nbsp;are&amp;nbsp;no&amp;nbsp;writers.&amp;nbsp;The&amp;nbsp;write&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;exclusive.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
!!!&lt;br&gt;
The&amp;nbsp;ReadWriteLock&amp;nbsp;interface&amp;nbsp;is&amp;nbsp;a&amp;nbsp;gateway&amp;nbsp;to&amp;nbsp;two&amp;nbsp;different&amp;nbsp;locks,&amp;nbsp;one&amp;nbsp;for&amp;nbsp;reading&lt;br&gt;
and&amp;nbsp;one&amp;nbsp;for&amp;nbsp;writing.&amp;nbsp;The&amp;nbsp;idea&amp;nbsp;behind&amp;nbsp;read/write&amp;nbsp;locks&amp;nbsp;is&amp;nbsp;that&amp;nbsp;for&amp;nbsp;most&amp;nbsp;resources&amp;nbsp;it&lt;br&gt;
is&amp;nbsp;OK&amp;nbsp;for&amp;nbsp;many&amp;nbsp;“readers”&amp;nbsp;to&amp;nbsp;be&amp;nbsp;viewing&amp;nbsp;data,&amp;nbsp;as&amp;nbsp;long&amp;nbsp;as&amp;nbsp;it&amp;nbsp;is&amp;nbsp;not&amp;nbsp;changing.&lt;br&gt;
Conversely,&amp;nbsp;a&amp;nbsp;writer&amp;nbsp;of&amp;nbsp;the&amp;nbsp;data&amp;nbsp;generally&amp;nbsp;requires&amp;nbsp;exclusive&amp;nbsp;access&amp;nbsp;to&amp;nbsp;it.&amp;nbsp;This&amp;nbsp;is&amp;nbsp;just&lt;br&gt;
what&amp;nbsp;read/write&amp;nbsp;locks&amp;nbsp;do.&amp;nbsp;Any&amp;nbsp;number&amp;nbsp;of&amp;nbsp;readers&amp;nbsp;may&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;read&amp;nbsp;lock&amp;nbsp;as&amp;nbsp;long&lt;br&gt;
as&amp;nbsp;no&amp;nbsp;write&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;in&amp;nbsp;place.&amp;nbsp;Only&amp;nbsp;one&amp;nbsp;party&amp;nbsp;may&amp;nbsp;hold&amp;nbsp;the&amp;nbsp;write&amp;nbsp;lock,&amp;nbsp;and&amp;nbsp;no&amp;nbsp;readers&lt;br&gt;
may&amp;nbsp;hold&amp;nbsp;read&amp;nbsp;locks&amp;nbsp;while&amp;nbsp;the&amp;nbsp;write&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;out.&amp;nbsp;A&amp;nbsp;writer&amp;nbsp;may&amp;nbsp;have&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;readers&lt;br&gt;
to&amp;nbsp;finish&amp;nbsp;before&amp;nbsp;acquiring&amp;nbsp;the&amp;nbsp;write&amp;nbsp;lock,&amp;nbsp;and&amp;nbsp;readers&amp;nbsp;may&amp;nbsp;have&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;a&amp;nbsp;writer&lt;br&gt;
to&amp;nbsp;finish&amp;nbsp;before&amp;nbsp;they&amp;nbsp;are&amp;nbsp;allowed&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;read&amp;nbsp;locks:&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&amp;nbsp;ReadWriteLock&amp;nbsp;rwLock&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ReentrantReadWriteLock(&amp;nbsp;fair&amp;nbsp;);&lt;br&gt;
//&amp;nbsp;reader&amp;nbsp;thread&amp;nbsp;1&lt;br&gt;
&amp;nbsp;rwLock.readLock().lock();&lt;br&gt;
//&amp;nbsp;reader&amp;nbsp;thread&amp;nbsp;2&lt;br&gt;
&amp;nbsp;rwLock.readLock().lock();&lt;br&gt;
//&amp;nbsp;writer&amp;nbsp;thread&lt;br&gt;
&amp;nbsp;rwLock.writeLock().lock();&amp;nbsp;//&amp;nbsp;blocks&amp;nbsp;on&amp;nbsp;threads&amp;nbsp;1&amp;nbsp;&amp;&amp;nbsp;2&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;this&amp;nbsp;code&amp;nbsp;snippet,&amp;nbsp;two&amp;nbsp;readers&amp;nbsp;hold&amp;nbsp;read&amp;nbsp;locks&amp;nbsp;while&amp;nbsp;a&amp;nbsp;writer&amp;nbsp;blocks&amp;nbsp;waiting&amp;nbsp;on&lt;br&gt;
the&amp;nbsp;write&amp;nbsp;lock.&amp;nbsp;When&amp;nbsp;both&amp;nbsp;readers&amp;nbsp;have&amp;nbsp;unlock()ed&amp;nbsp;their&amp;nbsp;read&amp;nbsp;locks,&amp;nbsp;the&amp;nbsp;writer&amp;nbsp;gains&lt;br&gt;
exclusive&amp;nbsp;access&amp;nbsp;to&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;any&amp;nbsp;subsequent&amp;nbsp;readers&amp;nbsp;block&amp;nbsp;until&amp;nbsp;the&amp;nbsp;writer&amp;nbsp;is&lt;br&gt;
finished.&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;owner&amp;nbsp;of&amp;nbsp;a&amp;nbsp;write&amp;nbsp;lock&amp;nbsp;can&amp;nbsp;acquire&amp;nbsp;a&amp;nbsp;read&amp;nbsp;lock,&amp;nbsp;too,&amp;nbsp;but&amp;nbsp;not&amp;nbsp;vice&amp;nbsp;versa.&lt;br&gt;
Acquiring&amp;nbsp;a&amp;nbsp;read&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;then&amp;nbsp;releasing&amp;nbsp;the&amp;nbsp;write&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;called&amp;nbsp;downgrading&amp;nbsp;the&lt;br&gt;
lock.&amp;nbsp;Trying&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;a&amp;nbsp;write&amp;nbsp;lock&amp;nbsp;while&amp;nbsp;holding&amp;nbsp;a&amp;nbsp;read&amp;nbsp;lock&amp;nbsp;(upgrading)&amp;nbsp;is&amp;nbsp;not&amp;nbsp;allowed&lt;br&gt;
and&amp;nbsp;causes&amp;nbsp;a&amp;nbsp;deadlock.&lt;br&gt;
=====================&lt;br&gt;
====&lt;br&gt;
First&amp;nbsp;let's&amp;nbsp;summarize&amp;nbsp;the&amp;nbsp;conditions&amp;nbsp;for&amp;nbsp;getting&amp;nbsp;read&amp;nbsp;and&amp;nbsp;write&amp;nbsp;access&amp;nbsp;to&amp;nbsp;the&amp;nbsp;resource:&lt;br&gt;
Read&amp;nbsp;Access&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;If&amp;nbsp;no&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;writing,&amp;nbsp;and&amp;nbsp;no&amp;nbsp;threads&amp;nbsp;have&amp;nbsp;requested&amp;nbsp;write&amp;nbsp;access.&lt;br&gt;
Write&amp;nbsp;Access&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;If&amp;nbsp;no&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;reading&amp;nbsp;or&amp;nbsp;writing.&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;:&lt;br&gt;
package&amp;nbsp;javautilconcurent.locks;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.locks.ReadWriteLock;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.locks.ReentrantReadWriteLock;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ReadWriteLockJava7ConcurrencyCookbook&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PricesInfo&amp;nbsp;pricesInfo=new&amp;nbsp;PricesInfo();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Reader&amp;nbsp;readers[]&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Reader[5];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;threadsReader[]&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread[5];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;5;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;readers[i]&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Reader(pricesInfo);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;threadsReader[i]&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(readers[i]);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Writer&amp;nbsp;writer=new&amp;nbsp;Writer(pricesInfo);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;threadWriter=new&amp;nbsp;Thread(writer);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;5;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;threadsReader[i].start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;threadWriter.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
//&amp;nbsp;this&amp;nbsp;object&amp;nbsp;has&amp;nbsp;read&amp;nbsp;and&amp;nbsp;write&amp;nbsp;locks&lt;br&gt;
class&amp;nbsp;PricesInfo&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;double&amp;nbsp;price1;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;double&amp;nbsp;price2;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;ReadWriteLock&amp;nbsp;lock;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;PricesInfo()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;price1&amp;nbsp;=&amp;nbsp;1.0;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;price2&amp;nbsp;=&amp;nbsp;2.0;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ReentrantReadWriteLock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;double&amp;nbsp;getPrice1()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.readLock().lock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double&amp;nbsp;value&amp;nbsp;=&amp;nbsp;price1;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.readLock().unlock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;value;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;double&amp;nbsp;getPrice2()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.readLock().lock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double&amp;nbsp;value&amp;nbsp;=&amp;nbsp;price2;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.readLock().unlock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;value;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;setPrices(double&amp;nbsp;price1,&amp;nbsp;double&amp;nbsp;price2)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.writeLock().lock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.price1&amp;nbsp;=&amp;nbsp;price1;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.price2&amp;nbsp;=&amp;nbsp;price2;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.writeLock().unlock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Reader&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;PricesInfo&amp;nbsp;pricesInfo;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Reader(PricesInfo&amp;nbsp;pricesInfo)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.pricesInfo&amp;nbsp;=&amp;nbsp;pricesInfo;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("%s:&amp;nbsp;Price&amp;nbsp;1:&amp;nbsp;%f\n",&amp;nbsp;Thread.currentThread()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.getName(),&amp;nbsp;pricesInfo.getPrice1());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("%s:&amp;nbsp;Price&amp;nbsp;2:&amp;nbsp;%f\n",&amp;nbsp;Thread.currentThread()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.getName(),&amp;nbsp;pricesInfo.getPrice2());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Writer&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;PricesInfo&amp;nbsp;pricesInfo;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Writer(PricesInfo&amp;nbsp;pricesInfo)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.pricesInfo&amp;nbsp;=&amp;nbsp;pricesInfo;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;3;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double&amp;nbsp;newPrice1&amp;nbsp;=&amp;nbsp;Math.random()&amp;nbsp;*&amp;nbsp;10;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double&amp;nbsp;newPrice2&amp;nbsp;=&amp;nbsp;Math.random()&amp;nbsp;*&amp;nbsp;8;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("Writer:&amp;nbsp;Attempt&amp;nbsp;to&amp;nbsp;modify&amp;nbsp;the&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;prices.\n");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;pricesInfo.setPrices(newPrice1,&amp;nbsp;newPrice2);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("Writer:&amp;nbsp;Prices&amp;nbsp;have&amp;nbsp;been&amp;nbsp;modified.&amp;nbsp;to&amp;nbsp;:"&amp;nbsp;+&amp;nbsp;newPrice1&amp;nbsp;+&amp;nbsp;","&amp;nbsp;+&amp;nbsp;newPrice2+&amp;nbsp;"\n");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
=======&lt;br&gt;
OTHER&amp;nbsp;VERY&amp;nbsp;SIMPLY&amp;nbsp;EXAMPLE:&lt;br&gt;
package&amp;nbsp;javautilconcurent.locks;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.locks.ReentrantReadWriteLock;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ReadWriteLockMyExample&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SyncObject&amp;nbsp;obj&amp;nbsp;=&amp;nbsp;new&amp;nbsp;SyncObject();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread[]&amp;nbsp;threads&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread[10];&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;threads[i]&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;MyTask(obj));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;10;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;threads[i].start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;with&amp;nbsp;locks&amp;nbsp;(1)&amp;nbsp;-&amp;nbsp;execution&amp;nbsp;of&amp;nbsp;program&amp;nbsp;takes&amp;nbsp;800&amp;nbsp;miliseconds&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;with&amp;nbsp;locks&amp;nbsp;(2)&amp;nbsp;-&amp;nbsp;execution&amp;nbsp;of&amp;nbsp;program&amp;nbsp;takes&amp;nbsp;8000&amp;nbsp;miliseconds&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;SyncObject{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;final&amp;nbsp;ReentrantReadWriteLock&amp;nbsp;lock&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ReentrantReadWriteLock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;doWork()&amp;nbsp;throws&amp;nbsp;InterruptedException{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//lock.readLock().lock();&amp;nbsp;&amp;nbsp;//&amp;nbsp;(1)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.writeLock().lock();&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;(2)&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Do&amp;nbsp;important&amp;nbsp;work");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(800);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.writeLock().unlock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//lock.readLock().unlock();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;MyTask&amp;nbsp;implements&amp;nbsp;Runnable{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;SyncObject&amp;nbsp;obj;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;MyTask(SyncObject&amp;nbsp;obj){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.obj&amp;nbsp;=&amp;nbsp;obj;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;obj.doWork();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
==============================================&lt;br&gt;
!!!!!!&lt;br&gt;
&lt;br&gt;
Main&amp;nbsp;Differences&amp;nbsp;Between&amp;nbsp;Locks&amp;nbsp;and&amp;nbsp;Synchronized&amp;nbsp;Blocks&lt;br&gt;
The&amp;nbsp;main&amp;nbsp;differences&amp;nbsp;between&amp;nbsp;a&amp;nbsp;Lock&amp;nbsp;and&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;block&amp;nbsp;are:&lt;br&gt;
-&amp;nbsp;A&amp;nbsp;synchronized&amp;nbsp;block&amp;nbsp;makes&amp;nbsp;no&amp;nbsp;guarantees&amp;nbsp;about&amp;nbsp;the&amp;nbsp;sequence&amp;nbsp;in&amp;nbsp;which&amp;nbsp;threads&lt;br&gt;
waiting&amp;nbsp;to&amp;nbsp;entering&amp;nbsp;it&amp;nbsp;are&amp;nbsp;granted&amp;nbsp;access.&lt;br&gt;
-&amp;nbsp;You&amp;nbsp;cannot&amp;nbsp;pass&amp;nbsp;any&amp;nbsp;parameters&amp;nbsp;to&amp;nbsp;the&amp;nbsp;entry&amp;nbsp;of&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;block.&amp;nbsp;Thus,&amp;nbsp;having&lt;br&gt;
a&amp;nbsp;timeout&amp;nbsp;trying&amp;nbsp;to&amp;nbsp;get&amp;nbsp;access&amp;nbsp;to&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;block&amp;nbsp;is&amp;nbsp;not&amp;nbsp;possible.&lt;br&gt;
-&amp;nbsp;The&amp;nbsp;synchronized&amp;nbsp;block&amp;nbsp;must&amp;nbsp;be&amp;nbsp;fully&amp;nbsp;contained&amp;nbsp;within&amp;nbsp;a&amp;nbsp;single&amp;nbsp;method.&amp;nbsp;A&amp;nbsp;Lock&amp;nbsp;can&lt;br&gt;
have&amp;nbsp;it's&amp;nbsp;calls&amp;nbsp;to&amp;nbsp;lock()&amp;nbsp;and&amp;nbsp;unlock()&amp;nbsp;in&amp;nbsp;separate&amp;nbsp;methods.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
http://www.journaldev.com/&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Lock&amp;nbsp;vs&amp;nbsp;synchronized&lt;br&gt;
-&amp;nbsp;Lock&amp;nbsp;provides&amp;nbsp;more&amp;nbsp;visibility&amp;nbsp;and&amp;nbsp;options&amp;nbsp;for&amp;nbsp;locking,&amp;nbsp;unlike&amp;nbsp;synchronized&amp;nbsp;where&amp;nbsp;a&lt;br&gt;
thread&amp;nbsp;might&amp;nbsp;end&amp;nbsp;up&amp;nbsp;waiting&amp;nbsp;indefinitely&amp;nbsp;for&amp;nbsp;the&amp;nbsp;lock,&amp;nbsp;we&amp;nbsp;can&amp;nbsp;use&amp;nbsp;tryLock()&amp;nbsp;to&amp;nbsp;make&amp;nbsp;sure&lt;br&gt;
thread&amp;nbsp;waits&amp;nbsp;for&amp;nbsp;specific&amp;nbsp;time&amp;nbsp;only.&lt;br&gt;
-&amp;nbsp;Synchronization&amp;nbsp;code&amp;nbsp;is&amp;nbsp;much&amp;nbsp;cleaner&amp;nbsp;and&amp;nbsp;easy&amp;nbsp;to&amp;nbsp;maintain&amp;nbsp;whereas&amp;nbsp;with&amp;nbsp;Lock&amp;nbsp;we&amp;nbsp;are&lt;br&gt;
forced&amp;nbsp;to&amp;nbsp;have&amp;nbsp;try-finally&amp;nbsp;block&amp;nbsp;to&amp;nbsp;make&amp;nbsp;sure&amp;nbsp;Lock&amp;nbsp;is&amp;nbsp;released&amp;nbsp;even&amp;nbsp;if&amp;nbsp;some&amp;nbsp;exception&amp;nbsp;is&lt;br&gt;
thrown&amp;nbsp;between&amp;nbsp;lock()&amp;nbsp;and&amp;nbsp;unlock()&amp;nbsp;method&amp;nbsp;calls.&lt;br&gt;
-&amp;nbsp;synchronization&amp;nbsp;blocks&amp;nbsp;or&amp;nbsp;methods&amp;nbsp;can&amp;nbsp;cover&amp;nbsp;only&amp;nbsp;one&amp;nbsp;method&amp;nbsp;whereas&amp;nbsp;we&amp;nbsp;can&amp;nbsp;acquire&lt;br&gt;
the&amp;nbsp;lock&amp;nbsp;in&amp;nbsp;one&amp;nbsp;method&amp;nbsp;and&amp;nbsp;release&amp;nbsp;it&amp;nbsp;in&amp;nbsp;another&amp;nbsp;method&amp;nbsp;with&amp;nbsp;Lock&amp;nbsp;API.&lt;br&gt;
-&amp;nbsp;synchronized&amp;nbsp;keyword&amp;nbsp;doesn’t&amp;nbsp;provide&amp;nbsp;fairness&amp;nbsp;whereas&amp;nbsp;we&amp;nbsp;can&amp;nbsp;set&amp;nbsp;fairness&amp;nbsp;to&amp;nbsp;true&amp;nbsp;while&lt;br&gt;
creating&amp;nbsp;ReentrantLock&amp;nbsp;object&amp;nbsp;so&amp;nbsp;that&amp;nbsp;longest&amp;nbsp;waiting&amp;nbsp;thread&amp;nbsp;gets&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;first.&lt;br&gt;
-&amp;nbsp;We&amp;nbsp;can&amp;nbsp;create&amp;nbsp;different&amp;nbsp;CONDITIONS&amp;nbsp;for&amp;nbsp;Lock&amp;nbsp;and&amp;nbsp;different&amp;nbsp;thread&amp;nbsp;can&amp;nbsp;await()&amp;nbsp;for&lt;br&gt;
different&amp;nbsp;conditions.&lt;br&gt;
&lt;br&gt;
!!!!&lt;br&gt;
Some&amp;nbsp;important&amp;nbsp;interfaces&amp;nbsp;and&amp;nbsp;classes&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;Concurrency&amp;nbsp;Lock&amp;nbsp;API&amp;nbsp;are:&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Lock:&amp;nbsp;This&amp;nbsp;is&amp;nbsp;the&amp;nbsp;base&amp;nbsp;interface&amp;nbsp;for&amp;nbsp;Lock&amp;nbsp;API.&amp;nbsp;It&amp;nbsp;provides&amp;nbsp;all&amp;nbsp;the&amp;nbsp;features&amp;nbsp;of&amp;nbsp;synchronized&lt;br&gt;
keyword&amp;nbsp;with&amp;nbsp;additional&amp;nbsp;ways&amp;nbsp;to&amp;nbsp;create&amp;nbsp;different&amp;nbsp;Conditions&amp;nbsp;for&amp;nbsp;locking,&amp;nbsp;providing&amp;nbsp;timeout&lt;br&gt;
for&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;lock.&amp;nbsp;Some&amp;nbsp;of&amp;nbsp;the&amp;nbsp;important&amp;nbsp;methods&amp;nbsp;are&amp;nbsp;lock()&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock,&lt;br&gt;
unlock()&amp;nbsp;to&amp;nbsp;release&amp;nbsp;the&amp;nbsp;lock,&amp;nbsp;tryLock()&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;lock&amp;nbsp;for&amp;nbsp;a&amp;nbsp;certain&amp;nbsp;period&amp;nbsp;of&amp;nbsp;time,&lt;br&gt;
newCondition()&amp;nbsp;to&amp;nbsp;create&amp;nbsp;the&amp;nbsp;Condition&amp;nbsp;etc.&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;Condition:&amp;nbsp;Condition&amp;nbsp;objects&amp;nbsp;are&amp;nbsp;similar&amp;nbsp;to&amp;nbsp;Object&amp;nbsp;wait-notify&amp;nbsp;model&amp;nbsp;with&amp;nbsp;additional&lt;br&gt;
feature&amp;nbsp;to&amp;nbsp;create&amp;nbsp;different&amp;nbsp;sets&amp;nbsp;of&amp;nbsp;wait.&amp;nbsp;A&amp;nbsp;Condition&amp;nbsp;object&amp;nbsp;is&amp;nbsp;always&amp;nbsp;created&amp;nbsp;by&amp;nbsp;Lock&amp;nbsp;object.&lt;br&gt;
Some&amp;nbsp;of&amp;nbsp;the&amp;nbsp;important&amp;nbsp;methods&amp;nbsp;are&amp;nbsp;await()&amp;nbsp;that&amp;nbsp;is&amp;nbsp;similar&amp;nbsp;to&amp;nbsp;wait()&amp;nbsp;and&amp;nbsp;signal(),&amp;nbsp;signalAll()&lt;br&gt;
that&amp;nbsp;is&amp;nbsp;similar&amp;nbsp;to&amp;nbsp;notify()&amp;nbsp;and&amp;nbsp;notifyAll()&amp;nbsp;methods.&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;ReadWriteLock:&amp;nbsp;It&amp;nbsp;contains&amp;nbsp;a&amp;nbsp;pair&amp;nbsp;of&amp;nbsp;associated&amp;nbsp;locks,&amp;nbsp;one&amp;nbsp;for&amp;nbsp;read-only&amp;nbsp;operations&amp;nbsp;and&lt;br&gt;
another&amp;nbsp;one&amp;nbsp;for&amp;nbsp;writing.&amp;nbsp;The&amp;nbsp;read&amp;nbsp;lock&amp;nbsp;may&amp;nbsp;be&amp;nbsp;held&amp;nbsp;simultaneously&amp;nbsp;by&amp;nbsp;multiple&amp;nbsp;reader&lt;br&gt;
threads&amp;nbsp;as&amp;nbsp;long&amp;nbsp;as&amp;nbsp;there&amp;nbsp;are&amp;nbsp;no&amp;nbsp;writer&amp;nbsp;threads.&amp;nbsp;The&amp;nbsp;write&amp;nbsp;lock&amp;nbsp;is&amp;nbsp;exclusive.&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;ReentrantLock:&amp;nbsp;This&amp;nbsp;is&amp;nbsp;the&amp;nbsp;most&amp;nbsp;widely&amp;nbsp;used&amp;nbsp;implementation&amp;nbsp;class&amp;nbsp;of&amp;nbsp;Lock&amp;nbsp;interface.&lt;br&gt;
This&amp;nbsp;class&amp;nbsp;implements&amp;nbsp;the&amp;nbsp;Lock&amp;nbsp;interface&amp;nbsp;in&amp;nbsp;similar&amp;nbsp;way&amp;nbsp;as&amp;nbsp;synchronized&amp;nbsp;keyword.&amp;nbsp;Apart&lt;br&gt;
from&amp;nbsp;Lock&amp;nbsp;interface&amp;nbsp;implementation,&amp;nbsp;ReentrantLock&amp;nbsp;contains&amp;nbsp;some&amp;nbsp;utility&amp;nbsp;methods&amp;nbsp;to&amp;nbsp;get&lt;br&gt;
the&amp;nbsp;thread&amp;nbsp;holding&amp;nbsp;the&amp;nbsp;lock,&amp;nbsp;threads&amp;nbsp;waiting&amp;nbsp;to&amp;nbsp;acquire&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;etc.&lt;br&gt;
synchronized&amp;nbsp;block&amp;nbsp;are&amp;nbsp;reentrant&amp;nbsp;in&amp;nbsp;nature&amp;nbsp;i.e&amp;nbsp;if&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;the&amp;nbsp;monitor&amp;nbsp;object&lt;br&gt;
and&amp;nbsp;if&amp;nbsp;another&amp;nbsp;synchronized&amp;nbsp;block&amp;nbsp;requires&amp;nbsp;to&amp;nbsp;have&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;on&amp;nbsp;the&amp;nbsp;same&amp;nbsp;monitor&amp;nbsp;object&amp;nbsp;then&amp;nbsp;thread&lt;br&gt;
can&amp;nbsp;enter&amp;nbsp;that&amp;nbsp;code&amp;nbsp;block.&amp;nbsp;I&amp;nbsp;think&amp;nbsp;this&amp;nbsp;is&amp;nbsp;the&amp;nbsp;reason&amp;nbsp;for&amp;nbsp;the&amp;nbsp;class&amp;nbsp;name&amp;nbsp;to&amp;nbsp;be&amp;nbsp;ReentrantLock.&lt;br&gt;
&lt;br&gt;
=====================================================&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Conditions&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;lock&amp;nbsp;may&amp;nbsp;be&amp;nbsp;associated&amp;nbsp;with&amp;nbsp;one&amp;nbsp;or&amp;nbsp;more&amp;nbsp;conditions.&amp;nbsp;These&amp;nbsp;conditions&amp;nbsp;are&amp;nbsp;declared&amp;nbsp;in&lt;br&gt;
the&amp;nbsp;Condition&amp;nbsp;interface.&amp;nbsp;The&amp;nbsp;purpose&amp;nbsp;of&amp;nbsp;these&amp;nbsp;conditions&amp;nbsp;is&amp;nbsp;to&amp;nbsp;allow&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;have&lt;br&gt;
control&amp;nbsp;of&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;and&amp;nbsp;check&amp;nbsp;whether&amp;nbsp;a&amp;nbsp;condition&amp;nbsp;is&amp;nbsp;true&amp;nbsp;or&amp;nbsp;not&amp;nbsp;and,&amp;nbsp;if&amp;nbsp;it's&amp;nbsp;false,&amp;nbsp;be&lt;br&gt;
suspended&amp;nbsp;until&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;wakes&amp;nbsp;them&amp;nbsp;up.&amp;nbsp;The&amp;nbsp;Condition&amp;nbsp;interface&amp;nbsp;provides&amp;nbsp;the&lt;br&gt;
mechanisms&amp;nbsp;to&amp;nbsp;suspend&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;and&amp;nbsp;to&amp;nbsp;wake&amp;nbsp;up&amp;nbsp;a&amp;nbsp;suspended&amp;nbsp;thread.&lt;br&gt;
&lt;br&gt;
To&amp;nbsp;complete&amp;nbsp;the&amp;nbsp;picture&amp;nbsp;of&amp;nbsp;Lock&amp;nbsp;as&amp;nbsp;a&amp;nbsp;parallel&amp;nbsp;for&amp;nbsp;Java&amp;nbsp;language&amp;nbsp;synchronization,&amp;nbsp;we&lt;br&gt;
need&amp;nbsp;an&amp;nbsp;analog&amp;nbsp;to&amp;nbsp;the&amp;nbsp;wait(),&amp;nbsp;notify(),&amp;nbsp;and&amp;nbsp;notifyAll()mechanism.&amp;nbsp;The&amp;nbsp;Condition&lt;br&gt;
interface&amp;nbsp;represents&amp;nbsp;this&amp;nbsp;functionality&amp;nbsp;with&amp;nbsp;its&amp;nbsp;await(),&amp;nbsp;signal(),&amp;nbsp;and&amp;nbsp;signalAll()&lt;br&gt;
methods.&amp;nbsp;A&amp;nbsp;Condition&amp;nbsp;is&amp;nbsp;associated&amp;nbsp;with&amp;nbsp;a&amp;nbsp;Lock&amp;nbsp;by&amp;nbsp;the&amp;nbsp;lock’s&amp;nbsp;newCondition()&lt;br&gt;
method.&amp;nbsp;Unlike&amp;nbsp;a&amp;nbsp;normal&amp;nbsp;Java&amp;nbsp;lock,&amp;nbsp;a&amp;nbsp;Lock&amp;nbsp;may&amp;nbsp;have&amp;nbsp;multiple&amp;nbsp;Condition&amp;nbsp;objects&amp;nbsp;that&lt;br&gt;
represent&amp;nbsp;multiple&amp;nbsp;wait&amp;nbsp;sets&amp;nbsp;of&amp;nbsp;threads.&amp;nbsp;The&amp;nbsp;Condition&amp;nbsp;await()&amp;nbsp;method&amp;nbsp;is&amp;nbsp;used&amp;nbsp;just&amp;nbsp;like&amp;nbsp;the&lt;br&gt;
wait()&amp;nbsp;method&amp;nbsp;of&amp;nbsp;a&amp;nbsp;Java&amp;nbsp;object&amp;nbsp;within&amp;nbsp;a&amp;nbsp;synchronized&amp;nbsp;block:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;Lock&amp;nbsp;lock&amp;nbsp;=&amp;nbsp;...&lt;br&gt;
&amp;nbsp;Condition&amp;nbsp;condition&amp;nbsp;=&amp;nbsp;lock.newCondition();&lt;br&gt;
&amp;nbsp;lock.lock();&lt;br&gt;
&amp;nbsp;condition.await();&amp;nbsp;//&amp;nbsp;block,&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;signal()&lt;br&gt;
&amp;nbsp;lock.unlock();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;//&amp;nbsp;meanwhile,&amp;nbsp;in&amp;nbsp;another&amp;nbsp;thread...&lt;br&gt;
&amp;nbsp;lock.lock();&lt;br&gt;
&amp;nbsp;condition.signal();&lt;br&gt;
&amp;nbsp;lock.unlock();&lt;br&gt;
&lt;br&gt;
Like&amp;nbsp;wait(),&amp;nbsp;the&amp;nbsp;Condition&amp;nbsp;await()&amp;nbsp;method&amp;nbsp;can&amp;nbsp;be&amp;nbsp;called&amp;nbsp;only&amp;nbsp;when&amp;nbsp;the&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;the&lt;br&gt;
owner&amp;nbsp;of&amp;nbsp;the&amp;nbsp;lock&amp;nbsp;associated&amp;nbsp;with&amp;nbsp;the&amp;nbsp;condition&amp;nbsp;and&amp;nbsp;the&amp;nbsp;signal()&amp;nbsp;method&amp;nbsp;may&amp;nbsp;be&lt;br&gt;
called&amp;nbsp;only&amp;nbsp;by&amp;nbsp;another&amp;nbsp;thread&amp;nbsp;that&amp;nbsp;has&amp;nbsp;acquired&amp;nbsp;the&amp;nbsp;lock.&amp;nbsp;Interestingly,&amp;nbsp;though,&amp;nbsp;in&lt;br&gt;
this&amp;nbsp;case,&amp;nbsp;these&amp;nbsp;restrictions&amp;nbsp;are&amp;nbsp;implementation&amp;nbsp;details&amp;nbsp;of&amp;nbsp;the&amp;nbsp;java.util.concurrent&lt;br&gt;
package;&amp;nbsp;some&amp;nbsp;other&amp;nbsp;implementation&amp;nbsp;of&amp;nbsp;these&amp;nbsp;classes&amp;nbsp;could&amp;nbsp;conceivably&amp;nbsp;change&lt;br&gt;
those&amp;nbsp;restrictions&amp;nbsp;in&amp;nbsp;some&amp;nbsp;way.&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:25" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;What&amp;nbsp;is&amp;nbsp;atomic&amp;nbsp;operation?&amp;nbsp;What&amp;nbsp;are&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;atomic&amp;nbsp;classes&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;Concurrency&amp;nbsp;API?&lt;br&gt;
Describe&amp;nbsp;CAS&amp;nbsp;Principle.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
&lt;img&amp;nbsp;width='700'&amp;nbsp;height='624'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/AtomicsPackage.png'/&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Atomic&amp;nbsp;operations&amp;nbsp;are&amp;nbsp;performed&amp;nbsp;in&amp;nbsp;a&amp;nbsp;single&amp;nbsp;unit&amp;nbsp;of&amp;nbsp;task&amp;nbsp;without&amp;nbsp;interference&amp;nbsp;from&amp;nbsp;other&lt;br&gt;
operations.&amp;nbsp;Atomic&amp;nbsp;operations&amp;nbsp;are&amp;nbsp;necessity&amp;nbsp;in&amp;nbsp;multi-threaded&amp;nbsp;environment&amp;nbsp;to&amp;nbsp;avoid&amp;nbsp;data&lt;br&gt;
inconsistency.&lt;br&gt;
&lt;br&gt;
&amp;nbsp;'int++'&amp;nbsp;&amp;nbsp;is&amp;nbsp;not&amp;nbsp;an&amp;nbsp;atomic&amp;nbsp;operation.&amp;nbsp;So&amp;nbsp;by&amp;nbsp;the&amp;nbsp;time&amp;nbsp;one&amp;nbsp;threads&amp;nbsp;read&amp;nbsp;it’s&amp;nbsp;value&amp;nbsp;and&lt;br&gt;
increment&amp;nbsp;it&amp;nbsp;by&amp;nbsp;one,&amp;nbsp;other&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;read&amp;nbsp;the&amp;nbsp;older&amp;nbsp;value&amp;nbsp;leading&amp;nbsp;to&amp;nbsp;wrong&amp;nbsp;result.&lt;br&gt;
&lt;br&gt;
To&amp;nbsp;solve&amp;nbsp;this&amp;nbsp;issue,&amp;nbsp;we&amp;nbsp;will&amp;nbsp;have&amp;nbsp;to&amp;nbsp;make&amp;nbsp;sure&amp;nbsp;that&amp;nbsp;increment&amp;nbsp;operation&amp;nbsp;on&amp;nbsp;count&amp;nbsp;is&lt;br&gt;
atomic,&amp;nbsp;we&amp;nbsp;can&amp;nbsp;do&amp;nbsp;that&amp;nbsp;using&amp;nbsp;Synchronization&amp;nbsp;but&amp;nbsp;Java&amp;nbsp;5&amp;nbsp;java.util.concurrent.atomic&lt;br&gt;
provides&amp;nbsp;wrapper&amp;nbsp;classes&amp;nbsp;for&amp;nbsp;int&amp;nbsp;and&amp;nbsp;long&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;achieve&amp;nbsp;this&amp;nbsp;atomically&lt;br&gt;
without&amp;nbsp;usage&amp;nbsp;of&amp;nbsp;Synchronization.&amp;nbsp;&lt;br&gt;
&lt;br&gt;
===============================================&lt;br&gt;
From&amp;nbsp;DOCUMENTATION&lt;br&gt;
Package&amp;nbsp;java.util.concurrent.atomic&amp;nbsp;Description&lt;br&gt;
&lt;br&gt;
A&amp;nbsp;small&amp;nbsp;toolkit&amp;nbsp;of&amp;nbsp;classes&amp;nbsp;that&amp;nbsp;support&amp;nbsp;lock-free&amp;nbsp;thread-safe&amp;nbsp;programming&amp;nbsp;on&amp;nbsp;single&lt;br&gt;
variables.&amp;nbsp;In&amp;nbsp;essence,&amp;nbsp;the&amp;nbsp;classes&amp;nbsp;in&amp;nbsp;this&amp;nbsp;package&amp;nbsp;extend&amp;nbsp;the&amp;nbsp;notion&amp;nbsp;of&amp;nbsp;volatile&amp;nbsp;values,&lt;br&gt;
fields,&amp;nbsp;and&amp;nbsp;array&amp;nbsp;elements&amp;nbsp;to&amp;nbsp;those&amp;nbsp;that&amp;nbsp;also&amp;nbsp;provide&amp;nbsp;an&amp;nbsp;atomic&amp;nbsp;conditional&amp;nbsp;update&lt;br&gt;
operation&amp;nbsp;of&amp;nbsp;the&amp;nbsp;form:&lt;br&gt;
&lt;br&gt;
boolean&amp;nbsp;compareAndSet(expectedValue,&amp;nbsp;updateValue);&lt;br&gt;
&lt;br&gt;
This&amp;nbsp;method&amp;nbsp;(which&amp;nbsp;varies&amp;nbsp;in&amp;nbsp;argument&amp;nbsp;types&amp;nbsp;across&amp;nbsp;different&amp;nbsp;classes)&amp;nbsp;atomically&amp;nbsp;sets&amp;nbsp;a&lt;br&gt;
variable&amp;nbsp;to&amp;nbsp;the&amp;nbsp;updateValue&amp;nbsp;if&amp;nbsp;it&amp;nbsp;currently&amp;nbsp;holds&amp;nbsp;the&amp;nbsp;expectedValue,&amp;nbsp;reporting&amp;nbsp;true&amp;nbsp;on&lt;br&gt;
success.&amp;nbsp;The&amp;nbsp;classes&amp;nbsp;in&amp;nbsp;this&amp;nbsp;package&amp;nbsp;also&amp;nbsp;contain&amp;nbsp;methods&amp;nbsp;to&amp;nbsp;get&amp;nbsp;and&amp;nbsp;unconditionally&amp;nbsp;set&lt;br&gt;
values,&amp;nbsp;as&amp;nbsp;well&amp;nbsp;as&amp;nbsp;a&amp;nbsp;weaker&amp;nbsp;conditional&amp;nbsp;atomic&amp;nbsp;update&amp;nbsp;operation&amp;nbsp;weakCompareAndSet&amp;nbsp;described&lt;br&gt;
below.&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;specifications&amp;nbsp;of&amp;nbsp;these&amp;nbsp;methods&amp;nbsp;enable&amp;nbsp;implementations&amp;nbsp;to&amp;nbsp;employ&amp;nbsp;efficient&lt;br&gt;
machine-level&amp;nbsp;atomic&amp;nbsp;instructions&amp;nbsp;that&amp;nbsp;are&amp;nbsp;available&amp;nbsp;on&amp;nbsp;contemporary&amp;nbsp;processors.&lt;br&gt;
However&amp;nbsp;on&amp;nbsp;some&amp;nbsp;platforms,&amp;nbsp;support&amp;nbsp;may&amp;nbsp;entail&amp;nbsp;some&amp;nbsp;form&amp;nbsp;of&amp;nbsp;internal&amp;nbsp;locking.&amp;nbsp;Thus&lt;br&gt;
the&amp;nbsp;methods&amp;nbsp;are&amp;nbsp;not&amp;nbsp;strictly&amp;nbsp;guaranteed&amp;nbsp;to&amp;nbsp;be&amp;nbsp;non-blocking&amp;nbsp;--&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;may&amp;nbsp;block&lt;br&gt;
transiently&amp;nbsp;before&amp;nbsp;performing&amp;nbsp;the&amp;nbsp;operation.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Instances&amp;nbsp;of&amp;nbsp;classes&amp;nbsp;AtomicBoolean,&amp;nbsp;AtomicInteger,&amp;nbsp;AtomicLong,&amp;nbsp;and&amp;nbsp;AtomicReference&amp;nbsp;each&lt;br&gt;
provide&amp;nbsp;access&amp;nbsp;and&amp;nbsp;updates&amp;nbsp;to&amp;nbsp;a&amp;nbsp;single&amp;nbsp;variable&amp;nbsp;of&amp;nbsp;the&amp;nbsp;corresponding&amp;nbsp;type.&amp;nbsp;Each&amp;nbsp;class&lt;br&gt;
also&amp;nbsp;provides&amp;nbsp;appropriate&amp;nbsp;utility&amp;nbsp;methods&amp;nbsp;for&amp;nbsp;that&amp;nbsp;type.&amp;nbsp;For&amp;nbsp;example,&amp;nbsp;classes&amp;nbsp;AtomicLong&lt;br&gt;
and&amp;nbsp;AtomicInteger&amp;nbsp;provide&amp;nbsp;atomic&amp;nbsp;increment&amp;nbsp;methods.&amp;nbsp;One&amp;nbsp;application&amp;nbsp;is&amp;nbsp;to&amp;nbsp;generate&lt;br&gt;
sequence&amp;nbsp;numbers,&amp;nbsp;as&amp;nbsp;in:&lt;br&gt;
&amp;nbsp;&lt;br&gt;
&amp;nbsp;class&amp;nbsp;Sequencer&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;final&amp;nbsp;AtomicLong&amp;nbsp;sequenceNumber&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;=&amp;nbsp;new&amp;nbsp;AtomicLong(0);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;long&amp;nbsp;next()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;sequenceNumber.getAndIncrement();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
====================&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Classes&amp;nbsp;in&amp;nbsp;java.util.concurrent.atomic&amp;nbsp;package:&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;AtomicBoolean&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
A&amp;nbsp;boolean&amp;nbsp;value&amp;nbsp;that&amp;nbsp;may&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;AtomicInteger&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
An&amp;nbsp;int&amp;nbsp;value&amp;nbsp;that&amp;nbsp;may&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;AtomicIntegerArray&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
An&amp;nbsp;int&amp;nbsp;array&amp;nbsp;in&amp;nbsp;which&amp;nbsp;elements&amp;nbsp;may&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;AtomicIntegerFieldUpdater&lt;T&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
A&amp;nbsp;reflection-based&amp;nbsp;utility&amp;nbsp;that&amp;nbsp;enables&amp;nbsp;atomic&amp;nbsp;updates&amp;nbsp;to&amp;nbsp;designated&amp;nbsp;volatile&amp;nbsp;int&lt;br&gt;
fields&amp;nbsp;of&amp;nbsp;designated&amp;nbsp;classes.&lt;br&gt;
-&amp;nbsp;AtomicLong&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
A&amp;nbsp;long&amp;nbsp;value&amp;nbsp;that&amp;nbsp;may&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;AtomicLongArray&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
A&amp;nbsp;long&amp;nbsp;array&amp;nbsp;in&amp;nbsp;which&amp;nbsp;elements&amp;nbsp;may&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;AtomicLongFieldUpdater&lt;T&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
A&amp;nbsp;reflection-based&amp;nbsp;utility&amp;nbsp;that&amp;nbsp;enables&amp;nbsp;atomic&amp;nbsp;updates&amp;nbsp;to&amp;nbsp;designated&amp;nbsp;volatile&amp;nbsp;long&lt;br&gt;
fields&amp;nbsp;of&amp;nbsp;designated&amp;nbsp;classes.&lt;br&gt;
-&amp;nbsp;AtomicMarkableReference&lt;V&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
An&amp;nbsp;AtomicMarkableReference&amp;nbsp;maintains&amp;nbsp;an&amp;nbsp;object&amp;nbsp;reference&amp;nbsp;along&amp;nbsp;with&amp;nbsp;a&amp;nbsp;mark&amp;nbsp;bit,&lt;br&gt;
that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;AtomicReference&lt;V&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
An&amp;nbsp;object&amp;nbsp;reference&amp;nbsp;that&amp;nbsp;may&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;AtomicReferenceArray&lt;E&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
An&amp;nbsp;array&amp;nbsp;of&amp;nbsp;object&amp;nbsp;references&amp;nbsp;in&amp;nbsp;which&amp;nbsp;elements&amp;nbsp;may&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;AtomicReferenceFieldUpdater&lt;T,V&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
A&amp;nbsp;reflection-based&amp;nbsp;utility&amp;nbsp;that&amp;nbsp;enables&amp;nbsp;atomic&amp;nbsp;updates&amp;nbsp;to&amp;nbsp;designated&lt;br&gt;
volatile&amp;nbsp;reference&amp;nbsp;fields&amp;nbsp;of&amp;nbsp;designated&amp;nbsp;classes.&lt;br&gt;
-&amp;nbsp;AtomicStampedReference&lt;V&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
An&amp;nbsp;AtomicStampedReference&amp;nbsp;maintains&amp;nbsp;an&amp;nbsp;object&amp;nbsp;reference&amp;nbsp;along&amp;nbsp;with&amp;nbsp;an&lt;br&gt;
integer&amp;nbsp;"stamp",&amp;nbsp;that&amp;nbsp;can&amp;nbsp;be&amp;nbsp;updated&amp;nbsp;atomically.&lt;br&gt;
-&amp;nbsp;DoubleAccumulator&amp;nbsp;1.8&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
One&amp;nbsp;or&amp;nbsp;more&amp;nbsp;variables&amp;nbsp;that&amp;nbsp;together&amp;nbsp;maintain&amp;nbsp;a&amp;nbsp;running&amp;nbsp;double&amp;nbsp;value&lt;br&gt;
updated&amp;nbsp;using&amp;nbsp;a&amp;nbsp;supplied&amp;nbsp;function.&lt;br&gt;
-&amp;nbsp;DoubleAdder&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.8&lt;br&gt;
One&amp;nbsp;or&amp;nbsp;more&amp;nbsp;variables&amp;nbsp;that&amp;nbsp;together&amp;nbsp;maintain&amp;nbsp;an&amp;nbsp;initially&amp;nbsp;zero&amp;nbsp;double&amp;nbsp;sum.&lt;br&gt;
-&amp;nbsp;LongAccumulator&amp;nbsp;1.8&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
One&amp;nbsp;or&amp;nbsp;more&amp;nbsp;variables&amp;nbsp;that&amp;nbsp;together&amp;nbsp;maintain&amp;nbsp;a&amp;nbsp;running&amp;nbsp;long&amp;nbsp;value&amp;nbsp;updated&lt;br&gt;
using&amp;nbsp;a&amp;nbsp;supplied&amp;nbsp;function.&lt;br&gt;
-&amp;nbsp;LongAdder&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.8&lt;br&gt;
One&amp;nbsp;or&amp;nbsp;more&amp;nbsp;variables&amp;nbsp;that&amp;nbsp;together&amp;nbsp;maintain&amp;nbsp;an&amp;nbsp;initially&amp;nbsp;zero&amp;nbsp;long&amp;nbsp;sum.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
====================================&lt;br&gt;
To&amp;nbsp;see&amp;nbsp;how&amp;nbsp;this&amp;nbsp;package&amp;nbsp;might&amp;nbsp;be&amp;nbsp;used,&amp;nbsp;let's&amp;nbsp;return&amp;nbsp;to&amp;nbsp;the&amp;nbsp;Counter&amp;nbsp;class&amp;nbsp;we&lt;br&gt;
originally&amp;nbsp;used&amp;nbsp;to&amp;nbsp;demonstrate&amp;nbsp;thread&amp;nbsp;interference:&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Counter&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;int&amp;nbsp;c&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;increment()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c++;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;decrement()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c--;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;int&amp;nbsp;value()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;c;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
One&amp;nbsp;way&amp;nbsp;to&amp;nbsp;make&amp;nbsp;Counter&amp;nbsp;safe&amp;nbsp;from&amp;nbsp;thread&amp;nbsp;interference&amp;nbsp;is&amp;nbsp;to&amp;nbsp;make&amp;nbsp;its&amp;nbsp;methods&lt;br&gt;
synchronized,&amp;nbsp;as&amp;nbsp;in&amp;nbsp;SynchronizedCounter:&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;SynchronizedCounter&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;int&amp;nbsp;c&amp;nbsp;=&amp;nbsp;0;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;increment()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c++;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;void&amp;nbsp;decrement()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c--;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;synchronized&amp;nbsp;int&amp;nbsp;value()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;c;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
For&amp;nbsp;this&amp;nbsp;simple&amp;nbsp;class,&amp;nbsp;synchronization&amp;nbsp;is&amp;nbsp;an&amp;nbsp;acceptable&amp;nbsp;solution.&amp;nbsp;But&amp;nbsp;for&amp;nbsp;a&amp;nbsp;more&lt;br&gt;
complicated&amp;nbsp;class,&amp;nbsp;we&amp;nbsp;might&amp;nbsp;want&amp;nbsp;to&amp;nbsp;avoid&amp;nbsp;the&amp;nbsp;liveness&amp;nbsp;impact&amp;nbsp;of&amp;nbsp;unnecessary&lt;br&gt;
synchronization.&amp;nbsp;Replacing&amp;nbsp;the&amp;nbsp;int&amp;nbsp;field&amp;nbsp;with&amp;nbsp;an&amp;nbsp;AtomicInteger&amp;nbsp;allows&amp;nbsp;us&amp;nbsp;to&amp;nbsp;prevent&lt;br&gt;
thread&amp;nbsp;interference&amp;nbsp;without&amp;nbsp;resorting&amp;nbsp;to&amp;nbsp;synchronization,&amp;nbsp;as&amp;nbsp;in&amp;nbsp;AtomicCounter:&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.atomic.AtomicInteger;&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;AtomicCounter&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;AtomicInteger&amp;nbsp;c&amp;nbsp;=&amp;nbsp;new&amp;nbsp;AtomicInteger(0);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;increment()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c.incrementAndGet();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;decrement()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c.decrementAndGet();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;int&amp;nbsp;value()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;c.get();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
===============&lt;br&gt;
Example&amp;nbsp;WITHOUT&amp;nbsp;Atomic&amp;nbsp;variables&amp;nbsp;(bad&amp;nbsp;code)&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;Example1WithoutAtomics&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;&amp;nbsp;main(String[]&amp;nbsp;arg)&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Use&amp;nbsp;atomics");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ProcessingThread&amp;nbsp;pt&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ProcessingThread();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(pt,&amp;nbsp;"t1");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(pt,&amp;nbsp;"t2");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.start();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.join();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.join();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Processing&amp;nbsp;count="&amp;nbsp;+&amp;nbsp;pt.getCount());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;ProcessingThread&amp;nbsp;implements&amp;nbsp;Runnable{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;int&amp;nbsp;count;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;1&amp;nbsp;;i&lt;5;i++){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;processSomething(i);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;count++;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;int&amp;nbsp;getCount(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;this.count;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;void&amp;nbsp;processSomething(int&amp;nbsp;i){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(i&amp;nbsp;*&amp;nbsp;1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
====&lt;br&gt;
OUTPUT&amp;nbsp;:&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;If&amp;nbsp;you&amp;nbsp;will&amp;nbsp;run&amp;nbsp;above&amp;nbsp;program,&amp;nbsp;you&amp;nbsp;will&amp;nbsp;notice&amp;nbsp;that&amp;nbsp;count&amp;nbsp;value&amp;nbsp;varies&amp;nbsp;between&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;5,6,7,8.&amp;nbsp;The&amp;nbsp;reason&amp;nbsp;is&amp;nbsp;because&amp;nbsp;count++&amp;nbsp;is&amp;nbsp;not&amp;nbsp;an&amp;nbsp;atomic&amp;nbsp;operation.&amp;nbsp;So&amp;nbsp;by&amp;nbsp;the&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;time&amp;nbsp;one&amp;nbsp;threads&amp;nbsp;read&amp;nbsp;it’s&amp;nbsp;value&amp;nbsp;and&amp;nbsp;increment&amp;nbsp;it&amp;nbsp;by&amp;nbsp;one,&amp;nbsp;other&amp;nbsp;thread&amp;nbsp;has&amp;nbsp;read&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;the&amp;nbsp;older&amp;nbsp;value&amp;nbsp;leading&amp;nbsp;to&amp;nbsp;wrong&amp;nbsp;result.&lt;br&gt;
&lt;br&gt;
==============&lt;br&gt;
Example&amp;nbsp;WITH&amp;nbsp;Atomic&amp;nbsp;variables&amp;nbsp;(good&amp;nbsp;code&amp;nbsp;)&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;java_enum;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.atomic.AtomicInteger;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;Example1WithAtomics&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;&amp;nbsp;main(String[]&amp;nbsp;arg)&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Use&amp;nbsp;atomics");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ProcessingThread&amp;nbsp;pt&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ProcessingThread();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(pt,&amp;nbsp;"t1");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread&amp;nbsp;t2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Thread(pt,&amp;nbsp;"t2");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.start();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.join();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t2.join();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Processing&amp;nbsp;count="&amp;nbsp;+&amp;nbsp;pt.getCount());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;ProcessingThreadAtomic&amp;nbsp;implements&amp;nbsp;Runnable{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;AtomicInteger&amp;nbsp;count&amp;nbsp;=&amp;nbsp;new&amp;nbsp;AtomicInteger(0);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;1&amp;nbsp;;i&lt;5;i++){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;processSomething(i);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;count.incrementAndGet();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;int&amp;nbsp;getCount(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;this.count.get();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;void&amp;nbsp;processSomething(int&amp;nbsp;i){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(i&amp;nbsp;*&amp;nbsp;1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
8&lt;br&gt;
======================================&lt;br&gt;
Compare&amp;nbsp;And&amp;nbsp;Swap&amp;nbsp;&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;computer&amp;nbsp;science,&amp;nbsp;compare-and-swap&amp;nbsp;(CAS)&amp;nbsp;is&amp;nbsp;an&amp;nbsp;atomic&amp;nbsp;instruction&amp;nbsp;used&lt;br&gt;
in&amp;nbsp;multithreading&amp;nbsp;to&amp;nbsp;achieve&amp;nbsp;synchronization.&amp;nbsp;It&amp;nbsp;compares&amp;nbsp;the&amp;nbsp;contents&amp;nbsp;of&amp;nbsp;a&lt;br&gt;
memory&amp;nbsp;location&amp;nbsp;to&amp;nbsp;a&amp;nbsp;given&amp;nbsp;value&amp;nbsp;and,&amp;nbsp;__only&amp;nbsp;if&amp;nbsp;they&amp;nbsp;are&amp;nbsp;the&amp;nbsp;same,&amp;nbsp;__&amp;nbsp;modifies&amp;nbsp;the&lt;br&gt;
contents&amp;nbsp;of&amp;nbsp;that&amp;nbsp;memory&amp;nbsp;location&amp;nbsp;to&amp;nbsp;a&amp;nbsp;given&amp;nbsp;new&amp;nbsp;value.&amp;nbsp;This&amp;nbsp;is&amp;nbsp;done&amp;nbsp;as&amp;nbsp;a&lt;br&gt;
single&amp;nbsp;atomic&amp;nbsp;operation.&amp;nbsp;The&amp;nbsp;atomicity&amp;nbsp;guarantees&amp;nbsp;that&amp;nbsp;the&amp;nbsp;new&amp;nbsp;value&amp;nbsp;is&amp;nbsp;calculated&lt;br&gt;
based&amp;nbsp;on&amp;nbsp;up-to-date&amp;nbsp;information;&amp;nbsp;if&amp;nbsp;the&amp;nbsp;value&amp;nbsp;had&amp;nbsp;been&amp;nbsp;updated&amp;nbsp;by&amp;nbsp;another&amp;nbsp;thread&lt;br&gt;
in&amp;nbsp;the&amp;nbsp;meantime,&amp;nbsp;the&amp;nbsp;write&amp;nbsp;would&amp;nbsp;fail.&amp;nbsp;The&amp;nbsp;result&amp;nbsp;of&amp;nbsp;the&amp;nbsp;operation&amp;nbsp;must&amp;nbsp;indicate&lt;br&gt;
whether&amp;nbsp;it&amp;nbsp;performed&amp;nbsp;the&amp;nbsp;substitution;&amp;nbsp;this&amp;nbsp;can&amp;nbsp;be&amp;nbsp;done&amp;nbsp;either&amp;nbsp;with&amp;nbsp;a&amp;nbsp;simple&lt;br&gt;
Boolean&amp;nbsp;response&amp;nbsp;(this&amp;nbsp;variant&amp;nbsp;is&amp;nbsp;often&amp;nbsp;called&amp;nbsp;compare-and-set),&amp;nbsp;or&amp;nbsp;by&amp;nbsp;returning&lt;br&gt;
the&amp;nbsp;value&amp;nbsp;read&amp;nbsp;from&amp;nbsp;the&amp;nbsp;memory&amp;nbsp;location&amp;nbsp;(not&amp;nbsp;the&amp;nbsp;value&amp;nbsp;written&amp;nbsp;to&amp;nbsp;it).&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Compare-and-Swap&amp;nbsp;(and&amp;nbsp;Compare-and-Swap-Double)&amp;nbsp;has&amp;nbsp;been&amp;nbsp;an&amp;nbsp;integral&amp;nbsp;part&amp;nbsp;of&amp;nbsp;the&lt;br&gt;
IBM&amp;nbsp;370&amp;nbsp;(and&amp;nbsp;all&amp;nbsp;successor)&amp;nbsp;architectures&amp;nbsp;since&amp;nbsp;1970.&amp;nbsp;The&amp;nbsp;operating&amp;nbsp;systems&amp;nbsp;that&lt;br&gt;
run&amp;nbsp;on&amp;nbsp;these&amp;nbsp;architectures&amp;nbsp;make&amp;nbsp;extensive&amp;nbsp;use&amp;nbsp;of&amp;nbsp;this&amp;nbsp;instruction&amp;nbsp;to&amp;nbsp;facilitate&lt;br&gt;
process&amp;nbsp;(i.e.,&amp;nbsp;system&amp;nbsp;and&amp;nbsp;user&amp;nbsp;tasks)&amp;nbsp;and&amp;nbsp;processor&amp;nbsp;(i.e.,&amp;nbsp;central&amp;nbsp;processors)&lt;br&gt;
parallelism&amp;nbsp;while&amp;nbsp;eliminating,&amp;nbsp;to&amp;nbsp;the&amp;nbsp;greatest&amp;nbsp;degree&amp;nbsp;possible,&amp;nbsp;the&amp;nbsp;"disabled&amp;nbsp;spin&lt;br&gt;
locks"&amp;nbsp;which&amp;nbsp;had&amp;nbsp;been&amp;nbsp;employed&amp;nbsp;in&amp;nbsp;earlier&amp;nbsp;IBM&amp;nbsp;operating&amp;nbsp;systems.&amp;nbsp;Similarly,&amp;nbsp;the&lt;br&gt;
use&amp;nbsp;of&amp;nbsp;Test-and-Set&amp;nbsp;was&amp;nbsp;also&amp;nbsp;eliminated.&amp;nbsp;In&amp;nbsp;these&amp;nbsp;operating&amp;nbsp;systems,&amp;nbsp;new&amp;nbsp;units&amp;nbsp;of&lt;br&gt;
work&amp;nbsp;may&amp;nbsp;be&amp;nbsp;instantiated&amp;nbsp;"globally",&amp;nbsp;into&amp;nbsp;the&amp;nbsp;Global&amp;nbsp;Service&amp;nbsp;Priority&amp;nbsp;List,&amp;nbsp;or&lt;br&gt;
"locally",&amp;nbsp;into&amp;nbsp;the&amp;nbsp;Local&amp;nbsp;Service&amp;nbsp;Priority&amp;nbsp;List,&amp;nbsp;by&amp;nbsp;the&amp;nbsp;execution&amp;nbsp;of&amp;nbsp;a&amp;nbsp;single&lt;br&gt;
Compare-and-Swap&amp;nbsp;instruction.&amp;nbsp;This&amp;nbsp;substantially&amp;nbsp;improved&amp;nbsp;the&amp;nbsp;responsiveness&amp;nbsp;of&lt;br&gt;
these&amp;nbsp;operating&amp;nbsp;systems.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Implementation&amp;nbsp;in&amp;nbsp;C&lt;br&gt;
The&amp;nbsp;following&amp;nbsp;C&amp;nbsp;function&amp;nbsp;shows&amp;nbsp;the&amp;nbsp;basic&amp;nbsp;behavior&amp;nbsp;of&amp;nbsp;a&amp;nbsp;compare-and-swap&amp;nbsp;variant&lt;br&gt;
that&amp;nbsp;returns&amp;nbsp;the&amp;nbsp;old&amp;nbsp;value&amp;nbsp;of&amp;nbsp;the&amp;nbsp;specified&amp;nbsp;memory&amp;nbsp;location;&amp;nbsp;however,&amp;nbsp;this&amp;nbsp;version&lt;br&gt;
does&amp;nbsp;not&amp;nbsp;provide&amp;nbsp;the&amp;nbsp;crucial&amp;nbsp;guarantees&amp;nbsp;of&amp;nbsp;atomicity&amp;nbsp;that&amp;nbsp;a&amp;nbsp;real&amp;nbsp;compare-and-swap&lt;br&gt;
operation&amp;nbsp;would:&lt;br&gt;
int&amp;nbsp;compare_and_swap&amp;nbsp;(int*&amp;nbsp;reg,&amp;nbsp;int&amp;nbsp;oldval,&amp;nbsp;int&amp;nbsp;newval)&amp;nbsp;&lt;br&gt;
{&lt;br&gt;
&amp;nbsp;&amp;nbsp;ATOMIC();&lt;br&gt;
&amp;nbsp;&amp;nbsp;int&amp;nbsp;old_reg_val&amp;nbsp;=&amp;nbsp;*reg;&lt;br&gt;
&amp;nbsp;&amp;nbsp;if&amp;nbsp;(old_reg_val&amp;nbsp;==&amp;nbsp;oldval)&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*reg&amp;nbsp;=&amp;nbsp;newval;&lt;br&gt;
&amp;nbsp;&amp;nbsp;END_ATOMIC();&lt;br&gt;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;old_reg_val;&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
For&amp;nbsp;example,&amp;nbsp;an&amp;nbsp;election&amp;nbsp;protocol&amp;nbsp;can&amp;nbsp;be&amp;nbsp;effected,&amp;nbsp;where&amp;nbsp;every&amp;nbsp;process&amp;nbsp;compares&amp;nbsp;the&lt;br&gt;
result&amp;nbsp;of&amp;nbsp;compare_and_swap&amp;nbsp;with&amp;nbsp;its,&amp;nbsp;let's&amp;nbsp;say,&amp;nbsp;PID&amp;nbsp;(=newval).&amp;nbsp;The&amp;nbsp;winning&amp;nbsp;process&lt;br&gt;
finds&amp;nbsp;the&amp;nbsp;compare_and_swap&amp;nbsp;returning&amp;nbsp;the&amp;nbsp;initial&amp;nbsp;non-PID&amp;nbsp;value&amp;nbsp;(e.g.,&amp;nbsp;zero).&amp;nbsp;For&amp;nbsp;the&lt;br&gt;
losers&amp;nbsp;it&amp;nbsp;will&amp;nbsp;return&amp;nbsp;the&amp;nbsp;winning&amp;nbsp;PID.&lt;br&gt;
bool&amp;nbsp;compare_and_swap&amp;nbsp;(int&amp;nbsp;*accum,&amp;nbsp;int&amp;nbsp;*dest,&amp;nbsp;int&amp;nbsp;newval)&lt;br&gt;
{&lt;br&gt;
&amp;nbsp;&amp;nbsp;if&amp;nbsp;(&amp;nbsp;*accum&amp;nbsp;==&amp;nbsp;*dest&amp;nbsp;)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*dest&amp;nbsp;=&amp;nbsp;newval;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;true;&lt;br&gt;
&amp;nbsp;&amp;nbsp;}&amp;nbsp;else&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*accum&amp;nbsp;=&amp;nbsp;*dest;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;false;&lt;br&gt;
&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
===================================&lt;br&gt;
Atomic&amp;nbsp;arrays&lt;br&gt;
Instead&amp;nbsp;of&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;AtomicInteger[]&amp;nbsp;mas&lt;br&gt;
we&amp;nbsp;can&amp;nbsp;use&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;AtomicIntegerArray&amp;nbsp;vector&amp;nbsp;=&amp;nbsp;new&amp;nbsp;AtomicIntegerArray(10);&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;javautilconcurent.atomics;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.atomic.AtomicIntegerArray;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;AtomicArray&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;AtomicIntegerArray&amp;nbsp;vector&amp;nbsp;=&amp;nbsp;new&amp;nbsp;AtomicIntegerArray(10);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vector.incrementAndGet(5);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;vector.length();&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(vector.get(i));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:26" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;java.util.concurrent&amp;nbsp;High&amp;nbsp;Level&amp;nbsp;Synchronization&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Constructs,&amp;nbsp;list&amp;nbsp;main&amp;nbsp;classes.&lt;br&gt;
CountDownLatch&amp;nbsp;and&amp;nbsp;Semaphore&amp;nbsp;,&amp;nbsp;describe.&amp;nbsp;Provide&amp;nbsp;examples.&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
The&amp;nbsp;java.util.concurrent&amp;nbsp;package&amp;nbsp;adds&amp;nbsp;several&amp;nbsp;higher-level&amp;nbsp;synchronization&amp;nbsp;utilities&lt;br&gt;
borrowed&amp;nbsp;from&amp;nbsp;other&amp;nbsp;languages,&amp;nbsp;including&amp;nbsp;CountDownLatch,&amp;nbsp;Semaphore,&amp;nbsp;CyclicBarrier,&lt;br&gt;
and&amp;nbsp;Exchanger.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='630'&amp;nbsp;height='330'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/Synchronizers1.png'/&gt;&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='840'&amp;nbsp;height='582'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/Synchronizers2.png'/&gt;&lt;br&gt;
&lt;br&gt;
=====================================================&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CountDownLatch&lt;br&gt;
The&amp;nbsp;CountDownLatch&amp;nbsp;is&amp;nbsp;a&amp;nbsp;very&amp;nbsp;simple&amp;nbsp;synchronization&amp;nbsp;utility&amp;nbsp;that&amp;nbsp;allows&amp;nbsp;any&amp;nbsp;number&lt;br&gt;
of&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;block,&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;a&amp;nbsp;countdown&amp;nbsp;value&amp;nbsp;to&amp;nbsp;reach&amp;nbsp;0&amp;nbsp;before&amp;nbsp;being&amp;nbsp;“released”&lt;br&gt;
to&amp;nbsp;continue&amp;nbsp;their&amp;nbsp;activities.&amp;nbsp;The&amp;nbsp;CountDownLatch&amp;nbsp;is&amp;nbsp;initialized&amp;nbsp;with&amp;nbsp;the&amp;nbsp;count&amp;nbsp;when&lt;br&gt;
constructed.&amp;nbsp;Thereafter,&amp;nbsp;threads&amp;nbsp;may&amp;nbsp;block&amp;nbsp;using&amp;nbsp;the&amp;nbsp;await()&amp;nbsp;method&amp;nbsp;or&amp;nbsp;block&amp;nbsp;for&amp;nbsp;a&lt;br&gt;
limited&amp;nbsp;period&amp;nbsp;of&amp;nbsp;time&amp;nbsp;using&amp;nbsp;the&amp;nbsp;timed&amp;nbsp;wait&amp;nbsp;version&amp;nbsp;of&amp;nbsp;await().&lt;br&gt;
&lt;br&gt;
Any&amp;nbsp;running&amp;nbsp;thread&amp;nbsp;may&amp;nbsp;decrement&amp;nbsp;the&amp;nbsp;counter&amp;nbsp;at&amp;nbsp;any&amp;nbsp;time,&amp;nbsp;whether&amp;nbsp;threads&amp;nbsp;are&lt;br&gt;
blocked&amp;nbsp;or&amp;nbsp;not.&amp;nbsp;Once&amp;nbsp;the&amp;nbsp;counter&amp;nbsp;reaches&amp;nbsp;0,&amp;nbsp;all&amp;nbsp;waiting&amp;nbsp;threads&amp;nbsp;unblock&amp;nbsp;and&amp;nbsp;continue.&lt;br&gt;
Thereafter,&amp;nbsp;any&amp;nbsp;calls&amp;nbsp;to&amp;nbsp;await()&amp;nbsp;do&amp;nbsp;not&amp;nbsp;block&amp;nbsp;and&amp;nbsp;the&amp;nbsp;await()&amp;nbsp;method&amp;nbsp;returns&amp;nbsp;false,&lt;br&gt;
indicating&amp;nbsp;that&amp;nbsp;the&amp;nbsp;count&amp;nbsp;has&amp;nbsp;passed.&amp;nbsp;The&amp;nbsp;count&amp;nbsp;cannot&amp;nbsp;be&amp;nbsp;reset.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='300'&amp;nbsp;height='300'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/CountdownLatch_example.png'/&gt;&lt;br&gt;
&lt;br&gt;
Pseudo&amp;nbsp;code&amp;nbsp;for&amp;nbsp;CountDownLatch&amp;nbsp;can&amp;nbsp;be&amp;nbsp;written&amp;nbsp;like&amp;nbsp;this:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Main&amp;nbsp;thread&amp;nbsp;start&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Create&amp;nbsp;CountDownLatch&amp;nbsp;for&amp;nbsp;N&amp;nbsp;threads&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Create&amp;nbsp;and&amp;nbsp;start&amp;nbsp;N&amp;nbsp;threads&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Main&amp;nbsp;thread&amp;nbsp;wait&amp;nbsp;on&amp;nbsp;latch&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//N&amp;nbsp;threads&amp;nbsp;completes&amp;nbsp;there&amp;nbsp;tasks&amp;nbsp;are&amp;nbsp;returns&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Main&amp;nbsp;thread&amp;nbsp;resume&amp;nbsp;execution&lt;br&gt;
&lt;br&gt;
===&lt;br&gt;
Simple&amp;nbsp;EXAMPLE&amp;nbsp;:&amp;nbsp;&lt;br&gt;
package&amp;nbsp;javautilconcurent.HighLeveSynchronizeConstructs;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.CountDownLatch;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;CountDownLatchExample&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CountDownLatch&amp;nbsp;latch&amp;nbsp;=&amp;nbsp;new&amp;nbsp;CountDownLatch(3);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Waiter&amp;nbsp;waiter&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Waiter(latch);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Decrementer&amp;nbsp;decrementer&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Decrementer(latch);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(waiter).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(decrementer).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(4000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Waiter&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CountDownLatch&amp;nbsp;latch&amp;nbsp;=&amp;nbsp;null;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Waiter(CountDownLatch&amp;nbsp;latch)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.latch&amp;nbsp;=&amp;nbsp;latch;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;latch.await();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Waiter&amp;nbsp;releases");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;Decrementer&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CountDownLatch&amp;nbsp;latch&amp;nbsp;=&amp;nbsp;null;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;Decrementer(CountDownLatch&amp;nbsp;latch)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.latch&amp;nbsp;=&amp;nbsp;latch;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("1&amp;nbsp;second");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.latch.countDown();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("2&amp;nbsp;seconds");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.latch.countDown();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("3&amp;nbsp;seconds");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.latch.countDown();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
1&amp;nbsp;second&lt;br&gt;
2&amp;nbsp;seconds&lt;br&gt;
3&amp;nbsp;seconds&lt;br&gt;
Waiter&amp;nbsp;releases&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
==&lt;br&gt;
Countdown&amp;nbsp;latches&amp;nbsp;are&amp;nbsp;used&amp;nbsp;in&amp;nbsp;a&amp;nbsp;wide&amp;nbsp;variety&amp;nbsp;of&amp;nbsp;synchronization&amp;nbsp;schemes&amp;nbsp;to&amp;nbsp;coordinate&lt;br&gt;
a&amp;nbsp;number&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;on&amp;nbsp;one&amp;nbsp;result&amp;nbsp;or&amp;nbsp;cause&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;a&amp;nbsp;number&amp;nbsp;of&amp;nbsp;other&amp;nbsp;threads&lt;br&gt;
to&amp;nbsp;produce&amp;nbsp;results.&amp;nbsp;Later&amp;nbsp;we’ll&amp;nbsp;talk&amp;nbsp;about&amp;nbsp;a&amp;nbsp;related&amp;nbsp;utility,&amp;nbsp;CyclicBarrier,&amp;nbsp;that&amp;nbsp;explicitly&lt;br&gt;
waits&amp;nbsp;for&amp;nbsp;a&amp;nbsp;number&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;synchronize&amp;nbsp;in&amp;nbsp;order&amp;nbsp;to&amp;nbsp;coordinate&amp;nbsp;an&amp;nbsp;action.&lt;br&gt;
&lt;br&gt;
=================================================&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Semaphore&lt;br&gt;
&lt;br&gt;
Semaphores&amp;nbsp;are&amp;nbsp;a&amp;nbsp;very&amp;nbsp;old&amp;nbsp;synchronization&amp;nbsp;construct&amp;nbsp;that&amp;nbsp;has&amp;nbsp;been&amp;nbsp;used&amp;nbsp;in&amp;nbsp;many&amp;nbsp;other&lt;br&gt;
languages.&lt;br&gt;
&lt;br&gt;
Conceptually,&amp;nbsp;a&amp;nbsp;semaphore&amp;nbsp;is&amp;nbsp;a&amp;nbsp;pool&amp;nbsp;of&amp;nbsp;permits—intangible&amp;nbsp;permission&amp;nbsp;slips&lt;br&gt;
to&amp;nbsp;perform&amp;nbsp;some&amp;nbsp;activity.&amp;nbsp;__&amp;nbsp;The&amp;nbsp;semaphore&amp;nbsp;is&amp;nbsp;initialized&amp;nbsp;with&amp;nbsp;a&amp;nbsp;specified&amp;nbsp;number&lt;br&gt;
of&amp;nbsp;permits.__&amp;nbsp;&lt;&lt;----&lt;br&gt;
Callers&amp;nbsp;can&amp;nbsp;then&amp;nbsp;use&amp;nbsp;the&amp;nbsp;&amp;nbsp;__&amp;nbsp;acquire()&amp;nbsp;and&amp;nbsp;__&amp;nbsp;release()&amp;nbsp;methods&amp;nbsp;to&amp;nbsp;take&amp;nbsp;and&amp;nbsp;return&lt;br&gt;
these&amp;nbsp;permits.&amp;nbsp;Calling&amp;nbsp;acquire()&amp;nbsp;when&amp;nbsp;no&amp;nbsp;permits&amp;nbsp;are&amp;nbsp;available&amp;nbsp;causes&amp;nbsp;the&amp;nbsp;caller&amp;nbsp;to&amp;nbsp;block&lt;br&gt;
until&amp;nbsp;one&amp;nbsp;is&amp;nbsp;released.&amp;nbsp;In&amp;nbsp;this&amp;nbsp;way,&amp;nbsp;for&amp;nbsp;example,&amp;nbsp;a&amp;nbsp;semaphore&amp;nbsp;could&amp;nbsp;be&amp;nbsp;used&amp;nbsp;to&amp;nbsp;limit&amp;nbsp;access&lt;br&gt;
to&amp;nbsp;some&amp;nbsp;resource&amp;nbsp;to&amp;nbsp;a&amp;nbsp;specified&amp;nbsp;number&amp;nbsp;of&amp;nbsp;threads:&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int&amp;nbsp;concurrentReaders&amp;nbsp;=&amp;nbsp;5;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boolean&amp;nbsp;fair&amp;nbsp;=&amp;nbsp;true;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Semaphore&amp;nbsp;sem&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Semaphore(&amp;nbsp;concurrentReaders,&amp;nbsp;fair&amp;nbsp;);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Data&amp;nbsp;readData()&amp;nbsp;throws&amp;nbsp;InterruptedException&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sem.acquire();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;read&amp;nbsp;data&amp;nbsp;...&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sem.release();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;data;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;this&amp;nbsp;code&amp;nbsp;snippet,&amp;nbsp;readData()&amp;nbsp;effectively&amp;nbsp;limits&amp;nbsp;itself&amp;nbsp;to&amp;nbsp;five&amp;nbsp;concurrent&amp;nbsp;reading&lt;br&gt;
threads&amp;nbsp;at&amp;nbsp;any&amp;nbsp;given&amp;nbsp;time.&amp;nbsp;Additional&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;blocked&amp;nbsp;in&amp;nbsp;the&amp;nbsp;acquire()&amp;nbsp;method&amp;nbsp;until&lt;br&gt;
a&amp;nbsp;permit&amp;nbsp;is&amp;nbsp;free.&amp;nbsp;--&gt;&gt;&amp;nbsp;In&amp;nbsp;this&amp;nbsp;sense,&amp;nbsp;a&amp;nbsp;semaphore&amp;nbsp;is&amp;nbsp;vaguely&amp;nbsp;like&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;with&amp;nbsp;multiple&amp;nbsp;owners.&lt;br&gt;
This&amp;nbsp;is&amp;nbsp;where&amp;nbsp;the&amp;nbsp;similarity&amp;nbsp;ends,&amp;nbsp;however.&lt;br&gt;
&lt;br&gt;
-====&lt;br&gt;
Hello&amp;nbsp;World&amp;nbsp;EXAMPLE&amp;nbsp;:&amp;nbsp;&lt;br&gt;
package&amp;nbsp;javautilconcurent.HighLeveSynchronizeConstructs;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Semaphore;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;SemaphoreHelloWorld&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;final&amp;nbsp;Semaphore&amp;nbsp;sem;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;SemaphoreHelloWorld(Semaphore&amp;nbsp;sem){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.sem&amp;nbsp;=&amp;nbsp;sem;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;actionLimitBy3Threads(){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sem.acquire();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(2000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Slept&amp;nbsp;two&amp;nbsp;second");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}finally{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sem.release();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;SemaphoreHelloWorld&amp;nbsp;hello&amp;nbsp;=&amp;nbsp;new&amp;nbsp;SemaphoreHelloWorld(new&amp;nbsp;Semaphore(3));&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for(&amp;nbsp;int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&lt;&amp;nbsp;4;&amp;nbsp;i++){&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;hello.actionLimitBy3Threads();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).start();;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
Slept&amp;nbsp;two&amp;nbsp;second&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;displayed&amp;nbsp;after&amp;nbsp;2&amp;nbsp;seconds&lt;br&gt;
Slept&amp;nbsp;two&amp;nbsp;second&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;displayed&amp;nbsp;after&amp;nbsp;2&amp;nbsp;seconds&lt;br&gt;
Slept&amp;nbsp;two&amp;nbsp;second&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;displayed&amp;nbsp;after&amp;nbsp;2&amp;nbsp;seconds&lt;br&gt;
Slept&amp;nbsp;two&amp;nbsp;second&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;displayed&amp;nbsp;after&amp;nbsp;4&amp;nbsp;seconds&lt;br&gt;
&lt;br&gt;
===============&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;actuality,&amp;nbsp;a&amp;nbsp;semaphore&amp;nbsp;differs&amp;nbsp;from&amp;nbsp;a&amp;nbsp;lock&amp;nbsp;in&amp;nbsp;several&amp;nbsp;ways.&amp;nbsp;First,&amp;nbsp;the&amp;nbsp;“pool&amp;nbsp;of&amp;nbsp;permits”&lt;br&gt;
is&amp;nbsp;really&amp;nbsp;just&amp;nbsp;a&amp;nbsp;number.&amp;nbsp;No&amp;nbsp;actual&amp;nbsp;value&amp;nbsp;is&amp;nbsp;returned&amp;nbsp;by&amp;nbsp;acquire()&amp;nbsp;and&amp;nbsp;no&amp;nbsp;association&amp;nbsp;is&lt;br&gt;
made&amp;nbsp;with&amp;nbsp;the&amp;nbsp;acquirer&amp;nbsp;of&amp;nbsp;the&amp;nbsp;lock.&lt;br&gt;
This&amp;nbsp;means&amp;nbsp;that&amp;nbsp;any&amp;nbsp;actual&amp;nbsp;locking&amp;nbsp;behavior&amp;nbsp;is&amp;nbsp;strictly&amp;nbsp;cooperative&amp;nbsp;(by&amp;nbsp;convention&amp;nbsp;in&amp;nbsp;the&lt;br&gt;
application).&amp;nbsp;It&amp;nbsp;also&amp;nbsp;means&amp;nbsp;that&amp;nbsp;“permits”&amp;nbsp;can&amp;nbsp;be&amp;nbsp;acquired&amp;nbsp;and&amp;nbsp;released&amp;nbsp;by&amp;nbsp;different&amp;nbsp;callers&lt;br&gt;
without&amp;nbsp;respect&amp;nbsp;to&amp;nbsp;who&amp;nbsp;actually&amp;nbsp;“acquired”&amp;nbsp;them.&amp;nbsp;&lt;br&gt;
&lt;br&gt;
It’s&amp;nbsp;really&amp;nbsp;just&amp;nbsp;incrementing&amp;nbsp;or&amp;nbsp;decrementing&amp;nbsp;the&amp;nbsp;number.&amp;nbsp;Also,&amp;nbsp;because&amp;nbsp;there&amp;nbsp;is&amp;nbsp;no&amp;nbsp;real&lt;br&gt;
association&amp;nbsp;with&amp;nbsp;an&amp;nbsp;“owner,”&amp;nbsp;--&gt;&gt;&amp;nbsp;semaphores&amp;nbsp;are&amp;nbsp;not&amp;nbsp;reentrant&amp;nbsp;&lt;&lt;--&amp;nbsp;in&amp;nbsp;the&amp;nbsp;way&amp;nbsp;that&amp;nbsp;real&amp;nbsp;locks&amp;nbsp;are.&lt;br&gt;
That&amp;nbsp;is,&amp;nbsp;if&amp;nbsp;a&amp;nbsp;thread&amp;nbsp;calls&amp;nbsp;acquire()&amp;nbsp;multiple&amp;nbsp;times,&amp;nbsp;it&amp;nbsp;simply&amp;nbsp;decrements&amp;nbsp;the&amp;nbsp;counter&lt;br&gt;
multiple&amp;nbsp;times.&amp;nbsp;This&amp;nbsp;behavior&amp;nbsp;could&amp;nbsp;be&amp;nbsp;useful&amp;nbsp;in&amp;nbsp;some&amp;nbsp;cases&amp;nbsp;to&amp;nbsp;count&amp;nbsp;levels&amp;nbsp;of&amp;nbsp;recursion&lt;br&gt;
for&amp;nbsp;security&amp;nbsp;APIs,&amp;nbsp;for&amp;nbsp;example,&amp;nbsp;but&amp;nbsp;is&amp;nbsp;not&amp;nbsp;like&amp;nbsp;a&amp;nbsp;lock,&amp;nbsp;in&amp;nbsp;which&amp;nbsp;one&amp;nbsp;caller&amp;nbsp;“owns”&amp;nbsp;multiple&lt;br&gt;
permits.&amp;nbsp;Finally,&amp;nbsp;because&amp;nbsp;the&amp;nbsp;permits&amp;nbsp;pool&amp;nbsp;is&amp;nbsp;really&amp;nbsp;just&amp;nbsp;a&amp;nbsp;number,&amp;nbsp;calling&amp;nbsp;acquire()&amp;nbsp;and&lt;br&gt;
release()&amp;nbsp;out&amp;nbsp;of&amp;nbsp;sync&amp;nbsp;can&amp;nbsp;increase&amp;nbsp;the&amp;nbsp;permit&amp;nbsp;pool&amp;nbsp;beyond&amp;nbsp;its&amp;nbsp;starting&amp;nbsp;point&amp;nbsp;or&amp;nbsp;decrement&lt;br&gt;
it&amp;nbsp;below&amp;nbsp;zero.&amp;nbsp;It&amp;nbsp;can&amp;nbsp;even&amp;nbsp;be&amp;nbsp;initialized&amp;nbsp;with&amp;nbsp;a&amp;nbsp;negative&amp;nbsp;number&amp;nbsp;if&amp;nbsp;you&amp;nbsp;wish&amp;nbsp;to&lt;br&gt;
require&amp;nbsp;releases&amp;nbsp;before&amp;nbsp;anyone&amp;nbsp;acquires&amp;nbsp;a&amp;nbsp;permit.&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;addition&amp;nbsp;to&amp;nbsp;acquire(),&amp;nbsp;Semaphore&amp;nbsp;has&amp;nbsp;a&amp;nbsp;tryAcquire()&amp;nbsp;method&amp;nbsp;that&amp;nbsp;parallels&amp;nbsp;the&lt;br&gt;
tryLock()&amp;nbsp;method&amp;nbsp;of&amp;nbsp;Lock.&amp;nbsp;It&amp;nbsp;returns&amp;nbsp;immediately,&amp;nbsp;acquiring&amp;nbsp;a&amp;nbsp;permit&amp;nbsp;if&amp;nbsp;one&amp;nbsp;was&amp;nbsp;available&lt;br&gt;
and&amp;nbsp;returning&amp;nbsp;false&amp;nbsp;otherwise.&amp;nbsp;Another&amp;nbsp;form&amp;nbsp;of&amp;nbsp;tryAcquire()&amp;nbsp;accepts&amp;nbsp;a&amp;nbsp;timed&lt;br&gt;
wait&amp;nbsp;period.&amp;nbsp;Semaphores&amp;nbsp;also&amp;nbsp;have&amp;nbsp;a&amp;nbsp;notion&amp;nbsp;of&amp;nbsp;“fairness”&amp;nbsp;in&amp;nbsp;the&amp;nbsp;ordering&amp;nbsp;of&amp;nbsp;acquire&lt;br&gt;
requests.&amp;nbsp;By&amp;nbsp;default,&amp;nbsp;requests&amp;nbsp;are&amp;nbsp;not&amp;nbsp;guaranteed&amp;nbsp;to&amp;nbsp;be&amp;nbsp;ordered,&amp;nbsp;but&amp;nbsp;if&amp;nbsp;the&amp;nbsp;“fair”&amp;nbsp;flag&amp;nbsp;is&lt;br&gt;
set&amp;nbsp;when&amp;nbsp;the&amp;nbsp;Semaphore&amp;nbsp;is&amp;nbsp;constructed,&amp;nbsp;acquire()&amp;nbsp;doles&amp;nbsp;out&amp;nbsp;permits&amp;nbsp;in&amp;nbsp;first-in-firstout&lt;br&gt;
(FIFO)&amp;nbsp;order.&amp;nbsp;The&amp;nbsp;tradeoff&amp;nbsp;is&amp;nbsp;that&amp;nbsp;ordering&amp;nbsp;may&amp;nbsp;impact&amp;nbsp;performance&amp;nbsp;a&amp;nbsp;bit,&amp;nbsp;depending&lt;br&gt;
on&amp;nbsp;the&amp;nbsp;implementation.&lt;br&gt;
&lt;br&gt;
===================================================&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CountdownLatch&amp;nbsp;VS&amp;nbsp;Semaphore&lt;br&gt;
CountdownLatch&amp;nbsp;is&amp;nbsp;used&amp;nbsp;to&amp;nbsp;start&amp;nbsp;a&amp;nbsp;series&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;and&amp;nbsp;then&amp;nbsp;wait&amp;nbsp;until&amp;nbsp;all&amp;nbsp;of&amp;nbsp;them&amp;nbsp;are&amp;nbsp;complete&lt;br&gt;
(or&amp;nbsp;until&amp;nbsp;they&amp;nbsp;call&amp;nbsp;countDown()&amp;nbsp;a&amp;nbsp;given&amp;nbsp;number&amp;nbsp;of&amp;nbsp;times.&lt;br&gt;
&lt;br&gt;
Semaphore&amp;nbsp;is&amp;nbsp;used&amp;nbsp;to&amp;nbsp;control&amp;nbsp;the&amp;nbsp;number&amp;nbsp;of&amp;nbsp;concurrent&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;are&amp;nbsp;using&amp;nbsp;a&amp;nbsp;resource.&lt;br&gt;
That&amp;nbsp;resource&amp;nbsp;can&amp;nbsp;be&amp;nbsp;something&amp;nbsp;like&amp;nbsp;a&amp;nbsp;file,&amp;nbsp;or&amp;nbsp;could&amp;nbsp;be&amp;nbsp;the&amp;nbsp;cpu&amp;nbsp;by&amp;nbsp;limiting&amp;nbsp;the&amp;nbsp;number&amp;nbsp;of&lt;br&gt;
threads&amp;nbsp;executing.&amp;nbsp;The&amp;nbsp;count&amp;nbsp;on&amp;nbsp;a&amp;nbsp;Semaphore&amp;nbsp;can&amp;nbsp;go&amp;nbsp;up&amp;nbsp;and&amp;nbsp;down&amp;nbsp;as&amp;nbsp;different&amp;nbsp;threads&amp;nbsp;call&lt;br&gt;
acquire()&amp;nbsp;and&amp;nbsp;release().&lt;br&gt;
&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:27" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurency&amp;nbsp;:&amp;nbsp;java.util.concurrent&amp;nbsp;High&amp;nbsp;Level&amp;nbsp;Synchronization&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Constructs,&lt;br&gt;
CyclicBarrier&amp;nbsp;and&amp;nbsp;Phaser&amp;nbsp;describe.&amp;nbsp;What&amp;nbsp;is&amp;nbsp;the&amp;nbsp;difference&amp;nbsp;between&amp;nbsp;them&amp;nbsp;(&amp;nbsp;it&amp;nbsp;is&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;little&amp;nbsp;difference)?&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>The&amp;nbsp;CyclicBarrier&amp;nbsp;class&amp;nbsp;is&amp;nbsp;a&amp;nbsp;synchronization&amp;nbsp;point&amp;nbsp;where&amp;nbsp;a&amp;nbsp;specified&amp;nbsp;number&amp;nbsp;of&lt;br&gt;
related&amp;nbsp;threads&amp;nbsp;meet&amp;nbsp;after&amp;nbsp;finishing&amp;nbsp;their&amp;nbsp;activities.&amp;nbsp;When&amp;nbsp;all&amp;nbsp;of&amp;nbsp;the&amp;nbsp;threads&lt;br&gt;
have&amp;nbsp;arrived,&amp;nbsp;an&amp;nbsp;optional,&amp;nbsp;shared&amp;nbsp;barrier&amp;nbsp;action&amp;nbsp;can&amp;nbsp;be&amp;nbsp;executed&amp;nbsp;and&amp;nbsp;then&amp;nbsp;all&lt;br&gt;
of&amp;nbsp;the&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;“released”&amp;nbsp;to&amp;nbsp;continue.&amp;nbsp;The&amp;nbsp;class&amp;nbsp;is&amp;nbsp;termed&amp;nbsp;cyclic&amp;nbsp;because&amp;nbsp;it&lt;br&gt;
can&amp;nbsp;then&amp;nbsp;be&amp;nbsp;used&amp;nbsp;again&amp;nbsp;in&amp;nbsp;the&amp;nbsp;case&amp;nbsp;where&amp;nbsp;the&amp;nbsp;threads&amp;nbsp;repeat&amp;nbsp;their&amp;nbsp;activities&amp;nbsp;in&amp;nbsp;this&lt;br&gt;
&amp;nbsp;manner.&amp;nbsp;CyclicBarrier&amp;nbsp;is&amp;nbsp;an&amp;nbsp;alternative&amp;nbsp;to&amp;nbsp;using&amp;nbsp;the&amp;nbsp;join()&amp;nbsp;method,&amp;nbsp;which&amp;nbsp;collects&lt;br&gt;
threads&amp;nbsp;only&amp;nbsp;after&amp;nbsp;they&amp;nbsp;have&amp;nbsp;completed&amp;nbsp;and&amp;nbsp;returned&amp;nbsp;from&amp;nbsp;their&amp;nbsp;run()&amp;nbsp;method.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;&amp;nbsp;constructor&amp;nbsp;consructs&amp;nbsp;&amp;nbsp;the&amp;nbsp;barriers,&amp;nbsp;specifying&amp;nbsp;the&amp;nbsp;number&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;must&lt;br&gt;
be&amp;nbsp;present&amp;nbsp;before&amp;nbsp;the&amp;nbsp;group&amp;nbsp;has&amp;nbsp;fully&amp;nbsp;arrived&amp;nbsp;and&amp;nbsp;the&amp;nbsp;action&amp;nbsp;to&amp;nbsp;perform&amp;nbsp;when&amp;nbsp;all&amp;nbsp;of&amp;nbsp;the&lt;br&gt;
threads&amp;nbsp;are&amp;nbsp;ready.&lt;br&gt;
&lt;br&gt;
Example&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;javautilconcurent.HighLeveSynchronizeConstructs;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.BrokenBarrierException;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.CyclicBarrier;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;CyclicBarierExample&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Runnable&amp;nbsp;barrier1Action&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("BarrierAction&amp;nbsp;1&amp;nbsp;executed&amp;nbsp;");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Runnable&amp;nbsp;barrier2Action&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("BarrierAction&amp;nbsp;2&amp;nbsp;executed&amp;nbsp;");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CyclicBarrier&amp;nbsp;barrier1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;CyclicBarrier(2,&amp;nbsp;barrier1Action);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CyclicBarrier&amp;nbsp;barrier2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;CyclicBarrier(2,&amp;nbsp;barrier2Action);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CyclicBarrierRunnable&amp;nbsp;barrierRunnable1&amp;nbsp;=&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;CyclicBarrierRunnable(barrier1,&amp;nbsp;barrier2);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CyclicBarrierRunnable&amp;nbsp;barrierRunnable2&amp;nbsp;=&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;CyclicBarrierRunnable(barrier1,&amp;nbsp;barrier2);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(barrierRunnable1).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(barrierRunnable2).start();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;CyclicBarrierRunnable&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CyclicBarrier&amp;nbsp;barrier1&amp;nbsp;=&amp;nbsp;null;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CyclicBarrier&amp;nbsp;barrier2&amp;nbsp;=&amp;nbsp;null;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;CyclicBarrierRunnable(CyclicBarrier&amp;nbsp;barrier1,&amp;nbsp;CyclicBarrier&amp;nbsp;barrier2)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.barrier1&amp;nbsp;=&amp;nbsp;barrier1;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.barrier2&amp;nbsp;=&amp;nbsp;barrier2;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(2000);&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;"&amp;nbsp;waiting&amp;nbsp;at&amp;nbsp;barrier&amp;nbsp;1");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;here&amp;nbsp;in&amp;nbsp;our&amp;nbsp;example&amp;nbsp;:&amp;nbsp;2&amp;nbsp;threads&amp;nbsp;must&amp;nbsp;make&amp;nbsp;'this.barrier1.await()'&amp;nbsp;-&amp;nbsp;and&amp;nbsp;after&amp;nbsp;this&amp;nbsp;barrier1&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//performs&amp;nbsp;some&amp;nbsp;action&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.barrier1.await();&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(2000);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;"&amp;nbsp;waiting&amp;nbsp;at&amp;nbsp;barrier&amp;nbsp;2");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.barrier2.await();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"&amp;nbsp;done!");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(BrokenBarrierException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT&amp;nbsp;:&lt;br&gt;
Thread-0&amp;nbsp;waiting&amp;nbsp;at&amp;nbsp;barrier&amp;nbsp;1&lt;br&gt;
Thread-1&amp;nbsp;waiting&amp;nbsp;at&amp;nbsp;barrier&amp;nbsp;1&lt;br&gt;
BarrierAction&amp;nbsp;1&amp;nbsp;executed&amp;nbsp;&lt;br&gt;
Thread-1&amp;nbsp;waiting&amp;nbsp;at&amp;nbsp;barrier&amp;nbsp;2&lt;br&gt;
Thread-0&amp;nbsp;waiting&amp;nbsp;at&amp;nbsp;barrier&amp;nbsp;2&lt;br&gt;
BarrierAction&amp;nbsp;2&amp;nbsp;executed&amp;nbsp;&lt;br&gt;
Thread-0&amp;nbsp;done!&lt;br&gt;
Thread-1&amp;nbsp;done!&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
==================================================&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Phaser&lt;br&gt;
&lt;br&gt;
No&amp;nbsp;Star&amp;nbsp;Trek&amp;nbsp;jokes&amp;nbsp;here.&amp;nbsp;Java&amp;nbsp;7&amp;nbsp;introduced&amp;nbsp;a&amp;nbsp;new&amp;nbsp;concurrency&amp;nbsp;utility&amp;nbsp;called&amp;nbsp;Phaser.&lt;br&gt;
Phaser&amp;nbsp;is&amp;nbsp;very&amp;nbsp;similar&amp;nbsp;to&amp;nbsp;the&amp;nbsp;CyclicBarrier&amp;nbsp;except&amp;nbsp;that&amp;nbsp;it&amp;nbsp;provides&amp;nbsp;a&amp;nbsp;bit&amp;nbsp;more&amp;nbsp;flexibility.&lt;br&gt;
Phaser&amp;nbsp;draws&amp;nbsp;its&amp;nbsp;name&amp;nbsp;in&amp;nbsp;part&amp;nbsp;from&amp;nbsp;the&amp;nbsp;fact&amp;nbsp;that&amp;nbsp;it&amp;nbsp;assigns&amp;nbsp;a&amp;nbsp;number&amp;nbsp;to&amp;nbsp;each&amp;nbsp;cycle&amp;nbsp;of&amp;nbsp;its&lt;br&gt;
threads&amp;nbsp;(a&amp;nbsp;phase&amp;nbsp;number).&amp;nbsp;Participating&amp;nbsp;threads&amp;nbsp;and&amp;nbsp;bystanders&amp;nbsp;can&amp;nbsp;read&amp;nbsp;this&amp;nbsp;number&lt;br&gt;
to&amp;nbsp;monitor&amp;nbsp;activity&amp;nbsp;in&amp;nbsp;the&amp;nbsp;barrier.&lt;br&gt;
&lt;br&gt;
In&amp;nbsp;CyclicBarrier,&amp;nbsp;the&amp;nbsp;number&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;are&lt;br&gt;
tracked&amp;nbsp;by&amp;nbsp;the&amp;nbsp;barrier&amp;nbsp;is&amp;nbsp;fixed;&amp;nbsp;new&amp;nbsp;threads&amp;nbsp;cannot&amp;nbsp;join&amp;nbsp;the&amp;nbsp;party&amp;nbsp;during&amp;nbsp;its&amp;nbsp;lifecycle.&lt;br&gt;
!!!!!&amp;nbsp;This&amp;nbsp;differs&amp;nbsp;from&amp;nbsp;Phaser,&amp;nbsp;where&amp;nbsp;the&amp;nbsp;number&amp;nbsp;of&amp;nbsp;participants&amp;nbsp;can&amp;nbsp;change&amp;nbsp;over&amp;nbsp;the&amp;nbsp;life&amp;nbsp;of&lt;br&gt;
the&amp;nbsp;activity.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:28" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurrency&amp;nbsp;:&amp;nbsp;Exchanger&amp;nbsp;class&amp;nbsp;,&amp;nbsp;describe.&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>The&amp;nbsp;java.util.concurrent.Exchanger&amp;nbsp;class&amp;nbsp;represents&amp;nbsp;a&amp;nbsp;kind&amp;nbsp;of&amp;nbsp;rendezvous&amp;nbsp;point&amp;nbsp;where&lt;br&gt;
two&amp;nbsp;threads&amp;nbsp;can&amp;nbsp;exchange&amp;nbsp;objects.&amp;nbsp;Here&amp;nbsp;is&amp;nbsp;an&amp;nbsp;illustration&amp;nbsp;of&amp;nbsp;this&amp;nbsp;mechanism:&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='500'&amp;nbsp;height='180'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/exchanger.png'/&gt;&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;Exchanger&amp;nbsp;is&amp;nbsp;a&amp;nbsp;synchronization&amp;nbsp;point&amp;nbsp;for&amp;nbsp;a&amp;nbsp;pair&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;exchange&amp;nbsp;data&lt;br&gt;
items.&amp;nbsp;An&amp;nbsp;item&amp;nbsp;of&amp;nbsp;the&amp;nbsp;same&amp;nbsp;type&amp;nbsp;is&amp;nbsp;passed&amp;nbsp;in&amp;nbsp;each&amp;nbsp;direction&amp;nbsp;using&amp;nbsp;the&amp;nbsp;exchange()&lt;br&gt;
method.&amp;nbsp;The&amp;nbsp;first&amp;nbsp;method&amp;nbsp;to&amp;nbsp;arrive&amp;nbsp;at&amp;nbsp;the&amp;nbsp;Exchanger&amp;nbsp;blocks,&amp;nbsp;waiting&amp;nbsp;for&amp;nbsp;its&lt;br&gt;
mate.&amp;nbsp;When&amp;nbsp;the&amp;nbsp;second&amp;nbsp;method&amp;nbsp;arrives,&amp;nbsp;they&amp;nbsp;each&amp;nbsp;receive&amp;nbsp;the&amp;nbsp;other’s&amp;nbsp;argument&lt;br&gt;
to&amp;nbsp;the&amp;nbsp;exchange()&amp;nbsp;method.&amp;nbsp;Any&amp;nbsp;number&amp;nbsp;of&amp;nbsp;actual&amp;nbsp;threads&amp;nbsp;may&amp;nbsp;be&amp;nbsp;using&amp;nbsp;the&lt;br&gt;
Exchanger;&amp;nbsp;they&amp;nbsp;are&amp;nbsp;simply&amp;nbsp;paired&amp;nbsp;in&amp;nbsp;some&amp;nbsp;order&amp;nbsp;when&amp;nbsp;they&amp;nbsp;arrive.&amp;nbsp;Exchanger&amp;nbsp;is&lt;br&gt;
a&amp;nbsp;generic&amp;nbsp;class&amp;nbsp;that&amp;nbsp;is&amp;nbsp;parameterized&amp;nbsp;by&amp;nbsp;the&amp;nbsp;type&amp;nbsp;of&amp;nbsp;object&amp;nbsp;to&amp;nbsp;be&amp;nbsp;passed:&lt;br&gt;
&lt;br&gt;
EXAMPLE&amp;nbsp;(simple&amp;nbsp;=))&lt;br&gt;
package&amp;nbsp;javautilconcurent.HighLeveSynchronizeConstructs;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Exchanger;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ExchangerExample&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Exchanger&amp;nbsp;exchanger&amp;nbsp;=&amp;nbsp;new&amp;nbsp;Exchanger();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ExchangerRunnable&amp;nbsp;exchangerRunnable1&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ExchangerRunnable(exchanger,&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"A");&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ExchangerRunnable&amp;nbsp;exchangerRunnable2&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ExchangerRunnable(exchanger,&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"B");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(exchangerRunnable1).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new&amp;nbsp;Thread(exchangerRunnable2).start();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
class&amp;nbsp;ExchangerRunnable&amp;nbsp;implements&amp;nbsp;Runnable&amp;nbsp;{&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Exchanger&amp;nbsp;exchanger&amp;nbsp;=&amp;nbsp;null;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object&amp;nbsp;object&amp;nbsp;=&amp;nbsp;null;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;ExchangerRunnable(Exchanger&amp;nbsp;exchanger,&amp;nbsp;Object&amp;nbsp;object)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.exchanger&amp;nbsp;=&amp;nbsp;exchanger;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.object&amp;nbsp;=&amp;nbsp;object;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object&amp;nbsp;previous&amp;nbsp;=&amp;nbsp;this.object;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.object&amp;nbsp;=&amp;nbsp;this.exchanger.exchange(this.object);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(Thread.currentThread().getName()&amp;nbsp;+&amp;nbsp;"&amp;nbsp;exchanged&amp;nbsp;"&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+&amp;nbsp;previous&amp;nbsp;+&amp;nbsp;"&amp;nbsp;for&amp;nbsp;"&amp;nbsp;+&amp;nbsp;this.object);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
OUTPUT:&lt;br&gt;
Thread-0&amp;nbsp;exchanged&amp;nbsp;A&amp;nbsp;for&amp;nbsp;B&lt;br&gt;
Thread-1&amp;nbsp;exchanged&amp;nbsp;B&amp;nbsp;for&amp;nbsp;A&lt;br&gt;
======================================&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;Exchanger&amp;nbsp;pattern&amp;nbsp;is&amp;nbsp;primarily&amp;nbsp;useful&amp;nbsp;for&amp;nbsp;reusing&amp;nbsp;data&amp;nbsp;objects&amp;nbsp;or&amp;nbsp;buffers&lt;br&gt;
between&amp;nbsp;threads,&amp;nbsp;as&amp;nbsp;indicated&amp;nbsp;in&amp;nbsp;this&amp;nbsp;code&amp;nbsp;snippet.&amp;nbsp;Say&amp;nbsp;that&amp;nbsp;you&amp;nbsp;have&amp;nbsp;a&amp;nbsp;reader&lt;br&gt;
thread&amp;nbsp;filling&amp;nbsp;buffers&amp;nbsp;with&amp;nbsp;data&amp;nbsp;and&amp;nbsp;a&amp;nbsp;writer&amp;nbsp;thread&amp;nbsp;writing&amp;nbsp;the&amp;nbsp;contents&amp;nbsp;of&amp;nbsp;the&lt;br&gt;
buffers&amp;nbsp;somewhere.&amp;nbsp;Using&amp;nbsp;an&amp;nbsp;Exchanger,&amp;nbsp;the&amp;nbsp;reader&amp;nbsp;and&amp;nbsp;writer&amp;nbsp;can&amp;nbsp;trade&amp;nbsp;a&amp;nbsp;pair&lt;br&gt;
of&amp;nbsp;buffers&amp;nbsp;back&amp;nbsp;and&amp;nbsp;forth&amp;nbsp;without&amp;nbsp;creating&amp;nbsp;new&amp;nbsp;ones.&amp;nbsp;This&amp;nbsp;may&amp;nbsp;seem&amp;nbsp;a&amp;nbsp;bit&amp;nbsp;arcane,&lt;br&gt;
but&amp;nbsp;it&amp;nbsp;has&amp;nbsp;applications&amp;nbsp;when&amp;nbsp;using&amp;nbsp;the&amp;nbsp;NIO&amp;nbsp;advanced&amp;nbsp;I/O&amp;nbsp;package,&amp;nbsp;which&amp;nbsp;we&lt;br&gt;
discuss&amp;nbsp;in&amp;nbsp;Chapters&amp;nbsp;12&amp;nbsp;and&amp;nbsp;13.&amp;nbsp;We&amp;nbsp;should&amp;nbsp;note&amp;nbsp;that&amp;nbsp;the&amp;nbsp;Exchanger&amp;nbsp;is&amp;nbsp;similar&amp;nbsp;to&lt;br&gt;
the&amp;nbsp;SynchronousQueue,&amp;nbsp;which&amp;nbsp;we’ll&amp;nbsp;discuss&amp;nbsp;in&amp;nbsp;Chapter&amp;nbsp;11&amp;nbsp;when&amp;nbsp;we&amp;nbsp;cover&amp;nbsp;the&lt;br&gt;
Collections&amp;nbsp;API.&amp;nbsp;The&amp;nbsp;Exchanger,&amp;nbsp;however,&amp;nbsp;passes&amp;nbsp;data&amp;nbsp;in&amp;nbsp;both&amp;nbsp;directions,&amp;nbsp;whereas&lt;br&gt;
SynchronousQueue&amp;nbsp;simply&amp;nbsp;passes&amp;nbsp;elements&amp;nbsp;in&amp;nbsp;one&amp;nbsp;direction.&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:29" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concrurrency&amp;nbsp;:&amp;nbsp;Concurrrent&amp;nbsp;Collections,&amp;nbsp;describe.&amp;nbsp;What&amp;nbsp;is&amp;nbsp;the&amp;nbsp;most&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;usefull&amp;nbsp;concurrent&amp;nbsp;collections&amp;nbsp;?&lt;br&gt;
Describe&amp;nbsp;ConcurrentHashMap&amp;nbsp;class.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>Java&amp;nbsp;Collection&amp;nbsp;classes&amp;nbsp;are&amp;nbsp;fail-fast&amp;nbsp;which&amp;nbsp;means&amp;nbsp;that&amp;nbsp;if&amp;nbsp;the&amp;nbsp;Collection&amp;nbsp;will&amp;nbsp;be&amp;nbsp;changed&lt;br&gt;
while&amp;nbsp;some&amp;nbsp;thread&amp;nbsp;is&amp;nbsp;traversing&amp;nbsp;over&amp;nbsp;it&amp;nbsp;using&amp;nbsp;iterator,&amp;nbsp;the&amp;nbsp;iterator.next()&amp;nbsp;will&amp;nbsp;throw&lt;br&gt;
ConcurrentModificationException.&lt;br&gt;
&lt;br&gt;
Concurrent&amp;nbsp;Collection&amp;nbsp;classes&amp;nbsp;support&amp;nbsp;full&amp;nbsp;concurrency&amp;nbsp;of&amp;nbsp;retrievals&amp;nbsp;and&amp;nbsp;adjustable&lt;br&gt;
expected&amp;nbsp;concurrency&amp;nbsp;for&amp;nbsp;updates.&amp;nbsp;Major&amp;nbsp;classes&amp;nbsp;are&amp;nbsp;ConcurrentHashMap,&lt;br&gt;
CopyOnWriteArrayList&amp;nbsp;and&amp;nbsp;CopyOnWriteArraySet.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='850'&amp;nbsp;height='500'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ConcurrentCollections1.png'/&gt;&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='700'&amp;nbsp;height='650'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ConcurrentCollections2.png'/&gt;&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='770'&amp;nbsp;height='640'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ConcurrentCollections3.png'/&gt;&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='726'&amp;nbsp;height='666'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ConcurrentCollections4.png'/&gt;&lt;br&gt;
====================================================&lt;br&gt;
FULL&amp;nbsp;LIST&amp;nbsp;OF&amp;nbsp;Collections&amp;nbsp;in&amp;nbsp;java.util.concurrent&amp;nbsp;package&amp;nbsp;:&lt;br&gt;
Interfaces&amp;nbsp;:&lt;br&gt;
BlockingDeque&lt;br&gt;
BlockingQueue&lt;br&gt;
ConcurrentMap&lt;br&gt;
ConcurrentNavigableMap&lt;br&gt;
TransferQueue&lt;br&gt;
&lt;br&gt;
Classes&amp;nbsp;:&lt;br&gt;
ArrayBlockingQueue&lt;br&gt;
ConcurrentHashMap&lt;br&gt;
ConcurrentHashMap.KeySetView&lt;br&gt;
ConcurrentLinkedDeque&lt;br&gt;
ConcurrentLinkedQueue&lt;br&gt;
ConcurrentSkipListMap&lt;br&gt;
ConcurrentSkipListSet&lt;br&gt;
CopyOnWriteArrayList&lt;br&gt;
CopyOnWriteArraySet&lt;br&gt;
DelayQueue&lt;br&gt;
LinkedBlockingDeque&lt;br&gt;
LinkedBlockingQueue&lt;br&gt;
LinkedTransferQueue&lt;br&gt;
PriorityBlockingQueue&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
=====================================&lt;br&gt;
Top&amp;nbsp;5&amp;nbsp;Concurrent&amp;nbsp;Collections&amp;nbsp;from&amp;nbsp;JDK&amp;nbsp;5&amp;nbsp;and&amp;nbsp;6&amp;nbsp;Java&amp;nbsp;Programmer&amp;nbsp;Should&amp;nbsp;Know&lt;br&gt;
Read&amp;nbsp;more:&amp;nbsp;http://javarevisited.blogspot.com/2013/02/concurrent-collections-from-jdk-56-java-example-tutorial.html&lt;br&gt;
&lt;br&gt;
1.&amp;nbsp;ConcurrentHashMap&lt;br&gt;
ConcurrentHashMap&amp;nbsp;is&amp;nbsp;undoubtedly&amp;nbsp;most&amp;nbsp;popular&amp;nbsp;collection&amp;nbsp;class&amp;nbsp;introduced&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;5&amp;nbsp;and&lt;br&gt;
most&amp;nbsp;of&amp;nbsp;us&amp;nbsp;are&amp;nbsp;already&amp;nbsp;using&amp;nbsp;it.&amp;nbsp;ConcurrentHashMap&amp;nbsp;provides&amp;nbsp;a&amp;nbsp;concurrent&amp;nbsp;alternative&lt;br&gt;
of&amp;nbsp;Hashtable&amp;nbsp;or&amp;nbsp;Synchronized&amp;nbsp;Map&amp;nbsp;classes&amp;nbsp;with&amp;nbsp;aim&amp;nbsp;to&amp;nbsp;support&amp;nbsp;higher&amp;nbsp;level&amp;nbsp;of&amp;nbsp;concurrency&lt;br&gt;
by&amp;nbsp;implementing&amp;nbsp;fined&amp;nbsp;grained&amp;nbsp;locking.&amp;nbsp;Multiple&amp;nbsp;reader&amp;nbsp;can&amp;nbsp;access&amp;nbsp;the&amp;nbsp;Map&amp;nbsp;concurrently&amp;nbsp;&lt;br&gt;
while&amp;nbsp;a&amp;nbsp;portion&amp;nbsp;of&amp;nbsp;Map&amp;nbsp;gets&amp;nbsp;locked&amp;nbsp;for&amp;nbsp;write&amp;nbsp;operation&amp;nbsp;depends&amp;nbsp;upon&amp;nbsp;concurrency&amp;nbsp;level&amp;nbsp;of&amp;nbsp;Map.&lt;br&gt;
ConcurrentHashMap&amp;nbsp;provides&amp;nbsp;better&amp;nbsp;scalability&amp;nbsp;than&amp;nbsp;there&amp;nbsp;synchronized&amp;nbsp;counter&amp;nbsp;part.&lt;br&gt;
Iterator&amp;nbsp;of&amp;nbsp;ConcurrentHashMap&amp;nbsp;are&amp;nbsp;fail-safe&amp;nbsp;iterators&amp;nbsp;which&amp;nbsp;doesn't&amp;nbsp;throw&amp;nbsp;ConcurrencModificationException&lt;br&gt;
thus&amp;nbsp;eliminates&amp;nbsp;another&amp;nbsp;requirement&amp;nbsp;of&amp;nbsp;locking&amp;nbsp;during&amp;nbsp;iteration&amp;nbsp;which&amp;nbsp;result&amp;nbsp;in&amp;nbsp;further&amp;nbsp;scalability&lt;br&gt;
and&amp;nbsp;performance.&lt;br&gt;
&lt;br&gt;
2.&amp;nbsp;CopyOnWriteArrayList&amp;nbsp;and&amp;nbsp;CopyOnWriteArraySet&lt;br&gt;
CopyOnWriteArrayList&amp;nbsp;is&amp;nbsp;a&amp;nbsp;concurrent&amp;nbsp;alternative&amp;nbsp;of&amp;nbsp;synchronized&amp;nbsp;List.&amp;nbsp;CopyOnWriteArrayList&amp;nbsp;provides&lt;br&gt;
better&amp;nbsp;concurrency&amp;nbsp;than&amp;nbsp;synchronized&amp;nbsp;List&amp;nbsp;by&amp;nbsp;allowing&amp;nbsp;multiple&amp;nbsp;concurrent&amp;nbsp;reader&amp;nbsp;and&amp;nbsp;replacing&amp;nbsp;the&lt;br&gt;
&amp;nbsp;whole&amp;nbsp;list&amp;nbsp;on&amp;nbsp;write&amp;nbsp;operation.&amp;nbsp;Yes,&amp;nbsp;write&amp;nbsp;operation&amp;nbsp;is&amp;nbsp;costly&amp;nbsp;on&amp;nbsp;CopyOnWriteArrayList&amp;nbsp;but&amp;nbsp;it&amp;nbsp;performs&lt;br&gt;
better&amp;nbsp;when&amp;nbsp;there&amp;nbsp;are&amp;nbsp;multiple&amp;nbsp;reader&amp;nbsp;and&amp;nbsp;requirement&amp;nbsp;of&amp;nbsp;iteration&amp;nbsp;is&amp;nbsp;more&amp;nbsp;than&amp;nbsp;writing.&amp;nbsp;Since&lt;br&gt;
CopyOnWriteArrayList&amp;nbsp;Iterator&amp;nbsp;also&amp;nbsp;don't&amp;nbsp;throw&amp;nbsp;ConcurrencModificationException&amp;nbsp;it&amp;nbsp;eliminates&amp;nbsp;need&amp;nbsp;to&lt;br&gt;
lock&amp;nbsp;the&amp;nbsp;collection&amp;nbsp;during&amp;nbsp;iteration.&amp;nbsp;Remember&amp;nbsp;both&amp;nbsp;ConcurrentHashMap&amp;nbsp;and&amp;nbsp;CopyOnWriteArrayList&lt;br&gt;
doesn't&amp;nbsp;provides&amp;nbsp;same&amp;nbsp;level&amp;nbsp;of&amp;nbsp;locking&amp;nbsp;as&amp;nbsp;Synchronized&amp;nbsp;Collection&amp;nbsp;and&amp;nbsp;achieves&amp;nbsp;thread-safety&amp;nbsp;by&amp;nbsp;there&lt;br&gt;
locking&amp;nbsp;and&amp;nbsp;mutability&amp;nbsp;strategy.&amp;nbsp;So&amp;nbsp;they&amp;nbsp;perform&amp;nbsp;better&amp;nbsp;if&amp;nbsp;requirements&amp;nbsp;suits&amp;nbsp;there&amp;nbsp;nature.&amp;nbsp;Similarly,&lt;br&gt;
CopyOnWriteArraySet&amp;nbsp;is&amp;nbsp;a&amp;nbsp;concurrent&amp;nbsp;replacement&amp;nbsp;to&amp;nbsp;Synchronized&amp;nbsp;Set.&amp;nbsp;&lt;br&gt;
&lt;br&gt;
3.&amp;nbsp;BlockingQueue&lt;br&gt;
BlockingQueue&amp;nbsp;is&amp;nbsp;also&amp;nbsp;one&amp;nbsp;of&amp;nbsp;better&amp;nbsp;known&amp;nbsp;collection&amp;nbsp;class&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;5.&amp;nbsp;BlockingQueue&amp;nbsp;makes&amp;nbsp;it&amp;nbsp;easy&lt;br&gt;
to&amp;nbsp;implement&amp;nbsp;producer-consumer&amp;nbsp;design&amp;nbsp;pattern&amp;nbsp;by&amp;nbsp;providing&amp;nbsp;inbuilt&amp;nbsp;blocking&amp;nbsp;support&amp;nbsp;for&amp;nbsp;put()&amp;nbsp;and&lt;br&gt;
take()&amp;nbsp;method.&amp;nbsp;put()&amp;nbsp;method&amp;nbsp;will&amp;nbsp;block&amp;nbsp;if&amp;nbsp;Queue&amp;nbsp;is&amp;nbsp;full&amp;nbsp;while&amp;nbsp;take()&amp;nbsp;method&amp;nbsp;will&amp;nbsp;block&amp;nbsp;if&amp;nbsp;Queue&amp;nbsp;is&lt;br&gt;
empty.&amp;nbsp;Java&amp;nbsp;5&amp;nbsp;API&amp;nbsp;provides&amp;nbsp;two&amp;nbsp;concrete&amp;nbsp;implementation&amp;nbsp;of&amp;nbsp;BlockingQueue&amp;nbsp;in&amp;nbsp;form&amp;nbsp;of&amp;nbsp;ArrayBlockingQueue&lt;br&gt;
and&amp;nbsp;LinkedBlockingQueue,&amp;nbsp;both&amp;nbsp;of&amp;nbsp;them&amp;nbsp;implement&amp;nbsp;FIFO&amp;nbsp;ordering&amp;nbsp;of&amp;nbsp;element.&amp;nbsp;ArrayBlockingQueue&amp;nbsp;is&lt;br&gt;
backed&amp;nbsp;by&amp;nbsp;Array&amp;nbsp;and&amp;nbsp;its&amp;nbsp;bounded&amp;nbsp;in&amp;nbsp;nature&amp;nbsp;while&amp;nbsp;LinkedBlockingQueue&amp;nbsp;is&amp;nbsp;optionally&amp;nbsp;bounded.&lt;br&gt;
Consider&amp;nbsp;using&amp;nbsp;BlockingQueue&amp;nbsp;to&amp;nbsp;solve&amp;nbsp;producer&amp;nbsp;Consumer&amp;nbsp;problem&amp;nbsp;in&amp;nbsp;Java&amp;nbsp;instead&amp;nbsp;of&amp;nbsp;writing&amp;nbsp;your&amp;nbsp;won&lt;br&gt;
wait-notify&amp;nbsp;code.&amp;nbsp;&lt;br&gt;
&lt;br&gt;
4.&amp;nbsp;Deque&amp;nbsp;and&amp;nbsp;BlockingDeque&lt;br&gt;
&lt;br&gt;
5.&amp;nbsp;ConcurrentSkipListMap&amp;nbsp;and&amp;nbsp;ConcurrentSkipListSet&lt;br&gt;
&lt;br&gt;
===========================================================&lt;br&gt;
From&amp;nbsp;java&amp;nbsp;se&amp;nbsp;Documentation&amp;nbsp;&lt;br&gt;
Concurrent&amp;nbsp;Collections&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;java.util.concurrent&amp;nbsp;package&amp;nbsp;includes&amp;nbsp;a&amp;nbsp;number&amp;nbsp;of&amp;nbsp;additions&amp;nbsp;to&amp;nbsp;the&amp;nbsp;Java&amp;nbsp;Collections&amp;nbsp;Framework.&lt;br&gt;
These&amp;nbsp;are&amp;nbsp;most&amp;nbsp;easily&amp;nbsp;categorized&amp;nbsp;by&amp;nbsp;the&amp;nbsp;collection&amp;nbsp;interfaces&amp;nbsp;provided:&lt;br&gt;
&lt;br&gt;
-&amp;nbsp;BlockingQueue&amp;nbsp;defines&amp;nbsp;a&amp;nbsp;first-in-first-out&amp;nbsp;data&amp;nbsp;structure&amp;nbsp;that&amp;nbsp;blocks&amp;nbsp;or&amp;nbsp;times&amp;nbsp;out&amp;nbsp;when&amp;nbsp;you&amp;nbsp;attempt&lt;br&gt;
to&amp;nbsp;add&amp;nbsp;to&amp;nbsp;a&amp;nbsp;full&amp;nbsp;queue,&amp;nbsp;or&amp;nbsp;retrieve&amp;nbsp;from&amp;nbsp;an&amp;nbsp;empty&amp;nbsp;queue.&lt;br&gt;
-&amp;nbsp;ConcurrentMap&amp;nbsp;is&amp;nbsp;a&amp;nbsp;subinterface&amp;nbsp;of&amp;nbsp;java.util.Map&amp;nbsp;that&amp;nbsp;defines&amp;nbsp;useful&amp;nbsp;atomic&amp;nbsp;operations.&lt;br&gt;
These&amp;nbsp;operations&amp;nbsp;remove&amp;nbsp;or&amp;nbsp;replace&amp;nbsp;a&amp;nbsp;key-value&amp;nbsp;pair&amp;nbsp;only&amp;nbsp;if&amp;nbsp;the&amp;nbsp;key&amp;nbsp;is&amp;nbsp;present,&amp;nbsp;or&amp;nbsp;add&amp;nbsp;a&amp;nbsp;key-value&lt;br&gt;
pair&amp;nbsp;only&amp;nbsp;if&amp;nbsp;the&amp;nbsp;key&amp;nbsp;is&amp;nbsp;absent.&amp;nbsp;Making&amp;nbsp;these&amp;nbsp;operations&amp;nbsp;atomic&amp;nbsp;helps&amp;nbsp;avoid&amp;nbsp;synchronization.&lt;br&gt;
The&amp;nbsp;standard&amp;nbsp;general-purpose&amp;nbsp;implementation&amp;nbsp;of&amp;nbsp;ConcurrentMap&amp;nbsp;is&amp;nbsp;&amp;nbsp;-&amp;nbsp;ConcurrentHashMap,&amp;nbsp;which&amp;nbsp;is&lt;br&gt;
a&amp;nbsp;concurrent&amp;nbsp;analog&amp;nbsp;of&amp;nbsp;HashMap.&lt;br&gt;
-&amp;nbsp;ConcurrentNavigableMap&amp;nbsp;is&amp;nbsp;a&amp;nbsp;subinterface&amp;nbsp;of&amp;nbsp;ConcurrentMap&amp;nbsp;that&amp;nbsp;supports&amp;nbsp;approximate&amp;nbsp;matches.&lt;br&gt;
The&amp;nbsp;standard&amp;nbsp;general-purpose&amp;nbsp;implementation&amp;nbsp;of&amp;nbsp;ConcurrentNavigableMap&amp;nbsp;is&amp;nbsp;ConcurrentSkipListMap,&lt;br&gt;
which&amp;nbsp;is&amp;nbsp;a&amp;nbsp;concurrent&amp;nbsp;analog&amp;nbsp;of&amp;nbsp;TreeMap.&lt;br&gt;
All&amp;nbsp;of&amp;nbsp;these&amp;nbsp;collections&amp;nbsp;help&amp;nbsp;avoid&amp;nbsp;Memory&amp;nbsp;Consistency&amp;nbsp;Errors&amp;nbsp;by&amp;nbsp;defining&amp;nbsp;a&amp;nbsp;happens-before&amp;nbsp;relationship&lt;br&gt;
between&amp;nbsp;an&amp;nbsp;operation&amp;nbsp;that&amp;nbsp;adds&amp;nbsp;an&amp;nbsp;object&amp;nbsp;to&amp;nbsp;the&amp;nbsp;collection&amp;nbsp;with&amp;nbsp;subsequent&amp;nbsp;operations&amp;nbsp;that&amp;nbsp;access&lt;br&gt;
or&amp;nbsp;remove&amp;nbsp;that&amp;nbsp;object.&lt;br&gt;
&lt;br&gt;
=============================================================&lt;br&gt;
StackOverflow&amp;nbsp;ConcurrentHashMap&lt;br&gt;
ConcurrentHashMap&amp;nbsp;allow&amp;nbsp;concurrent&amp;nbsp;access&amp;nbsp;to&amp;nbsp;the&amp;nbsp;map.&amp;nbsp;HashTables&amp;nbsp;too&amp;nbsp;offers&amp;nbsp;synchronized&amp;nbsp;access&lt;br&gt;
to&amp;nbsp;map,&amp;nbsp;but&amp;nbsp;your&amp;nbsp;entire&amp;nbsp;map&amp;nbsp;is&amp;nbsp;locked&amp;nbsp;to&amp;nbsp;perform&amp;nbsp;any&amp;nbsp;operation.&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;logic&amp;nbsp;behind&amp;nbsp;ConcurrentHashMap&amp;nbsp;is&amp;nbsp;that&amp;nbsp;your&amp;nbsp;entire&amp;nbsp;table&amp;nbsp;is&amp;nbsp;not&amp;nbsp;getting&amp;nbsp;locked,&amp;nbsp;but&amp;nbsp;only&amp;nbsp;the&lt;br&gt;
portion[segments].&amp;nbsp;Each&amp;nbsp;segments&amp;nbsp;manages&amp;nbsp;its&amp;nbsp;own&amp;nbsp;HashTable.&amp;nbsp;Locking&amp;nbsp;is&amp;nbsp;applied&amp;nbsp;only&amp;nbsp;for&amp;nbsp;updates.&lt;br&gt;
In&amp;nbsp;case&amp;nbsp;of&amp;nbsp;of&amp;nbsp;retrievals,&amp;nbsp;it&amp;nbsp;allows&amp;nbsp;full&amp;nbsp;concurrency.&lt;br&gt;
&lt;br&gt;
Let's&amp;nbsp;take&amp;nbsp;four&amp;nbsp;threads&amp;nbsp;are&amp;nbsp;concurrently&amp;nbsp;working&amp;nbsp;on&amp;nbsp;a&amp;nbsp;map&amp;nbsp;whose&amp;nbsp;capacity&amp;nbsp;is&amp;nbsp;32,&amp;nbsp;the&amp;nbsp;table&amp;nbsp;is&lt;br&gt;
partitioned&amp;nbsp;into&amp;nbsp;four&amp;nbsp;segments&amp;nbsp;where&amp;nbsp;each&amp;nbsp;segments&amp;nbsp;manages&amp;nbsp;a&amp;nbsp;hash&amp;nbsp;table&amp;nbsp;of&amp;nbsp;capacity.&amp;nbsp;The&lt;br&gt;
collection&amp;nbsp;maintains&amp;nbsp;a&amp;nbsp;list&amp;nbsp;of&amp;nbsp;16&amp;nbsp;segments&amp;nbsp;by&amp;nbsp;default,&amp;nbsp;each&amp;nbsp;of&amp;nbsp;which&amp;nbsp;is&amp;nbsp;used&amp;nbsp;to&amp;nbsp;guard&amp;nbsp;(or&amp;nbsp;lock&amp;nbsp;on)&amp;nbsp;a&lt;br&gt;
single&amp;nbsp;bucket&amp;nbsp;of&amp;nbsp;the&amp;nbsp;map.&lt;br&gt;
&lt;br&gt;
&lt;img&amp;nbsp;width='435'&amp;nbsp;height='204'&amp;nbsp;alt='image'&amp;nbsp;src='/data/images/ConcurrentHashMap.jpg'/&gt;&lt;br&gt;
&lt;br&gt;
This&amp;nbsp;effectively&amp;nbsp;means&amp;nbsp;that&amp;nbsp;16&amp;nbsp;threads&amp;nbsp;can&amp;nbsp;modify&amp;nbsp;the&amp;nbsp;collection&amp;nbsp;at&amp;nbsp;a&amp;nbsp;single&amp;nbsp;time.&amp;nbsp;This&amp;nbsp;level&amp;nbsp;of&lt;br&gt;
concurrency&amp;nbsp;can&amp;nbsp;be&amp;nbsp;increased&amp;nbsp;using&amp;nbsp;the&amp;nbsp;optional&amp;nbsp;concurrencyLevel&amp;nbsp;constructor&amp;nbsp;argument.&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;ConcurrentHashMap(int&amp;nbsp;initialCapacity,&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;float&amp;nbsp;loadFactor,&amp;nbsp;int&amp;nbsp;concurrencyLevel)&lt;br&gt;
!!!!&lt;br&gt;
As&amp;nbsp;the&amp;nbsp;other&amp;nbsp;answer&amp;nbsp;stated,&amp;nbsp;the&amp;nbsp;ConcurrentHashMap&amp;nbsp;offers&amp;nbsp;new&amp;nbsp;method&amp;nbsp;--&gt;&amp;nbsp;putIfAbsent()&amp;nbsp;which&amp;nbsp;is&lt;br&gt;
similar&amp;nbsp;to&amp;nbsp;put&amp;nbsp;except&amp;nbsp;the&amp;nbsp;value&amp;nbsp;will&amp;nbsp;not&amp;nbsp;be&amp;nbsp;overridden&amp;nbsp;if&amp;nbsp;the&amp;nbsp;key&amp;nbsp;exists.&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;Map&lt;String,String&gt;&amp;nbsp;aMap&amp;nbsp;=new&amp;nbsp;ConcurrentHashMap&lt;String,String&gt;();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(!aMap.contains("key"))&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;aMap.put("key","value");&lt;br&gt;
&lt;br&gt;
The&amp;nbsp;new&amp;nbsp;method&amp;nbsp;is&amp;nbsp;also&amp;nbsp;faster&amp;nbsp;as&amp;nbsp;it&amp;nbsp;avoids&amp;nbsp;double&amp;nbsp;traversing&amp;nbsp;as&amp;nbsp;above.&amp;nbsp;contains&amp;nbsp;method&amp;nbsp;has&amp;nbsp;to&lt;br&gt;
locate&amp;nbsp;the&amp;nbsp;segment&amp;nbsp;and&amp;nbsp;iterate&amp;nbsp;the&amp;nbsp;table&amp;nbsp;to&amp;nbsp;find&amp;nbsp;the&amp;nbsp;key&amp;nbsp;and&amp;nbsp;again&amp;nbsp;the&amp;nbsp;method&amp;nbsp;put&amp;nbsp;has&amp;nbsp;to&amp;nbsp;traverse&lt;br&gt;
the&amp;nbsp;bucket&amp;nbsp;and&amp;nbsp;put&amp;nbsp;the&amp;nbsp;key.&lt;br&gt;
========&lt;br&gt;
ConcurrentHashMap&amp;nbsp;example&amp;nbsp;:&lt;br&gt;
&lt;br&gt;
package&amp;nbsp;javautilconcurent.ConcurrentCollections;&lt;br&gt;
&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ConcurrentHashMap;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ConcurrentMap;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.ExecutorService;&lt;br&gt;
import&amp;nbsp;java.util.concurrent.Executors;&lt;br&gt;
&lt;br&gt;
public&amp;nbsp;class&amp;nbsp;ConcurrentCollectionsHello&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;String&amp;nbsp;CONCURRENCY_LEVEL_DEFAULT&amp;nbsp;=&amp;nbsp;"50";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;static&amp;nbsp;final&amp;nbsp;String&amp;nbsp;CONCURRENCY_KEY&amp;nbsp;=&amp;nbsp;"concurrency";&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private&amp;nbsp;ConcurrentMap&lt;Double,&amp;nbsp;Double&gt;&amp;nbsp;sqrtCache&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ConcurrentHashMap&lt;Double,&amp;nbsp;Double&gt;();&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;main(String[]&amp;nbsp;args)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;ConcurrentCollectionsHello&amp;nbsp;test&amp;nbsp;=&amp;nbsp;new&amp;nbsp;ConcurrentCollectionsHello();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;int&amp;nbsp;concurrencyLevel&amp;nbsp;=&amp;nbsp;10;&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;ExecutorService&amp;nbsp;executor&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(3);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;ExecutorService&amp;nbsp;executor1&amp;nbsp;=&amp;nbsp;Executors.newFixedThreadPool(3);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.execute(new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("helre");&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;concurrencyLevel;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;Double&amp;nbsp;d&amp;nbsp;=&amp;nbsp;Double.valueOf(i);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.execute(new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("sqrt&amp;nbsp;of&amp;nbsp;%s&amp;nbsp;=&amp;nbsp;%s&amp;nbsp;in&amp;nbsp;thread&amp;nbsp;%s%n",&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;d,&amp;nbsp;test.getSqrt(d),&amp;nbsp;Thread.currentThread()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(450);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i&amp;nbsp;=&amp;nbsp;0;&amp;nbsp;i&amp;nbsp;&lt;&amp;nbsp;concurrencyLevel;&amp;nbsp;i++)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final&amp;nbsp;Double&amp;nbsp;d&amp;nbsp;=&amp;nbsp;Double.valueOf(i);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor1.execute(new&amp;nbsp;Runnable()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;void&amp;nbsp;run()&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("sqrt&amp;nbsp;of&amp;nbsp;%s&amp;nbsp;=&amp;nbsp;%s&amp;nbsp;in&amp;nbsp;thread&amp;nbsp;%s%n",&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;d,&amp;nbsp;test.getSqrt(d),&amp;nbsp;Thread.currentThread()&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.getName());&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(450);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;catch&amp;nbsp;(InterruptedException&amp;nbsp;e)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.shutdown();&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public&amp;nbsp;double&amp;nbsp;getSqrt(Double&amp;nbsp;d)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Double&amp;nbsp;sqrt&amp;nbsp;=&amp;nbsp;sqrtCache.get(d);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(sqrt&amp;nbsp;==&amp;nbsp;null)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sqrt&amp;nbsp;=&amp;nbsp;Math.sqrt(d);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("calculated&amp;nbsp;sqrt&amp;nbsp;of&amp;nbsp;%s&amp;nbsp;=&amp;nbsp;%s%n",&amp;nbsp;d,&amp;nbsp;sqrt);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Double&amp;nbsp;existing&amp;nbsp;=&amp;nbsp;sqrtCache.putIfAbsent(d,&amp;nbsp;sqrt);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if&amp;nbsp;(existing&amp;nbsp;!=&amp;nbsp;null)&amp;nbsp;{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.printf("discard&amp;nbsp;calculated&amp;nbsp;sqrt&amp;nbsp;%s&amp;nbsp;and&amp;nbsp;use&amp;nbsp;the&amp;nbsp;cached&amp;nbsp;sqrt&amp;nbsp;%s",&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sqrt,&amp;nbsp;existing);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sqrt&amp;nbsp;=&amp;nbsp;existing;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}else{&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf("getting&amp;nbsp;sqrt&amp;nbsp;from&amp;nbsp;cacheee&amp;nbsp;of&amp;nbsp;%s&amp;nbsp;=&amp;nbsp;%s%n",&amp;nbsp;d,&amp;nbsp;sqrt);&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return&amp;nbsp;sqrt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Analyze&amp;nbsp;Output&amp;nbsp;))&lt;br&gt;</questionanswer>
  </question>
  <question id="1_0_0_3_0:30" type="2">
    <questiontext>&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java&amp;nbsp;Concurrency&amp;nbsp;:&amp;nbsp;Monitor&amp;nbsp;vs&amp;nbsp;Lock&amp;nbsp;,&amp;nbsp;describe.&lt;br&gt;
&amp;nbsp;&amp;nbsp;</questiontext>
    <questionanswer>&lt;br&gt;
In&amp;nbsp;concurrent&amp;nbsp;programming,&amp;nbsp;a&amp;nbsp;monitor&amp;nbsp;is&amp;nbsp;a&amp;nbsp;synchronization&amp;nbsp;construct&amp;nbsp;that&lt;br&gt;
allows&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;have&amp;nbsp;both&amp;nbsp;mutual&amp;nbsp;exclusion&amp;nbsp;and&amp;nbsp;the&amp;nbsp;ability&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;(block)&amp;nbsp;for&lt;br&gt;
a&amp;nbsp;certain&amp;nbsp;condition&amp;nbsp;to&amp;nbsp;become&amp;nbsp;true.&amp;nbsp;Monitors&amp;nbsp;also&amp;nbsp;have&amp;nbsp;a&amp;nbsp;mechanism&amp;nbsp;for&amp;nbsp;signalling&lt;br&gt;
other&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;their&amp;nbsp;condition&amp;nbsp;has&amp;nbsp;been&amp;nbsp;met.&amp;nbsp;In&amp;nbsp;essence,&amp;nbsp;a&amp;nbsp;monitor&amp;nbsp;&amp;nbsp;M&amp;nbsp;=&amp;nbsp;(m,&amp;nbsp;c)&amp;nbsp;!!&lt;br&gt;
is&amp;nbsp;a&amp;nbsp;pair&amp;nbsp;of&amp;nbsp;a&amp;nbsp;mutex&amp;nbsp;(lock)&amp;nbsp;object&amp;nbsp;m&amp;nbsp;and&amp;nbsp;a&amp;nbsp;condition&amp;nbsp;variable&amp;nbsp;c.&amp;nbsp;A&amp;nbsp;condition&amp;nbsp;variable&lt;br&gt;
is&amp;nbsp;basically&amp;nbsp;a&amp;nbsp;container&amp;nbsp;of&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;are&amp;nbsp;waiting&amp;nbsp;on&amp;nbsp;a&amp;nbsp;certain&amp;nbsp;condition.&amp;nbsp;Monitors&lt;br&gt;
provide&amp;nbsp;a&amp;nbsp;mechanism&amp;nbsp;for&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;temporarily&amp;nbsp;give&amp;nbsp;up&amp;nbsp;exclusive&amp;nbsp;access&amp;nbsp;in&amp;nbsp;order&lt;br&gt;
to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;some&amp;nbsp;condition&amp;nbsp;to&amp;nbsp;be&amp;nbsp;met,&amp;nbsp;before&amp;nbsp;regaining&amp;nbsp;exclusive&amp;nbsp;access&amp;nbsp;and&amp;nbsp;resuming&lt;br&gt;
their&amp;nbsp;task.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Another&amp;nbsp;definition&amp;nbsp;of&amp;nbsp;monitor&amp;nbsp;is&amp;nbsp;a&amp;nbsp;thread-safe&amp;nbsp;class,&amp;nbsp;object,&amp;nbsp;or&amp;nbsp;module&amp;nbsp;that&amp;nbsp;uses&amp;nbsp;wrapped&lt;br&gt;
mutual&amp;nbsp;exclusion&amp;nbsp;in&amp;nbsp;order&amp;nbsp;to&amp;nbsp;safely&amp;nbsp;allow&amp;nbsp;access&amp;nbsp;to&amp;nbsp;a&amp;nbsp;method&amp;nbsp;or&amp;nbsp;variable&amp;nbsp;by&amp;nbsp;more&amp;nbsp;than&lt;br&gt;
one&amp;nbsp;thread.&amp;nbsp;The&amp;nbsp;defining&amp;nbsp;characteristic&amp;nbsp;of&amp;nbsp;a&amp;nbsp;monitor&amp;nbsp;is&amp;nbsp;that&amp;nbsp;its&amp;nbsp;methods&amp;nbsp;are&amp;nbsp;executed&amp;nbsp;with&lt;br&gt;
mutual&amp;nbsp;exclusion:&amp;nbsp;At&amp;nbsp;each&amp;nbsp;point&amp;nbsp;in&amp;nbsp;time,&amp;nbsp;at&amp;nbsp;most&amp;nbsp;one&amp;nbsp;thread&amp;nbsp;may&amp;nbsp;be&amp;nbsp;executing&amp;nbsp;any&amp;nbsp;of&amp;nbsp;its&lt;br&gt;
methods.&amp;nbsp;Using&amp;nbsp;a&amp;nbsp;condition&amp;nbsp;variable(s),&amp;nbsp;it&amp;nbsp;can&amp;nbsp;also&amp;nbsp;provide&amp;nbsp;the&amp;nbsp;ability&amp;nbsp;for&amp;nbsp;threads&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;on&lt;br&gt;
a&amp;nbsp;certain&amp;nbsp;condition&amp;nbsp;(thus&amp;nbsp;using&amp;nbsp;the&amp;nbsp;above&amp;nbsp;definition&amp;nbsp;of&amp;nbsp;a&amp;nbsp;"monitor").&amp;nbsp;For&amp;nbsp;the&amp;nbsp;rest&amp;nbsp;of&amp;nbsp;this&lt;br&gt;
article,&amp;nbsp;this&amp;nbsp;sense&amp;nbsp;of&amp;nbsp;"monitor"&amp;nbsp;will&amp;nbsp;be&amp;nbsp;referred&amp;nbsp;to&amp;nbsp;as&amp;nbsp;a&amp;nbsp;"thread-safe&amp;nbsp;object/class/module"&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
======&lt;br&gt;
In&amp;nbsp;Java&amp;nbsp;every&amp;nbsp;Object&amp;nbsp;has&amp;nbsp;a&amp;nbsp;monitor&amp;nbsp;and&amp;nbsp;wait,&amp;nbsp;notify&amp;nbsp;methods&amp;nbsp;are&amp;nbsp;used&amp;nbsp;to&amp;nbsp;wait&amp;nbsp;for&amp;nbsp;the&amp;nbsp;Object&lt;br&gt;
monitor&amp;nbsp;or&amp;nbsp;to&amp;nbsp;notify&amp;nbsp;other&amp;nbsp;threads&amp;nbsp;that&amp;nbsp;Object&amp;nbsp;monitor&amp;nbsp;is&amp;nbsp;free&amp;nbsp;now.&amp;nbsp;There&amp;nbsp;is&amp;nbsp;no&amp;nbsp;monitor&amp;nbsp;on&lt;br&gt;
threads&amp;nbsp;in&amp;nbsp;java&amp;nbsp;and&amp;nbsp;synchronization&amp;nbsp;can&amp;nbsp;be&amp;nbsp;used&amp;nbsp;with&amp;nbsp;any&amp;nbsp;Object,&amp;nbsp;that’s&amp;nbsp;why&amp;nbsp;it’s&amp;nbsp;part&amp;nbsp;of&amp;nbsp;Object&lt;br&gt;
class&amp;nbsp;so&amp;nbsp;that&amp;nbsp;every&amp;nbsp;class&amp;nbsp;in&amp;nbsp;java&amp;nbsp;has&amp;nbsp;these&amp;nbsp;essential&amp;nbsp;methods&amp;nbsp;for&amp;nbsp;inter&amp;nbsp;thread&amp;nbsp;communication.&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
</questions>
