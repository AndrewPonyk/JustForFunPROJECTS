<?xml version="1.0" encoding="UTF-8"?>
<questions id="1_1_2_0" name="Gl_test" nofquestions="32" nofsubcategories="0" filename="gl_test1_1_2_0.xml">
  <question id="1_1_2_0:0" type="0">
    <questiontext>1)You need to write a code segment that transfers the contents of a byte 
    array named dataToSend by using a NetworkStream object named netStream. 
    You need to use a cache of size 8,192 bytes. Which code segment should you 
    use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ MemoryStream memStream = new MemoryStream(8192); 
netStream.Write(dataToSend, 0, (int) memStream.Length); $v0end$&lt;br&gt;
$v1$ 
    MemoryStream memStream = new MemoryStream(8192);
 memStream.Write(dataToSend, 0, (int) netStream.Length); $v1end$&lt;br&gt;
$v2$ 
    BufferedStream bufStream = new BufferedStream(netStream);
 bufStream.Write(dataToSend, 0, 8192); $v2end$&lt;br&gt;
$v3$ BufferedStream 
    bufStream = new BufferedStream(netStream, 8192);
 bufStream.Write(dataToSend, 0, dataToSend.Length); $v3end$&lt;br&gt;
$vend$</questiontext>
    <questionanswer>3&lt;br&gt;
&lt;br&gt;</questionanswer>
  </question>
  <question id="1_1_2_0:1" type="0">
    <questiontext>You are using the Microsoft Visual Studio 2005 IDE to examine the output 
    of a method that returns a string. 
You assign the output of the method to a string variable named fName. 
You need to write a code segment that prints the following on a single line.
The message: &amp;quot;Test Failed: &amp;quot;. The value of fName if the value of fName does 
    not equal &amp;quot;Company&amp;quot;. 
You also need to ensure that the code segment simultaneously facilitates 
    uninterrupted execution of the application. 

Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ Debug.Assert(fName == 
    &amp;#8220;Company&amp;#8221;, &amp;#8220;Test Failed: &amp;#8221;, fName); $v0end$&lt;br&gt;
$v1$ 
    
if (fName != &amp;quot;Company&amp;quot;) {
Debug.Print(&amp;#8220;Test Failed: &amp;#8221;);
Debug.Print(fName);
} 
$v1end$&lt;br&gt;
$v2$
if (fName != &amp;quot;Company&amp;quot;) {
Debug.WriteLine(&amp;#8220;Test Failed: &amp;#8221;);
Debug.WriteLine(fName);
}
$v2end$&lt;br&gt;
$v3$
Debug.WriteLineIf(fName != &amp;#8220;Company&amp;#8221;, fName, &amp;#8220;Test Failed&amp;#8221;);
$v3end$&lt;br&gt;
$vend$</questiontext>
    <questionanswer>3</questionanswer>
  </question>
  <question id="1_1_2_0:2" type="0">
    <questiontext>&lt;br&gt;
    Your application uses two threads, named threadOne and threadTwo. You need &lt;br&gt;
    to modify the code to prevent the execution of threadOne until threadTwo &lt;br&gt;
    completes execution. What should you do?&lt;br&gt;
$v$&lt;br&gt;
$v0$ Use a WaitCallback &lt;br&gt;
    delegate to synchronize the threads. $v0end$&lt;br&gt;
$v1$Call the SpinLock &lt;br&gt;
    method of threadOne.$v1end$&lt;br&gt;
$v2$Configure threadOne to run at a lower &lt;br&gt;
    priority.$v2end$&lt;br&gt;
$v3$Call the Sleep method of threadOne.$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>0</questionanswer>
  </question>
  <question id="1_1_2_0:3" type="0">
    <questiontext>&lt;br&gt;
    You are writing code for user authentication and authorization. &lt;br&gt;
The username, password, and roles are stored in your application data store.&lt;br&gt;
You need to establish a user security context that will be used for &lt;br&gt;
    authorization checks such as IsInRole. &lt;br&gt;
&lt;br&gt;
You write the following code segment to authorize the user.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
if (!TestPassword(userName, password))&lt;br&gt;
throw new Exception(&amp;#8220;could not authenticate user&amp;#8221;);&lt;br&gt;
String[] userRolesArray = LookupUserRoles(userName);&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
You need to complete this code so that it establishes the&lt;br&gt;
user security context. &lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
NTAccount userNTName = new NTAccount(userName);&lt;br&gt;
GenericIdentity ident = new GenericIdentity(userNTName.Value);&lt;br&gt;
GenericPrincipal currentUser= new GenericPrincipal(ident, userRolesArray);&lt;br&gt;
Thread.CurrentPrincipal = currentUser; &lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
GenericIdentity ident = new GenericIdentity(userName);&lt;br&gt;
GenericPrincipal currentUser = new GenericPrincipal(ident, userRolesArray);&lt;br&gt;
Thread.CurrentPrincipal = currentUser;&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
IntPtr token = IntPtr.Zero;&lt;br&gt;
token = LogonUserUsingInterop(username,encryptedPassword);&lt;br&gt;
WindowsImpersonationContext ctx =WindowsIdentity.Impersonate(token);&lt;br&gt;
$v2end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:4" type="0">
    <questiontext>&lt;br&gt;
    You write the following code to call a function from the Win32 Application &lt;br&gt;
    Programming Interface (API) by using platform invoke.&lt;br&gt;
&lt;br&gt;
int rc = MessageBox(hWnd, text, caption, type); &lt;br&gt;
&lt;br&gt;
You need to define a methon prototype.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
&lt;br&gt;
$v$&lt;br&gt;
$v0$ [DllImport(&amp;quot;user32&amp;quot;)]public static extern int MessageBoxA(int &lt;br&gt;
    hWnd, String text,String caption, uint type); $v0end$&lt;br&gt;
$v1$ &lt;br&gt;
    [DllImport(&amp;quot;user32&amp;quot;)]public static extern int &lt;br&gt;
    Win32API_User32_MessageBox(int hWnd, String text, String caption, uint &lt;br&gt;
    type);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$ &lt;br&gt;
[DllImport(@&amp;quot;C:\WINDOWS\system32\user32.dll&amp;quot;)]public static extern &lt;br&gt;
    intMessageBox(int hWnd, String text,String caption, uint type); $v2end$&lt;br&gt;
$v3$ &lt;br&gt;
    [DllImport(&amp;quot;user32&amp;quot;)]public static extern int MessageBox(int hWnd, String &lt;br&gt;
    text,String caption, uint type); $v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>3</questionanswer>
  </question>
  <question id="1_1_2_0:5" type="0">
    <questiontext>&lt;br&gt;
    You need to identify a type that meets the following criteria: &lt;br&gt;
&lt;br&gt;
- Is always a number.&lt;br&gt;
- Is not greater than 65,535. &lt;br&gt;
&lt;br&gt;
Which type should you choose?&lt;br&gt;
$v$&lt;br&gt;
$v0$ int $v0end$&lt;br&gt;
$v1$ &lt;br&gt;
    System.IntPtr$v1end$&lt;br&gt;
$v2$ System.UInt16$v2end$&lt;br&gt;
$v3$ &lt;br&gt;
    System.String$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>2</questionanswer>
  </question>
  <question id="1_1_2_0:6" type="0">
    <questiontext>&lt;br&gt;
    You are developing a class library. Portions of your code need to access &lt;br&gt;
    system environment&lt;br&gt;
variables.&lt;br&gt;
You need to force a runtime SecurityException only when callers that are &lt;br&gt;
    higher in the call stack&lt;br&gt;
do not have the necessary permissions.&lt;br&gt;
Which call method should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ Assert()$v0end$&lt;br&gt;
$v1$ &lt;br&gt;
    Demand()$v1end$&lt;br&gt;
$v2$ Deny()$v2end$&lt;br&gt;
$v3$ PermitOnly()$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:7" type="0">
    <questiontext>&lt;br&gt;
    You need to write a code segment that transfers the first 80 bytes from a &lt;br&gt;
    stream variable named stream1 into a new byte array named byteArray. &lt;br&gt;
You also need to ensure that the code segment assigns the number of bytes that &lt;br&gt;
    are transferred to an integer variable named bytesTransferred.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
&lt;br&gt;
$v$&lt;br&gt;
$v0$ bytesTransferred = stream1.Read(byteArray, 0, 80); $v0end$&lt;br&gt;
$v1$ &lt;br&gt;
    &lt;br&gt;
while (bytesTransferred &lt; 80) {&lt;br&gt;
stream1.Seek(1, SeekOrigin.Current);&lt;br&gt;
byteArray[bytesTransferred++] =&lt;br&gt;
Convert.ToByte(stream1.ReadByte());}&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
stream1.Write(byteArray, 0, 80);&lt;br&gt;
bytesTransferred = byteArray.Length;&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
for (int i = 0; i &lt; 80; i++) {&lt;br&gt;
stream1.WriteByte(byteArray[i]);&lt;br&gt;
bytesTransferred = i;&lt;br&gt;
if (!stream1.CanWrite) {&lt;br&gt;
break;&lt;br&gt;
}}&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>0</questionanswer>
  </question>
  <question id="1_1_2_0:8" type="0">
    <questiontext>&lt;br&gt;
    You are writing an application that uses SOAP to exchange data with other &lt;br&gt;
    applications. &lt;br&gt;
You use a Department class that inherits from ArrayList to send objects to &lt;br&gt;
    another application.&lt;br&gt;
The Department object is named dept. &lt;br&gt;
You need to ensure that the application serializes the Department object for &lt;br&gt;
    transport by using SOAP. &lt;br&gt;
&lt;br&gt;
Which code should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
SoapFormatter formatter = new SoapFormatter();&lt;br&gt;
byte[] buffer = new byte[dept.Capacity];&lt;br&gt;
MemoryStream stream = new MemoryStream(buffer);&lt;br&gt;
foreach (object o in dept) {&lt;br&gt;
  formatter.Serialize(stream, o);&lt;br&gt;
}&lt;br&gt;
 $v0end$&lt;br&gt;
$v1$&lt;br&gt;
SoapFormatter formatter = new SoapFormatter();&lt;br&gt;
byte[] buffer = new byte[dept.Capacity];&lt;br&gt;
MemoryStream stream = new MemoryStream(buffer);&lt;br&gt;
formatter.Serialize(stream, dept);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
SoapFormatter formatter = new SoapFormatter();&lt;br&gt;
MemoryStream stream = new MemoryStream();&lt;br&gt;
foreach (object o in dept) {&lt;br&gt;
  Formatter.Serialize(stream, o);&lt;br&gt;
}&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
SoapFormatter formatter = new SoapFormatter();&lt;br&gt;
MemoryStream stream = new MemoryStream();&lt;br&gt;
formatter.Serialize(stream, dept);&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>3</questionanswer>
  </question>
  <question id="1_1_2_0:9" type="0">
    <questiontext>&lt;br&gt;
    You are writing a method to compress an array of bytes.&lt;br&gt;
The bytes to be compressed are passed to the method in a parameter named &lt;br&gt;
    document.&lt;br&gt;
You need to compress the contents of the incoming parameter.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
MemoryStream inStream = new MemoryStream(document);&lt;br&gt;
GZipStream zipStream = new GZipStream(inStream,CompressionMode.Compress); &lt;br&gt;
MemoryStream outStream = new MemoryStream();&lt;br&gt;
       int b;&lt;br&gt;
           while((b = zipStream.ReadByte()) != -1) {&lt;br&gt;
           outStream.WriteByte((byte)b);&lt;br&gt;
       } &lt;br&gt;
return outStream.ToArray();&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
MemoryStream Stream = new MemoryStream(document);&lt;br&gt;
    GZipStream zipStream = new GZipStream(stream,CompressionMode.Compress);&lt;br&gt;
    zipStream.Write(document, 0,document.Length);&lt;br&gt;
    zipStream.Close();&lt;br&gt;
return stream.ToArray();&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
MemoryStream outStream = new MemoryStream();&lt;br&gt;
   GZipStream zipStream = new GZipStream(outStream,CompressionMode.Compress);&lt;br&gt;
   zipStream.Write(document, 0,document.Length);&lt;br&gt;
   zipStream.Close();&lt;br&gt;
return outStream.ToArray();&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
MemoryStream inStream = new MemoryStream(document);&lt;br&gt;
    GZipStream zipStream = new GZipStream(inStream,CompressionMode.Compress);&lt;br&gt;
    byte[] result = new Byte[document.Length];&lt;br&gt;
    zipStream.Write(result, 0, result.Length);&lt;br&gt;
return result;&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>2</questionanswer>
  </question>
  <question id="1_1_2_0:10" type="0">
    <questiontext>&lt;br&gt;
    You are developing an application for a client residing in Hong Kong.&lt;br&gt;
You need to display negative currency values by using a minus sign. &lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
CultureInfo culture = new CultureInfo(&amp;#8220;zh-HK&amp;#8221;);&lt;br&gt;
    return numberToPrint.ToString(&amp;#8220;-(0)&amp;#8221;, culture);&lt;br&gt;
 $v0end$&lt;br&gt;
$v1$&lt;br&gt;
CultureInfo culture = new CultureInfo(&amp;#8220;zh-HK&amp;#8221;);&lt;br&gt;
    return numberToPrint.ToString(&amp;#8220;()&amp;#8221;, culture);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
NumberFormatInfo culture = new CultureInfo(&amp;#8220;zh-HK&amp;#8221;).NumberFormat;&lt;br&gt;
    culture.NumberNegativePattern = 1;&lt;br&gt;
    return numberToPrint.ToString(&amp;#8220;C&amp;#8221;, culture);&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
NumberFormatInfo culture = new CultureInfo(&amp;#8220;zh-HK&amp;#8221;).NumberFormat;&lt;br&gt;
    culture.CurrencyNegativePattern = 1;&lt;br&gt;
    return numberToPrint.ToString(&amp;#8220;C&amp;#8221;, culture);&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>3</questionanswer>
  </question>
  <question id="1_1_2_0:11" type="0">
    <questiontext>&lt;br&gt;
    You are creating a new security policy for an application domain. You &lt;br&gt;
    write the following lines of code. &lt;br&gt;
PolicyLevel policy = PolicyLevel.CreateAppDomainLevel();&lt;br&gt;
PolicyStatement noTrustStatement = new &lt;br&gt;
    PolicyStatement(policy.GetNamedPermissionSet(&amp;#8220;Nothing&amp;#8221;));&lt;br&gt;
PolicyStatement fullTrustStatement = new &lt;br&gt;
    PolicyStatement(policy.GetNamedPermissionSet(&amp;#8220;FullTrust&amp;#8221;));&lt;br&gt;
You need to arrange code groups for the policy so that loaded assemblies &lt;br&gt;
    default to the Nothing permission set. If the assembly originates from a &lt;br&gt;
    trusted zone, the security policy must grant the assembly the FullTrust &lt;br&gt;
    permission set. &lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$&lt;br&gt;
CodeGroup ^group = new FirstMatchCodeGroup(gcnew &lt;br&gt;
    AllMembershipCondition(),noTrustStatement);&lt;br&gt;
 $v0end$&lt;br&gt;
$v1$&lt;br&gt;
CodeGroup ^group = new UnionCodeGroup(gcnew &lt;br&gt;
    ZoneMembershipCondition(SecurityZone::Trusted),fullTrustStatement);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
CodeGroup ^group1 = new FirstMatchCodeGroup(gcnew &lt;br&gt;
    AllMembershipCondition(),noTrustStatement); &lt;br&gt;
CodeGroup ^group2 = gcnew UnionCodeGroup(gcnew &lt;br&gt;
    ZoneMembershipCondition(SecurityZone::Trusted),fullTrustStatement); &lt;br&gt;
group1-&gt;AddChild(group2);&lt;br&gt;
$v2end$&lt;br&gt;
$v3$$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>2</questionanswer>
  </question>
  <question id="1_1_2_0:12" type="0">
    <questiontext>&lt;br&gt;
    You create a method that runs by using the credentials of the end user. &lt;br&gt;
You need to use Microsoft Windows groups to authorize the user. &lt;br&gt;
You must add a code segment that identifies whether a user is in the local &lt;br&gt;
    group named Clerk. &lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$  &lt;br&gt;
WindowsIdentity currentUser = WindowsIdentity.GetCurrent();&lt;br&gt;
foreach(IdentityReference grp in currentUser.Groups) {&lt;br&gt;
  NTAccount grpAccount =((NTAccount)grp.Translate(typeof(NTAccount)));&lt;br&gt;
  isAuthorized = grpAccount.Value.Equals(Environment.MachineName + @&amp;#8221;\Clerk&amp;#8221;);&lt;br&gt;
  if(isAuthorized)&lt;br&gt;
  break;&lt;br&gt;
}&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
WindowsPrincipal currentUser =(WindowsPrincipal)Thread.CurrentPrincipal;&lt;br&gt;
isAuthorized = currentUser.IsInRole(&amp;#8220;Clerk&amp;#8221;);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
WindowsPrincipal currentUser =(WindowsPrincipal)Thread.CurrentPrincipal;&lt;br&gt;
isAuthorized =currentUser.IsInRole(Environment.MachineName);&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
GenericPrincipal currentUser =(GenericPrincipal)Thread.CurrentPrincipal;&lt;br&gt;
isAuthorized = currentUser.IsInRole(&amp;#8220;Clerk&amp;#8221;);&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:13" type="0">
    <questiontext>&lt;br&gt;
    You create an application that stores information about your customers who &lt;br&gt;
    reside in various regions. &lt;br&gt;
You are developing internal utilities for this application.&lt;br&gt;
You need to gather regional information about your customers in Canada.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ CultureInfo cultureInfo = &lt;br&gt;
    new CultureInfo(&amp;#8220;CA&amp;#8221;); // Output the region information&amp;#8230; $v0end$&lt;br&gt;
$v1$&lt;br&gt;
foreach (CultureInfo culture in &lt;br&gt;
    CultureInfo.GetCultures(CultureTypes.SpecificCultures)) { &lt;br&gt;
//Output the region information...&lt;br&gt;
}&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
RegionInfo regionInfo = new RegionInfo(&amp;#8220;&amp;#8221;);if(regionInfo.Name == &amp;#8220;CA&amp;#8221;) {&lt;br&gt;
// Output the region information...}&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
RegionInfo regionInfo = new RegionInfo(&amp;#8220;CA&amp;#8221;); // Output the region information&amp;#8230;&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>3</questionanswer>
  </question>
  <question id="1_1_2_0:14" type="0">
    <questiontext>&lt;br&gt;
    You are loading a new assembly into an application. &lt;br&gt;
You need to override the default evidence for the assembly. &lt;br&gt;
You require the common language runtime (CLR) to grant the assembly a&lt;br&gt;
permission set, as if the assembly were loaded from the local intranet zone.&lt;br&gt;
You need to build the evidence collection. &lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
Evidence evidence = new Evidence(Assembly.GetExecutingAssembly().Evidence);&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
Evidence evidence = new Evidence(AppDomain.CurrentDomain.Evidence);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
Evidence evidence = new Evidence();&lt;br&gt;
evidence.AddAssembly(new Zone(SecurityZone.Intranet));&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
Evidence evidence = new Evidence();&lt;br&gt;
evidence.AddHost(new Zone(SecurityZone.Intranet));&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>3</questionanswer>
  </question>
  <question id="1_1_2_0:15" type="0">
    <questiontext>You are creating a new security policy for an application domain. You &lt;br&gt;
    write the following lines of code.&lt;br&gt; &lt;br&gt;

Dim objPolicy As PolicyLevel = PolicyLevel.CreateAppDomainLevelDim&lt;br&gt;
noTrustStatement As New PolicyStatement( &lt;br&gt;
    _objPolicy.GetNamedPermissionSet(&amp;quot;Nothing&amp;quot;))&lt;br&gt;
Dim fullTrustStatement As New PolicyStatement( &lt;br&gt;
    _objPolicy.GetNamedPermissionSet(&amp;quot;FullTrust&amp;quot;))&lt;br&gt; &lt;br&gt;

You need to arrange code groups for the policy so that loaded assemblies &lt;br&gt;
    default to the Nothing permission set.&lt;br&gt;
If the assembly originates from a trusted zone, the security policy must grant &lt;br&gt;
    the assembly the FullTrust permission set.&lt;br&gt;

Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ 
Dim objGroup1 As CodeGroup = New FirstMatchCodeGroup&lt;br&gt;
(_New ZoneMembershipCondition(SecurityZone.Trusted), _fullTrustStatement)&lt;br&gt;
Dim objGroup2 As CodeGroup = New UnionCodeGroup( _New AllMembershipCondition, &lt;br&gt;
    noTrustStatement)&lt;br&gt;
$v0end$&lt;br&gt;
$v1$
Dim objGroup1 As CodeGroup = New FirstMatchCodeGroup( _New &lt;br&gt;
    AllMembershipCondition, noTrustStatement)&lt;br&gt;
Dim objGroup2 As CodeGroup = New UnionCodeGroup( _New &lt;br&gt;
    ZoneMembershipCondition(SecurityZone.Trusted), _fullTrustStatement)&lt;br&gt;
$v1end$&lt;br&gt;
$v2$
Dim objGroup As CodeGroup = New FirstMatchCodeGroup( _New &lt;br&gt;
    ZoneMembershipCondition(SecurityZone.Trusted), _fullTrustStatement)&lt;br&gt;
$v2end$&lt;br&gt;
$v3$
Dim objGroup As CodeGroup = New UnionCodeGroup( _New &lt;br&gt;
    ZoneMembershipCondition(SecurityZone.Trusted), _fullTrustStatement)&lt;br&gt;
$v3end$&lt;br&gt;
$vend$</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:16" type="0">
    <questiontext>&lt;br&gt;
    You create an application to send a message by e-mail.&lt;br&gt;
An SMTP server is available on the local subnet.&lt;br&gt;
The SMTP server is named smtp.Company.com&lt;br&gt;
To test the application, you use a source address, me@Company.com, and a &lt;br&gt;
    target address, you@Company.com.&lt;br&gt;
You need to transmit the e-mail message.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
MailAddress addrFrom = new MailAddress(&amp;#8220;me@Company.com&amp;#8221;, &amp;#8220;Me&amp;#8221;);&lt;br&gt;
&lt;br&gt;
MailAddress addrTo = new MailAddress(&amp;#8220;you@Company.com&amp;#8221;, &amp;#8220;You&amp;#8221;);&lt;br&gt;
&lt;br&gt;
MailMessage message = new MailMessage(addrFrom, addrTo);&lt;br&gt;
&lt;br&gt;
    message.Subject = &amp;#8220;Greetings!&amp;#8221;;&lt;br&gt;
&lt;br&gt;
    message.Body =&amp;#8220;Test&amp;#8221;;&lt;br&gt;
&lt;br&gt;
    message.Dispose();&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
MailAddress addrFrom = new MailAddress(&amp;#8220;me@Company.com&amp;#8221;, &amp;#8220;Me&amp;#8221;);&lt;br&gt;
&lt;br&gt;
MailAddress addrTo = new MailAddress(&amp;#8220;you@Company.com&amp;#8221;, &amp;#8220;You&amp;#8221;);&lt;br&gt;
&lt;br&gt;
MailMessage message = new MailMessage(addrFrom, addrTo);&lt;br&gt;
&lt;br&gt;
message.Subject = &amp;#8220;Greetings!&amp;#8221;;&lt;br&gt;
&lt;br&gt;
message.Body = &amp;#8220;Test&amp;#8221;;&lt;br&gt;
&lt;br&gt;
SocketInformation info = new SocketInformation();&lt;br&gt;
&lt;br&gt;
Socket client = new Socket(info);&lt;br&gt;
&lt;br&gt;
System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();&lt;br&gt;
&lt;br&gt;
byte[] msgBytes = enc.GetBytes(message.ToString());&lt;br&gt;
&lt;br&gt;
client.Send(msgBytes);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
MailAddress addrFrom = new MailAddress(&amp;#8220;me@Company.com&amp;#8221;);&lt;br&gt;
&lt;br&gt;
MailAddress addrTo = new MailAddress(&amp;#8220;you@Company.com&amp;#8221;);&lt;br&gt;
&lt;br&gt;
MailMessage message = new MailMessage(addrFrom,addrTo);&lt;br&gt;
&lt;br&gt;
message.Subject = &amp;#8220;Greetings!&amp;#8221;;&lt;br&gt;
&lt;br&gt;
message.Body = &amp;#8220;Test&amp;#8221;;&lt;br&gt;
&lt;br&gt;
SmtpClient client = new SmtpClient(&amp;#8220;smtp.Company.com&amp;#8221;);&lt;br&gt;
&lt;br&gt;
client.Send(message);&lt;br&gt;
$v2end$&lt;br&gt;
$v3$$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>2</questionanswer>
  </question>
  <question id="1_1_2_0:17" type="0">
    <questiontext>&lt;br&gt;
    You need to create a dynamic assembly named MyAssembly.&lt;br&gt;
You also need to save the assembly to disk.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
AssemblyName myAssemblyName = new AssemblyName();&lt;br&gt;
&lt;br&gt;
AssemblyBuilder myAssemblyBuilder = &lt;br&gt;
    AppDomain.CurrentDomain.DefineDynamicAssembly(myAssemblyName,AssemblyBuilderAccess.RunAndSave);&lt;br&gt;
&lt;br&gt;
myAssemblyBuilder.Save(&amp;#8220;MyAssembly.dll&amp;#8221;);&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
AssemblyName myAssemblyName = new AssemblyName();&lt;br&gt;
&lt;br&gt;
myAssemblyName.Name = &amp;#8220;MyAssembly&amp;#8221;;&lt;br&gt;
AssemblyBuilder myAssemblyBuilder = &lt;br&gt;
    AppDomain.CurrentDomain.DefineDynamicAssembly(myAssemblyName,AssemblyBulderAccess.Save);&lt;br&gt;
myAssemblyBuilder.Save(&amp;#8220;MyAssembly.dll&amp;#8221;);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
AssemblyName myAssemblyName = new AssemblyName();&lt;br&gt;
&lt;br&gt;
myAssemblyName.Name = &amp;#8220;MyAssembly&amp;#8221;;&lt;br&gt;
AssemblyBuilder myAssemblyBuilder = &lt;br&gt;
    AppDomain.CurrentDomain.DefineDynamicAssembly(myAssemblyName,AssemblyBuilderAccess.Run);&lt;br&gt;
myAssemblyBuilder.Save(&amp;#8220;MyAssembly.dll&amp;#8221;);&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:18" type="0">
    <questiontext>&lt;br&gt;
    You are creating a class that performs complex financial calculations.&lt;br&gt;
The class contains a method named GetCurrentRate that retrieves the current &lt;br&gt;
    interest rate and a variable named currRate that stores the current &lt;br&gt;
    interest rate.You write serialized representations of the class. You need &lt;br&gt;
    to write a code segment that updates the currRate variable with the &lt;br&gt;
    current interest rate&lt;br&gt;
when an instance of the class is deserialized.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
[OnDeserializing]internal void UpdateValue(SerializationInfo info) {&lt;br&gt;
info.AddValue(&amp;#8220;currentRate&amp;#8221;, GetCurrentRate());}&lt;br&gt;
 $v0end$&lt;br&gt;
$v1$&lt;br&gt;
[OnSerializing]internal void UpdateValue(SerializationInfo info) { &lt;br&gt;
info.AddValue(&amp;#8220;currentRate&amp;#8221;, GetCurrentRate());}&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
[OnDeserialized]internal void UpdateValue(StreamingContext context) {&lt;br&gt;
currRate = GetCurrentRate();}&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
[OnSerializing]internal void UpdateValue (StreamingContext context) {&lt;br&gt;
currRate = GetCurrentRate();}&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>2</questionanswer>
  </question>
  <question id="1_1_2_0:19" type="0">
    <questiontext>&lt;br&gt;
    You need to write a code segment that will create a common language &lt;br&gt;
    runtime (CLR) unit of isolation within an application.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
System.ComponentModel.Component myComponent;&lt;br&gt;
&lt;br&gt;
myComponent = new System.ComponentModel.Component();&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
System.Diagnostics.Process myProcess;&lt;br&gt;
&lt;br&gt;
myProcess = new System.Diagnostics.Process();&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
AppDomainSetup mySetup =AppDomain.CurrentDomain.SetupInformation;&lt;br&gt;
&lt;br&gt;
mySetup.ShadowCopyFiles = &amp;#8220;true&amp;#8221;;&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
AppDomain domain;&lt;br&gt;
&lt;br&gt;
domain = AppDomain.CreateDomain(&amp;#8220;CompanyDomain&amp;#8221;):&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>3</questionanswer>
  </question>
  <question id="1_1_2_0:20" type="0">
    <questiontext>&lt;br&gt;
    You need to generate a report that lists language codes and region codes.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
 foreach (CultureInfo culture in &lt;br&gt;
    CultureInfo.GetCultures(CultureTypes.SpecificCultures)) { &lt;br&gt;
    // Output the culture information...} &lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
CultureInfo culture = new CultureInfo(&amp;#8220;&amp;#8221;); CultureTypes types = &lt;br&gt;
    culture.CultureTypes; &lt;br&gt;
    // Output the culture information... &lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
 foreach (CultureInfo culture in &lt;br&gt;
    CultureInfo.GetCultures(CultureTypes.NeutralCultures)) { &lt;br&gt;
    // Output the culture information...} &lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
foreach (CultureInfo culture in &lt;br&gt;
    CultureInfo.GetCultures(CultureTypes.ReplacementCultures)) { &lt;br&gt;
    // Output the culture information...} &lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>0</questionanswer>
  </question>
  <question id="1_1_2_0:21" type="0">
    <questiontext>&lt;br&gt;
    You are writing a custom dictionary. The custom-dictionary class is named &lt;br&gt;
    MyDictionary. You&lt;br&gt;
need to ensure that the dictionary is type safe.&lt;br&gt;
Which code segment should you use?&lt;br&gt;
&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
class MyDictionary : HashTable&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
class MyDictionary : Dictionary&lt;string, string&gt;&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
class MyDictionary : IDictionary&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
class MyDictionary { ... }&lt;br&gt;
Dictionary&lt;string, string&gt; t =&lt;br&gt;
&lt;br&gt;
   new Dictionary&lt;string, string&gt;();&lt;br&gt;
&lt;br&gt;
MyDictionary dictionary = (MyDictionary)t;&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:22" type="0">
    <questiontext>&lt;br&gt;
    You are changing the security settings of a file named MyData.xml.&lt;br&gt;
You need to preserve the existing inherited access rules. &lt;br&gt;
You also need to prevent the access rules from inheriting changes in the &lt;br&gt;
    future.&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
FileSecurity security = &lt;br&gt;
   new FileSecurity(&amp;quot;mydata.xml&amp;quot;,AccessControlSections.All);&lt;br&gt;
security.SetAccessRuleProtection(true,true);&lt;br&gt;
File.SetAccessControl(&amp;#8220;mydata.xml&amp;#8221;, security);&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
FileSecurity security = File.GetAccessControl(&amp;#8220;mydata.xml&amp;#8221;);&lt;br&gt;
security.SetAuditRuleProtection(true,true);&lt;br&gt;
File.SetAccessControl(&amp;#8220;mydata.xml&amp;#8221;, security);&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
FileSecurity security = new FileSecurity();&lt;br&gt;
security.SetAccessRuleProtection(true,true);&lt;br&gt;
File.SetAccessControl(&amp;#8220;mydata.xml&amp;#8221;, security);&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
FileSecurity security = File.GetAccessControl(&amp;#8220;mydata.xml&amp;#8221;);&lt;br&gt;
security.SetAccessRuleProtection(true, true);&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>0</questionanswer>
  </question>
  <question id="1_1_2_0:23" type="0">
    <questiontext>&lt;br&gt;
    You write a class named Employee that includes the following code segment. &lt;br&gt;
&lt;br&gt;
public class&lt;br&gt;
Employee {&lt;br&gt;
string employeeId, employeeName, jobTitleName;&lt;br&gt;
public string GetName() { return employeeName; }&lt;br&gt;
public string GetTitle() { return jobTitleName; } &lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
You need to expose this class to COM in a type library. &lt;br&gt;
The COM interface must also facilitate forward-compatibility across new &lt;br&gt;
    versions of the Employee class. &lt;br&gt;
You need to choose a method for generating the COM interface.&lt;br&gt;
&lt;br&gt;
What should you do?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
Add the following attribute to the class definition.&lt;br&gt;
[ClassInterface(ClassInterfaceType.None)]&lt;br&gt;
public class Employee {}&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
Define an interface for the class and add the following attribute to the class &lt;br&gt;
    definition.&lt;br&gt;
[ClassInterface(ClassInterfaceType.None)]&lt;br&gt;
public class Employee : IEmployee&lt;br&gt;
{}&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
Add the following attribute to the class definition.&lt;br&gt;
[ComVisible(true)]&lt;br&gt;
public class Employee {}&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
Add the following attribute to the class definition.&lt;br&gt;
[ClassInterface(ClassInterfaceType.AutoDual)]&lt;br&gt;
public class Employee {}&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:24" type="0">
    <questiontext>&lt;br&gt;
    You are developing an application to assist the user in conducting &lt;br&gt;
    electronic surveys. &lt;br&gt;
The survey consists of 25 true-or-false questions. &lt;br&gt;
You need to perform the following tasks: Initialize each answer to true.&lt;br&gt;
Minimize the amount of memory used by each survey. &lt;br&gt;
&lt;br&gt;
Which storage option should you choose?&lt;br&gt;
$v$&lt;br&gt;
$v0$ BitArray answers = new &lt;br&gt;
    BitArray(1); $v0end$&lt;br&gt;
$v1$ BitArray answers = new BitArray(-1); $v1end$&lt;br&gt;
$v2$ &lt;br&gt;
    BitVector32 answers = new BitVector32(-1); $v2end$&lt;br&gt;
$v3$ BitVector32 &lt;br&gt;
    answers = new BitVector32(1); $v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>2</questionanswer>
  </question>
  <question id="1_1_2_0:25" type="0">
    <questiontext>&lt;br&gt;
    Your company uses an application named Application1 that was compiled by &lt;br&gt;
    using the .NET Framework version 1.0. &lt;br&gt;
The application currently runs on a shared computer on which the .NET &lt;br&gt;
    Framework versions 1.0 and 1.1 are installed.&lt;br&gt;
You need to move the application to a new computer on which the .NET Framework &lt;br&gt;
    versions 1.1 and 2.0 are installed. &lt;br&gt;
The application is compatible with the .NET Framework 1.1, but it is &lt;br&gt;
    incompatible with the .NET Framework 2.0. &lt;br&gt;
You need to ensure that the application will use the .NET Framework version &lt;br&gt;
    1.1 on the new computer. &lt;br&gt;
&lt;br&gt;
What should you do?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
Add the following XML element to the application configuration file.&lt;br&gt;
&lt;configuration&gt;&lt;br&gt;
&lt;runtime&gt;&lt;br&gt;
&lt;assemblyBinding&lt;br&gt;
xmlns=&amp;quot;urn:schemas-microsoft-com:asm.v1&amp;quot;&gt;&lt;br&gt;
&lt;dependentAssembly&gt;&lt;br&gt;
&lt;assemblyIdentity name=&amp;quot;Application1&amp;quot;&lt;br&gt;
publicKeyToken=&amp;quot;32ab4ba45e0a69a1&amp;quot;&lt;br&gt;
culture=&amp;quot;neutral&amp;quot; /&gt;&lt;br&gt;
&lt;bindingRedirect oldVersion=&amp;quot;1.0.3075.0&amp;quot;&lt;br&gt;
newVersion=&amp;quot;1.1.4322.0&amp;quot;/&gt;&lt;br&gt;
&lt;/dependentAssembly&gt;&lt;br&gt;
&lt;/assemblyBinding&gt;&lt;br&gt;
&lt;/runtime&gt;&lt;br&gt;
&lt;/configuration&gt;&lt;br&gt;
 $v0end$&lt;br&gt;
$v1$&lt;br&gt;
Add the following XML element to the application configuration file.&lt;br&gt;
&lt;configuration&gt;&lt;br&gt;
&lt;startup&gt;&lt;br&gt;
&lt;supportedRuntime version=&amp;quot;1.1.4322&amp;quot; /&gt;&lt;br&gt;
&lt;startup&gt;&lt;br&gt;
&lt;/configuration&gt;&lt;br&gt;
$v1end$&lt;br&gt;
$v2$ &lt;br&gt;
Add the following XML element to the machine configuration file.&lt;br&gt;
&lt;configuration&gt;&lt;br&gt;
&lt;startup&gt;&lt;br&gt;
&lt;requiredRuntime version=&amp;quot;1.1.4322&amp;quot; /&gt;&lt;br&gt;
&lt;startup&gt;&lt;br&gt;
&lt;/configuration&gt;&lt;br&gt;
$v2end$&lt;br&gt;
$v3$$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:26" type="0">
    <questiontext>&lt;br&gt;
    You work as a developer at Company.com. You are creating an assembly named &lt;br&gt;
    Company1.&lt;br&gt;
Company1 contains a public method. The global cache contains a second assembly &lt;br&gt;
    named&lt;br&gt;
Company2.&lt;br&gt;
You must ensure that the public method is only called from Company2.&lt;br&gt;
Which permission class should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$PublisherIdentityPermission$v0end$&lt;br&gt;
$v1$GacIdentityPermission$v1end$&lt;br&gt;
$v2$StrongNameIdentityPermission &lt;br&gt;
    $v2end$&lt;br&gt;
$v3$DataProtectionPermission$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
  <question id="1_1_2_0:27" type="0">
    <questiontext>&lt;br&gt;
    You are writing a method that accepts a string parameter named message.&lt;br&gt;
Your method must break the message parameter into individual lines of text &lt;br&gt;
and pass each line to a second method named Process.&lt;br&gt;
&lt;br&gt;
Which code segment should you use?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
StringReader reader = new StringReader(message);&lt;br&gt;
while (reader.Peek() != -1) {&lt;br&gt;
 string line = reader.Read().ToString();&lt;br&gt;
 Process(line);&lt;br&gt;
}&lt;br&gt;
reader.Close();&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
StringReader reader = new StringReader(message);&lt;br&gt;
Process(reader.ToString());&lt;br&gt;
reader.Close();&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
StringReader reader = new StringReader(message);&lt;br&gt;
while (reader.Peek() != -1) {&lt;br&gt;
Process(reader.ReadLine());&lt;br&gt;
}&lt;br&gt;
reader.Close();&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
StringReader reader = new StringReader(message);&lt;br&gt;
Process(reader.ReadToEnd());&lt;br&gt;
reader.Close();&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>2</questionanswer>
  </question>
  <question id="1_1_2_0:28" type="0">
    <questiontext>&lt;br&gt;
    You develop a service application named PollingService that periodically &lt;br&gt;
    calls long-running procedures. &lt;br&gt;
These procedures are called from the DoWork method.&lt;br&gt;
&lt;br&gt;
You use the following service application code: &lt;br&gt;
&lt;br&gt;
partial class PollingService :&lt;br&gt;
    ServiceBase {&lt;br&gt;
        bool blnExit = false; public PollingService() {}&lt;br&gt;
        protected override void OnStart(string[] args) {&lt;br&gt;
            do &lt;br&gt;
            {&lt;br&gt;
                DoWork();&lt;br&gt;
            } &lt;br&gt;
                while (!blnExit);&lt;br&gt;
        }&lt;br&gt;
    protected override void OnStop() {&lt;br&gt;
    blnExit = true;&lt;br&gt;
}&lt;br&gt;
private void DoWork() {&lt;br&gt;
...&lt;br&gt;
} &lt;br&gt;
}&lt;br&gt;
&lt;br&gt;
When you attempt to start the service, you receive the following error &lt;br&gt;
    message: Could not start the PollingService service on the local computer. &lt;br&gt;
Error 1053: The service did not respond to the start or control request in a &lt;br&gt;
    timely fashion. &lt;br&gt;
You need to modify the service application code so that the service starts &lt;br&gt;
    properly. &lt;br&gt;
&lt;br&gt;
What should you do?&lt;br&gt;
$v$&lt;br&gt;
$v0$ &lt;br&gt;
Add a class-level System.Timers.&lt;br&gt;
Timer variable to the service class code. &lt;br&gt;
Move the call to the DoWork method into the Elapsed event procedure of the &lt;br&gt;
    timer, &lt;br&gt;
set the Enabled property of the timer to True, and call the Start method of &lt;br&gt;
    the timer in the OnStart method.&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
Drag a timer component onto the design surface of the service. Move the calls &lt;br&gt;
    to the longrunning procedure from the OnStart method into the Tick event &lt;br&gt;
    procedure of the timer, set the Enabled property of the timer to True, and &lt;br&gt;
    call the Start method of the timer in the OnStart method.&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
Move the loop code from the OnStart method into the DoWork method.&lt;br&gt;
$v2end$&lt;br&gt;
$v3$&lt;br&gt;
Move the loop code into the constructor of the service class from the OnStart &lt;br&gt;
    method.&lt;br&gt;
$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>0</questionanswer>
  </question>
  <question id="1_1_2_0:29" type="0">
    <questiontext>&lt;br&gt;
    You develop a service application named FileService. &lt;br&gt;
You deploy the service application to multiple servers on your network. &lt;br&gt;
You implement the following code segment. &lt;br&gt;
(Line numbers are included for reference only.)&lt;br&gt;
01 public void StartService(string serverName){&lt;br&gt;
02     ServiceController crtl = new&lt;br&gt;
03     ServiceController(&amp;#8220;FileService&amp;#8221;);&lt;br&gt;
04         if (crtl.Status == ServiceControllerStatus.Stopped){&lt;br&gt;
05     }&lt;br&gt;
06 }&lt;br&gt;
You need to develop a routine that will start FileService if it stops. &lt;br&gt;
The routine must start FileService on the server identified by the serverName &lt;br&gt;
    input parameter.&lt;br&gt;
&lt;br&gt;
Which two lines of code should you add to the code segment? &lt;br&gt;
&lt;br&gt;
$v$&lt;br&gt;
$v0$&lt;br&gt;
Insert the following line of code between lines 04 and 05:&lt;br&gt;
crtl.ExecuteCommand(0);&lt;br&gt;
Insert the following line of code between lines 03 and 04:&lt;br&gt;
crtl.MachineName = serverName;&lt;br&gt;
$v0end$&lt;br&gt;
$v1$&lt;br&gt;
Insert the following line of code between lines 04 and 05:&lt;br&gt;
crtl.Continue();&lt;br&gt;
$v1end$&lt;br&gt;
$v2$&lt;br&gt;
Insert the following line of code between lines 03 and 04:&lt;br&gt;
crtl.MachineName = serverName;&lt;br&gt;
Insert the following line of code between lines 04 and 05:&lt;br&gt;
crtl.Start();&lt;br&gt;
$v2end$&lt;br&gt;
$v3$$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>2</questionanswer>
  </question>
  <question id="1_1_2_0:30" type="0">
    <questiontext>&lt;br&gt;
    You need to call an unmanaged function from your managed code by using &lt;br&gt;
    platform invoke services. &lt;br&gt;
&lt;br&gt;
What should you do?&lt;br&gt;
$v$&lt;br&gt;
$v0$Register your assembly by using COM and then &lt;br&gt;
    reference your managed code from COM.$v0end$&lt;br&gt;
$v1$Export a type library &lt;br&gt;
    for your managed code.$v1end$&lt;br&gt;
$v2$Import a type library as an assembly &lt;br&gt;
    and then create instances of COM object.$v2end$&lt;br&gt;
$v3$Create a class to &lt;br&gt;
    hold DLL functions and then create prototype methods by using managed &lt;br&gt;
    code.$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>3</questionanswer>
  </question>
  <question id="1_1_2_0:31" type="0">
    <questiontext>&lt;br&gt;
    You use Reflection to obtain information about a method named MyMethod.&lt;br&gt;
You need to ascertain whether MyMethod is accessible to a derived class. &lt;br&gt;
&lt;br&gt;
What should you do?&lt;br&gt;
$v$&lt;br&gt;
$v0$ Call the IsStatic property of the &lt;br&gt;
    MethodInfo class.$v0end$&lt;br&gt;
$v1$ Call the IsFamily property of the &lt;br&gt;
    MethodInfo class.$v1end$&lt;br&gt;
$v2$ Call the IsAssembly property of the &lt;br&gt;
    MethodInfo class$v2end$&lt;br&gt;
$v3$ Call the IsVirtual property of the &lt;br&gt;
    MethodInfo class.$v3end$&lt;br&gt;
$vend$&lt;br&gt;</questiontext>
    <questionanswer>1</questionanswer>
  </question>
</questions>
