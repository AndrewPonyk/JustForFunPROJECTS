<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Folder Browser</title>
  <style>
    body { font-family: Arial, sans-serif; }
    ul { list-style-type: none; padding: 0; }
    li { margin: 5px 0; }
    a { text-decoration: none; color: #007BFF; }
    a:hover { text-decoration: underline; }
    
    #videoModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #contentModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1001;
    }

    #contentContainer {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 98%;
      max-height: 98%;
      background-color: white;
      border-radius: 8px;
      padding: 10px;
      overflow: auto;
    }

    #contentTitle {
      font-weight: bold;
      margin-bottom: 15px;
      color: #333;
      text-align: center;
    }

    #imageViewer {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 8px;
    }

    #textViewer {
      max-width: 95vw;
      max-height: 90vh;
      overflow: auto;
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #pdfViewer {
      width: 95vw;
      height: 90vh;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    #epubViewer {
      width: 95vw;
      height: 90vh;
      display: flex;
      flex-direction: column;
    }

    #epubContainer {
      display: flex;
      flex: 1;
      height: 100%;
    }

    #epubSidebar {
      width: 250px;
      border: 1px solid #ddd;
      border-right: none;
      background-color: #f9f9f9;
      overflow-y: auto;
      flex-shrink: 0;
    }

    #epubSidebarHeader {
      padding: 10px;
      background-color: #e9ecef;
      border-bottom: 1px solid #ddd;
      font-weight: bold;
      font-size: 14px;
    }

    #epubToc {
      padding: 0;
      margin: 0;
      list-style: none;
    }

    #epubToc li {
      padding: 8px 15px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      font-size: 13px;
      line-height: 1.3;
    }

    #epubToc li:hover {
      background-color: #e6f3ff;
    }

    #epubToc li.active {
      background-color: #007BFF;
      color: white;
    }

    #epubToc li.nested {
      padding-left: 25px;
      font-size: 12px;
    }

    #epubMainContent {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #epubControls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
    }

    #epubControls button {
      padding: 8px 16px;
      background-color: #007BFF;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    #epubControls button:hover {
      background-color: #0056b3;
    }

    #epubControls button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    #epubProgress {
      font-size: 14px;
      color: #666;
    }

    #epubReader {
      flex: 1;
      border: 1px solid #ddd;
      border-radius: 0 0 4px 4px;
      overflow-y: auto;
      overflow-x: hidden;
    }

    #contentCloseButton {
      position: absolute;
      top: -10px;
      right: -10px;
      background-color: #fff;
      border: none;
      font-size: 20px;
      cursor: pointer;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      line-height: 26px;
      text-align: center;
      padding: 0;
      z-index: 1002;
    }

    #videoContainer {
      position: relative;
      margin-left: 50px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #videoPlayer {
      width: 90%;
      max-width: 1200px;
    }

    #closeButton {
      position: absolute;
      top: -10px;
      right: -10px;
      background-color: #fff;
      border: none;
      font-size: 20px;
      cursor: pointer;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      line-height: 26px;
      text-align: center;
      padding: 0;
    }

    #speedControls {
      margin-top: 10px;
      text-align: center;
    }

    .speed-button {
      margin: 0 5px;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
    }

    .pass-checkbox {
      margin-left: 10px;
      accent-color: green;
      width: 20px;
      height: 20px;
    }
    
    .wtc-checkbox {
      margin-left: 5px;
      accent-color: #90EE90;
      width: 20px;
      height: 20px;
    }
    
    .blue-square {
      display: inline-block;
      width: 10px;
      height: 10px;
      background-color: blue;
      margin-left: 5px;
    }
    
    .rating-bars {
      display: inline-flex;
      align-items: flex-end;
      margin-left: 5px;
      height: 16px;
      width: 20px;
      background-color: white;
      border-radius: 2px;
      padding: 1px;
    }
    
    .rating-bar {
      width: 4px;
      background-color: #333;
      margin-right: 1px;
    }
    
    .rating-bar.bar1 { height: 4px; }
    .rating-bar.bar2 { height: 8px; }
    .rating-bar.bar3 { height: 12px; }
    .rating-bar.bar4 { height: 16px; }
    
    .rating-bars.rating-3 .rating-bar {
      background-color: #32CD32;
      box-shadow: 0 0 4px #32CD32;
      animation: excellentBlink 2s infinite;
    }
    
    @keyframes excellentBlink {
      0%, 50% { 
        background-color: #32CD32;
        box-shadow: 0 0 4px #32CD32;
      }
      75% { 
        background-color: #00FF00;
        box-shadow: 0 0 8px #00FF00, 0 0 12px #32CD32;
      }
      100% { 
        background-color: #32CD32;
        box-shadow: 0 0 4px #32CD32;
      }
    }
    
    .rating-bars.rating-2 .rating-bar {
      background-color: #FFA500;
    }
    
    .rating-bars.rating-1 .rating-bar {
      background-color: #FF4444;
    }
    
    .rating-select {
      margin-left: 5px;
      font-size: 12px;
      width: 40px;
    }
    
    /* Metadata styles */
    .metadata-btn {
      font-size: 10px;
      padding: 2px 6px;
      margin-left: 5px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 3px;
      cursor: pointer;
      color: #666;
    }
    
    .metadata-btn:hover {
      background: #e0e0e0;
      color: #333;
    }
    
    .has-metadata::before {
      content: "üìù";
      margin-right: 3px;
      font-size: 10px;
      opacity: 0.7;
    }
    
    .metadata-tooltip {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 15px;
      width: 500px;
      height: 350px;
      min-width: 250px;
      max-width: 800px;
      min-height: 150px;
      max-height: 600px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 2000;
      font-family: Arial, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      overflow: auto;
      cursor: move;
    }
    
    .metadata-tooltip-text {
      margin-bottom: 8px;
      word-wrap: break-word;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      background-color: #f8f8f8;
      padding: 8px;
      border-radius: 3px;
      border: 1px solid #e0e0e0;
      user-select: text;
      cursor: text;
    }
    
    .metadata-tooltip-image {
      max-width: 100%;
      max-height: 400px;
      object-fit: contain;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    
    .tooltip-close {
      position: absolute;
      top: 5px;
      right: 8px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 3px;
      width: 20px;
      height: 20px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
    }
    
    .tooltip-close:hover {
      background: #e0e0e0;
      color: #333;
    }
    
    .tooltip-resize-handle {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 20px;
      height: 20px;
      cursor: nw-resize;
      background: linear-gradient(-45deg, transparent 0%, transparent 40%, #ccc 40%, #ccc 45%, transparent 45%, transparent 55%, #ccc 55%, #ccc 60%, transparent 60%);
    }
    
    .tooltip-resize-handle:hover {
      background: linear-gradient(-45deg, transparent 0%, transparent 40%, #999 40%, #999 45%, transparent 45%, transparent 55%, #999 55%, #999 60%, transparent 60%);
    }
    
    #metadataModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
    }
    
    #metadataContainer {
      background: white;
      border-radius: 8px;
      padding: 20px;
      min-width: 400px;
      max-width: 600px;
      position: relative;
    }
    
    #metadataTitle {
      font-weight: bold;
      margin-bottom: 15px;
      color: #333;
    }
    
    #metadataText {
      width: 100%;
      height: 100px;
      margin-bottom: 15px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      resize: vertical;
    }
    
    #imagePasteArea {
      width: 100%;
      min-height: 80px;
      border: 2px dashed #ccc;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;
      color: #666;
      font-size: 14px;
      cursor: pointer;
      transition: border-color 0.3s;
    }
    
    #imagePasteArea:hover {
      border-color: #999;
    }
    
    #imagePasteArea.dragover {
      border-color: #007BFF;
      background-color: #f0f8ff;
    }
    
    #imagePreview {
      max-width: 100%;
      max-height: 200px;
      object-fit: contain;
      border-radius: 4px;
      margin-top: 10px;
    }
    
    .metadata-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }
    
    .metadata-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .metadata-buttons .save-btn {
      background: #007BFF;
      color: white;
    }
    
    .metadata-buttons .save-btn:hover {
      background: #0056b3;
    }
    
    .metadata-buttons .cancel-btn {
      background: #6c757d;
      color: white;
    }
    
    .metadata-buttons .cancel-btn:hover {
      background: #545b62;
    }
    
    .metadata-buttons .delete-btn {
      background: #dc3545;
      color: white;
    }
    
    .metadata-buttons .delete-btn:hover {
      background: #c82333;
    }
    
    #metadataCloseButton {
      position: absolute;
      top: -10px;
      right: -10px;
      background-color: #fff;
      border: 1px solid #ccc;
      font-size: 18px;
      cursor: pointer;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      line-height: 26px;
      text-align: center;
      padding: 0;
      z-index: 3001;
    }
  </style>
</head>
<body>
  <h1>Folder Browser</h1>
  <input type="text" size="100" id="folderPath" value="H:\Vidokursu_and_Books_From_118a\6.1JAVA_\03SpringFramework" placeholder="Enter folder path">
  <button onclick="loadFolder()">Load Folder</button>
  <ul id="fileList"></ul>

  <!-- Modal for video player -->
  <div id="videoModal">
    <div id="videoContainer">
      <button id="closeButton">‚úñ</button>
      <video id="videoPlayer" controls></video>
      <div id="speedControls">
        <button class="speed-button" data-speed="1">1x</button>
        <button class="speed-button" data-speed="1.5">1.5x</button>
        <button class="speed-button" data-speed="1.75">1.75x</button>
        <button class="speed-button" data-speed="2">2x</button>
        <button class="speed-button" data-speed="2.25">2.25x</button>
        <button class="speed-button" data-speed="2.5">2.5x</button>
        <button class="speed-button" data-speed="2.8">2.8x</button>
      </div>
    </div>
  </div>

  <!-- Modal for content viewer (images and text) -->
  <div id="contentModal">
    <div id="contentContainer">
      <button id="contentCloseButton">‚úñ</button>
      <div id="contentTitle"></div>
      <img id="imageViewer" src="" alt="" style="display: none;">
      <pre id="textViewer" style="display: none;"></pre>
      <iframe id="pdfViewer" src="" style="display: none;"></iframe>
      <div id="epubViewer" style="display: none;">
        <div id="epubControls">
          <button id="epubPrev">‚óÄ Previous</button>
          <span id="epubProgress"></span>
          <button id="epubNext">Next ‚ñ∂</button>
          <button id="toggleToc">üìö TOC</button>
        </div>
        <div id="epubContainer">
          <div id="epubSidebar">
            <div id="epubSidebarHeader">Table of Contents</div>
            <ul id="epubToc"></ul>
          </div>
          <div id="epubMainContent">
            <div id="epubReader"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Metadata Modal -->
  <div id="metadataModal">
    <div id="metadataContainer">
      <button id="metadataCloseButton">‚úñ</button>
      <div id="metadataTitle">Add/Edit Metadata</div>
      <textarea id="metadataText" placeholder="Enter description or notes..."></textarea>
      <div id="imagePasteArea">
        <span>Paste image here (Ctrl+V) or click to upload</span>
      </div>
      <img id="imagePreview" style="display: none;" alt="Image preview">
      <input type="file" id="imageFileInput" accept="image/*" style="display: none;">
      <div class="metadata-buttons">
        <div>
          <button class="save-btn" id="saveMetadata">Save</button>
          <button class="cancel-btn" id="cancelMetadata">Cancel</button>
        </div>
        <button class="delete-btn" id="deleteMetadata" style="display: none;">Delete Metadata</button>
      </div>
    </div>
  </div>

  <!-- Background Audio Element for Motivational Music -->
  <audio id="backgroundAudio" loop style="display:none;">
    <source src="music/yt1znet-RodneySpence-LastOfTheTransports.mp3" type="audio/mp3">
    Your browser does not support the audio element.
  </audio>

  <!-- JSZip Library (required for EPUB.js) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <!-- EPUB.js Library -->
  <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js"></script>

  <script>
    // Array of music tracks. Adjust these paths to match your /music/ folder.
    const musicTracks = [
      "music/Alan Walker - Faded (Instrumental Version).mp3",
      "music/Intro.mp3",
      "music/M83 'We Own The Sky' Official video.mp3",
      "music/M83 - Midnight City (Instrumental).mp3",
      "music/yt1znet-RodneySpence-LastOfTheTransports.mp3"
    ];

    var currentPath = "";
    var currentMetadataItem = null;
    var currentMetadataPath = null;
    var metadataImageFile = null;
    var currentTooltip = null;

    // Metadata functions
    async function fetchMetadata(folderPath, itemName) {
      try {
        const response = await fetch(`/metadata?folderPath=${encodeURIComponent(folderPath)}&itemName=${encodeURIComponent(itemName)}`);
        const result = await response.json();
        return result.metadata;
      } catch (error) {
        console.error('Error fetching metadata:', error);
        return null;
      }
    }

    async function saveMetadata(folderPath, itemName, text, hasImage, imageExtension) {
      try {
        const response = await fetch('/metadata', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            folderPath, 
            itemName, 
            text, 
            hasImage: hasImage || false, 
            imageExtension: imageExtension || null 
          })
        });
        return await response.json();
      } catch (error) {
        console.error('Error saving metadata:', error);
        return { success: false, error: error.message };
      }
    }

    async function deleteMetadata(folderPath, itemName) {
      try {
        const response = await fetch(`/metadata?folderPath=${encodeURIComponent(folderPath)}&itemName=${encodeURIComponent(itemName)}`, {
          method: 'DELETE'
        });
        return await response.json();
      } catch (error) {
        console.error('Error deleting metadata:', error);
        return { success: false, error: error.message };
      }
    }

    async function uploadMetadataImage(folderPath, itemName, imageFile, imageExtension) {
      try {
        const formData = new FormData();
        formData.append('image', imageFile);
        formData.append('folderPath', folderPath);
        formData.append('itemName', itemName);
        formData.append('imageExtension', imageExtension);

        const response = await fetch('/metadata-image', {
          method: 'POST',
          body: formData
        });
        return await response.json();
      } catch (error) {
        console.error('Error uploading metadata image:', error);
        return { success: false, error: error.message };
      }
    }

    function openMetadataModal(folderPath, itemName) {
      currentMetadataPath = folderPath;
      currentMetadataItem = itemName;
      
      const modal = document.getElementById('metadataModal');
      const title = document.getElementById('metadataTitle');
      const textarea = document.getElementById('metadataText');
      const imagePreview = document.getElementById('imagePreview');
      const deleteBtn = document.getElementById('deleteMetadata');
      
      title.textContent = `Metadata for: ${itemName}`;
      textarea.value = '';
      imagePreview.style.display = 'none';
      imagePreview.src = '';
      metadataImageFile = null;
      deleteBtn.style.display = 'none';
      
      // Load existing metadata
      fetchMetadata(folderPath, itemName).then(metadata => {
        if (metadata) {
          textarea.value = metadata.text || '';
          deleteBtn.style.display = 'inline-block';
          
          if (metadata.imageExists && metadata.imagePath) {
            imagePreview.src = metadata.imagePath;
            imagePreview.style.display = 'block';
            document.querySelector('#imagePasteArea span').textContent = 'Click to replace image or paste new one (Ctrl+V)';
          }
        }
      });
      
      modal.style.display = 'flex';
    }

    function closeMetadataModal() {
      document.getElementById('metadataModal').style.display = 'none';
      currentMetadataItem = null;
      currentMetadataPath = null;
      metadataImageFile = null;
      
      const imagePreview = document.getElementById('imagePreview');
      const pasteArea = document.querySelector('#imagePasteArea span');
      imagePreview.style.display = 'none';
      imagePreview.src = '';
      pasteArea.textContent = 'Paste image here (Ctrl+V) or click to upload';
    }

    function handleImagePaste(file) {
      if (file && file.type.startsWith('image/')) {
        metadataImageFile = file;
        const reader = new FileReader();
        reader.onload = function(e) {
          const imagePreview = document.getElementById('imagePreview');
          imagePreview.src = e.target.result;
          imagePreview.style.display = 'block';
          document.querySelector('#imagePasteArea span').textContent = 'Image ready to upload';
        };
        reader.readAsDataURL(file);
      }
    }

    function showMetadataTooltip(element, folderPath, itemName) {
      hideMetadataTooltip();
      
      fetchMetadata(folderPath, itemName).then(metadata => {
        if (metadata && (metadata.text || metadata.imageExists)) {
          const tooltip = document.createElement('div');
          tooltip.className = 'metadata-tooltip';
          
          // Add close button
          const closeBtn = document.createElement('div');
          closeBtn.className = 'tooltip-close';
          closeBtn.innerHTML = '‚úñ';
          closeBtn.title = 'Close tooltip (or click anywhere)';
          closeBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            hideMetadataTooltip();
          });
          tooltip.appendChild(closeBtn);
          
          // Add resize handle
          const resizeHandle = document.createElement('div');
          resizeHandle.className = 'tooltip-resize-handle';
          resizeHandle.title = 'Drag to resize';
          tooltip.appendChild(resizeHandle);
          
          if (metadata.text) {
            const textDiv = document.createElement('div');
            textDiv.className = 'metadata-tooltip-text';
            textDiv.textContent = metadata.text;
            tooltip.appendChild(textDiv);
          }
          
          if (metadata.imageExists && metadata.imagePath) {
            const img = document.createElement('img');
            img.className = 'metadata-tooltip-image';
            img.src = metadata.imagePath;
            tooltip.appendChild(img);
          }
          
          document.body.appendChild(tooltip);
          
          // Position tooltip (larger initial size)
          const rect = element.getBoundingClientRect();
          
          let left = rect.left + rect.width + 20;
          let top = rect.top;
          
          // Adjust if tooltip would go off screen
          if (left + 350 > window.innerWidth) { // Assume initial width of ~350px
            left = rect.left - 370;
          }
          if (top + 200 > window.innerHeight) { // Assume initial height of ~200px
            top = window.innerHeight - 220;
          }
          
          tooltip.style.left = Math.max(10, left) + 'px';
          tooltip.style.top = Math.max(10, top) + 'px';
          
          // Add drag and resize functionality
          makeDraggable(tooltip);
          makeResizable(tooltip, resizeHandle);
          
          currentTooltip = tooltip;
          
          // Prevent tooltip from closing when clicking on it
          tooltip.addEventListener('click', function(e) {
            e.stopPropagation();
          });
          
          // Prevent tooltip from hiding when hovering over it
          tooltip.addEventListener('mouseenter', function() {
            clearTimeout(window.tooltipHideTimeout);
          });
          
          tooltip.addEventListener('mouseleave', function() {
            window.tooltipHideTimeout = setTimeout(hideMetadataTooltip, 300);
          });
        }
      });
    }
    
    function makeDraggable(element) {
      let isDragging = false;
      let startX, startY, initialX, initialY;
      
      element.addEventListener('mousedown', function(e) {
        // Only start dragging if not clicking on the resize handle, close button, or text area
        if (e.target.classList.contains('tooltip-close') || 
            e.target.classList.contains('tooltip-resize-handle') ||
            e.target.classList.contains('metadata-tooltip-text')) return;
        
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = parseInt(element.style.left, 10) || 0;
        initialY = parseInt(element.style.top, 10) || 0;
        
        element.style.cursor = 'grabbing';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        element.style.left = (initialX + dx) + 'px';
        element.style.top = (initialY + dy) + 'px';
      });
      
      document.addEventListener('mouseup', function() {
        if (isDragging) {
          isDragging = false;
          element.style.cursor = 'move';
        }
      });
    }
    
    function makeResizable(element, resizeHandle) {
      let isResizing = false;
      let startX, startY, initialWidth, initialHeight;
      
      resizeHandle.addEventListener('mousedown', function(e) {
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        
        const computedStyle = window.getComputedStyle(element);
        initialWidth = parseInt(computedStyle.width, 10);
        initialHeight = parseInt(computedStyle.height, 10);
        
        e.preventDefault();
        e.stopPropagation();
      });
      
      document.addEventListener('mousemove', function(e) {
        if (!isResizing) return;
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        const newWidth = Math.max(250, Math.min(800, initialWidth + dx));
        const newHeight = Math.max(150, Math.min(600, initialHeight + dy));
        
        element.style.width = newWidth + 'px';
        element.style.height = newHeight + 'px';
      });
      
      document.addEventListener('mouseup', function() {
        if (isResizing) {
          isResizing = false;
        }
      });
    }

    function hideMetadataTooltip() {
      if (currentTooltip) {
        document.body.removeChild(currentTooltip);
        currentTooltip = null;
      }
    }

    async function loadFolder(folderPath) {
      folderPath = folderPath || document.getElementById('folderPath').value;

      // Update the URL query parameter
      const url = new URL(window.location);
      url.searchParams.set('folder', folderPath);
      history.replaceState(null, '', url);

      currentPath = folderPath;
      // Replace backslashes with forward slashes.
      folderPath = folderPath.replace(/\\/g, '/');
      
      const response = await fetch(`/list?folder=${encodeURIComponent(folderPath)}`);
      const files = await response.json();
      
      const fileList = document.getElementById('fileList');
      fileList.innerHTML = '';

      // If not in root, add a "Go Up" entry
      const pathParts = folderPath.split('/');
      if (pathParts.length > 1) {
        const parentFolder = pathParts.slice(0, -1).join('/');
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#';
        a.textContent = '.. (Go Up)';
        a.addEventListener('click', function(event) {
          event.preventDefault();
          loadFolder(parentFolder);
        });
        li.appendChild(a);
        fileList.appendChild(li);
      }

      // List files/folders
      files.forEach(file => {
        const li = document.createElement('li');
        const filePath = file.path.replace(/\\/g, '/');

        if (file.isDirectory) {
          const a = document.createElement('a');
          a.href = '#';
          a.textContent = `üìÅ ${file.name}`;
          a.addEventListener('click', function(event) {
            event.preventDefault();
            loadFolder(filePath);
          });
          
          // Color styling - PASS overrides wtc
          if (file.name.toLowerCase().includes("-pass")) {
            li.style.backgroundColor = "lightgreen";
          } else if (file.name.toLowerCase().includes("-wtc")) {
            li.style.backgroundColor = "#E8F5E8";
          }
          
          if (file.name.toLowerCase().includes("react--")) { 
            li.style.fontWeight = "bold";
          }
          if (file.name.toLowerCase().includes("==app")) {
            li.style.textDecoration = "underline";
          }
          if (file.name.toLowerCase().includes("netflix")) {
            li.style.textDecorationLine = "underline"; 
            li.style.textDecorationStyle = "wavy";
          }
          li.appendChild(a);
          
          // Add metadata button for folders
          const metadataBtn = document.createElement('button');
          metadataBtn.className = 'metadata-btn';
          metadataBtn.textContent = 'Meta';
          metadataBtn.title = 'Add/Edit Metadata';
          metadataBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            openMetadataModal(currentPath, file.name);
          });
          li.appendChild(metadataBtn);
          
          // Check if metadata exists and add indicator
          fetchMetadata(currentPath, file.name).then(metadata => {
            if (metadata && (metadata.text || metadata.imageExists)) {
              li.classList.add('has-metadata');
              
              // Add hover listeners for tooltip with delay
              a.addEventListener('mouseenter', function() {
                clearTimeout(window.tooltipHideTimeout);
                showMetadataTooltip(this, currentPath, file.name);
              });
              a.addEventListener('mouseleave', function() {
                window.tooltipHideTimeout = setTimeout(hideMetadataTooltip, 500); // 500ms delay
              });
              
              // Also add click listener as backup
              a.addEventListener('click', function(e) {
                e.preventDefault();
                showMetadataTooltip(this, currentPath, file.name);
              });
            }
          });
          
          // Add checkboxes for folders
          const passLabel = document.createElement('span');
          passLabel.textContent = ' P:';
          passLabel.style.fontSize = '12px';
          passLabel.style.color = '#666';
          li.appendChild(passLabel);
          
          const passCheckbox = document.createElement('input');
          passCheckbox.type = 'checkbox';
          passCheckbox.className = 'pass-checkbox';
          passCheckbox.checked = file.name.toLowerCase().includes('-pass');
          passCheckbox.addEventListener('change', function() {
            if (this.checked) {
              markPass(filePath);
            }
          });
          li.appendChild(passCheckbox);
          
          const wtcLabel = document.createElement('span');
          wtcLabel.textContent = ' W:';
          wtcLabel.style.fontSize = '12px';
          wtcLabel.style.color = '#666';
          li.appendChild(wtcLabel);
          
          const wtcCheckbox = document.createElement('input');
          wtcCheckbox.type = 'checkbox';
          wtcCheckbox.className = 'wtc-checkbox';
          wtcCheckbox.checked = file.name.toLowerCase().includes('-wtc');
          wtcCheckbox.addEventListener('change', function() {
            if (this.checked) {
              markWtc(filePath);
            }
          });
          li.appendChild(wtcCheckbox);
          
          // Add rating system for folders
          const currentRating = extractRating(file.name);
          
          const ratingBars = createRatingBars(currentRating);
          li.appendChild(ratingBars);
          
          const ratingSelect = document.createElement('select');
          ratingSelect.className = 'rating-select';
          for (let i = 0; i <= 3; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            option.selected = (i === currentRating);
            ratingSelect.appendChild(option);
          }
          ratingSelect.addEventListener('change', function() {
            setRating(filePath, parseInt(this.value));
          });
          li.appendChild(ratingSelect);
        } else {
          const a = document.createElement('a');
          if (/\.(mp4|webm|ts|avi|mkv)$/i.test(file.name)) {
            a.href = '#';
            a.textContent = `üìÑ ${file.name}`;
            a.addEventListener('click', function(event) {
              event.preventDefault();
              playVideoFullscreen(filePath);
            });
          } else if (/\.(png|jpg|jpeg|gif|bmp|webp)$/i.test(file.name)) {
            a.href = '#';
            a.textContent = `üñºÔ∏è ${file.name}`;
            a.addEventListener('click', function(event) {
              event.preventDefault();
              openImage(filePath);
            });
          } else if (/\.(txt|json|xml|js|css|html|md|log|csv|sql|php|py|java|cpp|h|c|sh|bat|yml|yaml|ini|cfg|conf|properties)$/i.test(file.name)) {
            a.href = '#';
            a.textContent = `üìù ${file.name}`;
            a.addEventListener('click', function(event) {
              event.preventDefault();
              openText(filePath);
            });
          } else if (/\.(pdf)$/i.test(file.name)) {
            a.href = '#';
            a.textContent = `üìã ${file.name}`;
            a.addEventListener('click', function(event) {
              event.preventDefault();
              openPdf(filePath);
            });
          } else if (/\.(epub)$/i.test(file.name)) {
            a.href = '#';
            a.textContent = `üìñ ${file.name}`;
            a.addEventListener('click', function(event) {
              event.preventDefault();
              openEpub(filePath);
            });
          } else {
            a.href = `${filePath}`;
            a.download = '';
            a.textContent = `üìÑ ${file.name}`;
          }
          li.appendChild(a);
          
          // Add metadata button for files
          const fileMetadataBtn = document.createElement('button');
          fileMetadataBtn.className = 'metadata-btn';
          fileMetadataBtn.textContent = 'Meta';
          fileMetadataBtn.title = 'Add/Edit Metadata';
          fileMetadataBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            openMetadataModal(currentPath, file.name);
          });
          li.appendChild(fileMetadataBtn);
          
          // Check if metadata exists and add indicator
          fetchMetadata(currentPath, file.name).then(metadata => {
            if (metadata && (metadata.text || metadata.imageExists)) {
              li.classList.add('has-metadata');
              
              // Add hover listeners for tooltip with delay
              a.addEventListener('mouseenter', function() {
                clearTimeout(window.tooltipHideTimeout);
                showMetadataTooltip(this, currentPath, file.name);
              });
              a.addEventListener('mouseleave', function() {
                window.tooltipHideTimeout = setTimeout(hideMetadataTooltip, 500); // 500ms delay
              });
              
              // Also add click listener as backup
              a.addEventListener('click', function(e) {
                e.preventDefault();
                showMetadataTooltip(this, currentPath, file.name);
              });
            }
          });
          
          // Color styling - PASS overrides wtc
          if (file.name.toLowerCase().includes("-pass")) {
            li.style.backgroundColor = "lightgreen";
          } else if (file.name.toLowerCase().includes("-wtc")) {
            li.style.backgroundColor = "#E8F5E8";
          }

          if (file.name.toLowerCase().includes("-qq")) {
            li.style.backgroundColor = "lightgreen";
            const blueSquare = document.createElement("span");
            blueSquare.className = "blue-square";
            li.appendChild(blueSquare);
          }

          if (/\.(mp4|webm|ts|avi|mkv)$/i.test(file.name)) {
            const playButton = document.createElement('button');
            playButton.textContent = 'Play';
            playButton.addEventListener('click', function() {
              playVideoFullscreen(filePath);
            });
            li.appendChild(playButton);

            const passLabel = document.createElement('span');
            passLabel.textContent = ' P:';
            passLabel.style.fontSize = '12px';
            passLabel.style.color = '#666';
            li.appendChild(passLabel);
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'pass-checkbox';
            checkbox.checked = file.name.toLowerCase().includes('-pass');
            checkbox.addEventListener('change', function() {
              if (this.checked) {
                markPass(filePath);
              }
            });
            li.appendChild(checkbox);
            
            const wtcLabel = document.createElement('span');
            wtcLabel.textContent = ' W:';
            wtcLabel.style.fontSize = '12px';
            wtcLabel.style.color = '#666';
            li.appendChild(wtcLabel);
            
            const wtcCheckbox = document.createElement('input');
            wtcCheckbox.type = 'checkbox';
            wtcCheckbox.className = 'wtc-checkbox';
            wtcCheckbox.checked = file.name.toLowerCase().includes('-wtc');
            wtcCheckbox.addEventListener('change', function() {
              if (this.checked) {
                markWtc(filePath);
              }
            });
            li.appendChild(wtcCheckbox);
          } 
          
          // Add rating system for ALL files (outside video conditional)
          const fileRating = extractRating(file.name);
          
          const fileRatingBars = createRatingBars(fileRating);
          li.appendChild(fileRatingBars);
          
          const fileRatingSelect = document.createElement('select');
          fileRatingSelect.className = 'rating-select';
          for (let i = 0; i <= 3; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            option.selected = (i === fileRating);
            fileRatingSelect.appendChild(option);
          }
          fileRatingSelect.addEventListener('change', function() {
            setRating(filePath, parseInt(this.value));
          });
          li.appendChild(fileRatingSelect);
        }
        fileList.appendChild(li);
      });
    }

    function playVideo(videoPath) {
      videoPath = videoPath.replace(/\\/g, '/');
      const videoPlayer = document.getElementById('videoPlayer');
      videoPlayer.src = `/video?path=${encodeURIComponent(videoPath)}`;
      document.getElementById('videoModal').style.display = 'flex';
      videoPlayer.play();
      videoPlayer.playbackRate = 2.5;

      // Pick a random track from the musicTracks array.
      const randomIndex = Math.floor(Math.random() * musicTracks.length);
      const randomTrack = musicTracks[randomIndex];

      // Set background audio to that random track and play.
      const bgAudio = document.getElementById('backgroundAudio');
      bgAudio.src = randomTrack;
      bgAudio.volume = 0.02;
      bgAudio.play();
    }

    function playVideoFullscreen(videoPath) {
      videoPath = videoPath.replace(/\\/g, '/');
      const videoPlayer = document.getElementById('videoPlayer');
      videoPlayer.src = `/video?path=${encodeURIComponent(videoPath)}`;
      document.getElementById('videoModal').style.display = 'flex';
      videoPlayer.play();
      videoPlayer.playbackRate = 2.5;
      
      // Request fullscreen for the video after a short delay to ensure it's ready
      setTimeout(() => {
        if (videoPlayer.requestFullscreen) {
          videoPlayer.requestFullscreen();
        } else if (videoPlayer.webkitRequestFullscreen) {
          videoPlayer.webkitRequestFullscreen();
        } else if (videoPlayer.msRequestFullscreen) {
          videoPlayer.msRequestFullscreen();
        }
      }, 100);

      // Pick a random track from the musicTracks array.
      const randomIndex = Math.floor(Math.random() * musicTracks.length);
      const randomTrack = musicTracks[randomIndex];

      // Set background audio to that random track and play.
      const bgAudio = document.getElementById('backgroundAudio');
      bgAudio.src = randomTrack;
      bgAudio.volume = 0.02;
      bgAudio.play();
    }

    async function markPass(filePath) {
      try {
        const response = await fetch('/markPass', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename: filePath }),
        });
        const result = await response.json();
        console.log(result.message);
        loadFolder(currentPath);
      } catch (error) {
        console.error('Error marking file as PASS:', error);
      }
    }
    
    async function markWtc(filePath) {
      try {
        const response = await fetch('/markWtc', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename: filePath }),
        });
        const result = await response.json();
        console.log(result.message);
        loadFolder(currentPath);
      } catch (error) {
        console.error('Error marking file as WTC:', error);
      }
    }
    
    function extractRating(filename) {
      const match = filename.match(/-r([0-3])/i);
      return match ? parseInt(match[1]) : 0;
    }
    
    function createRatingBars(rating) {
      const container = document.createElement('div');
      container.className = `rating-bars rating-${rating}`;
      
      for (let i = 1; i <= 4; i++) {
        const bar = document.createElement('div');
        bar.className = `rating-bar bar${i}`;
        if (i > rating) {
          bar.style.opacity = '0.2';
        }
        container.appendChild(bar);
      }
      
      return container;
    }
    
    async function setRating(filePath, rating) {
      try {
        const response = await fetch('/setRating', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename: filePath, rating: rating }),
        });
        const result = await response.json();
        console.log(result.message);
        loadFolder(currentPath);
      } catch (error) {
        console.error('Error setting rating:', error);
      }
    }
    
    function openImage(imagePath) {
      imagePath = imagePath.replace(/\\/g, '/');
      const imageViewer = document.getElementById('imageViewer');
      const textViewer = document.getElementById('textViewer');
      const contentTitle = document.getElementById('contentTitle');
      
      // Hide text viewer, show image viewer
      textViewer.style.display = 'none';
      imageViewer.style.display = 'block';
      
      imageViewer.src = `/image?path=${encodeURIComponent(imagePath)}`;
      contentTitle.textContent = imagePath.split('/').pop();
      document.getElementById('contentModal').style.display = 'flex';
    }
    
    async function openText(textPath) {
      try {
        textPath = textPath.replace(/\\/g, '/');
        const response = await fetch(`/text?path=${encodeURIComponent(textPath)}`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        if (result.error) {
          throw new Error(result.error);
        }
        
        const imageViewer = document.getElementById('imageViewer');
        const textViewer = document.getElementById('textViewer');
        const contentTitle = document.getElementById('contentTitle');
        
        // Hide image viewer, show text viewer
        imageViewer.style.display = 'none';
        textViewer.style.display = 'block';
        
        textViewer.textContent = result.content;
        contentTitle.textContent = result.filename;
        document.getElementById('contentModal').style.display = 'flex';
      } catch (error) {
        console.error('Error loading text file:', error);
        alert(`Error loading file: ${error.message}`);
      }
    }
    
    function openPdf(pdfPath) {
      pdfPath = pdfPath.replace(/\\/g, '/');
      const imageViewer = document.getElementById('imageViewer');
      const textViewer = document.getElementById('textViewer');
      const pdfViewer = document.getElementById('pdfViewer');
      const contentTitle = document.getElementById('contentTitle');
      
      // Hide other viewers, show PDF viewer
      imageViewer.style.display = 'none';
      textViewer.style.display = 'none';
      pdfViewer.style.display = 'block';
      
      pdfViewer.src = `/pdf?path=${encodeURIComponent(pdfPath)}`;
      contentTitle.textContent = pdfPath.split('/').pop();
      document.getElementById('contentModal').style.display = 'flex';
    }
    
    let currentEpub = null;
    let rendition = null;
    let tocVisible = true;
    
    function openEpub(epubPath) {
      try {
        epubPath = epubPath.replace(/\\/g, '/');
        const imageViewer = document.getElementById('imageViewer');
        const textViewer = document.getElementById('textViewer');
        const pdfViewer = document.getElementById('pdfViewer');
        const epubViewer = document.getElementById('epubViewer');
        const contentTitle = document.getElementById('contentTitle');
        
        // Hide other viewers, show EPUB viewer
        imageViewer.style.display = 'none';
        textViewer.style.display = 'none';
        pdfViewer.style.display = 'none';
        epubViewer.style.display = 'flex';
        
        // Initialize EPUB
        const epubUrl = `/epub?path=${encodeURIComponent(epubPath)}`;
        currentEpub = ePub();
        
        // Clear previous content
        document.getElementById('epubReader').innerHTML = '';
        document.getElementById('epubToc').innerHTML = '';
        
        // Open the EPUB file
        currentEpub.open(epubUrl).then(function() {
          // Create rendition with continuous scrolling
          rendition = currentEpub.renderTo('epubReader', {
            width: '100%',
            height: '100%',
            spread: 'none',
            flow: 'scrolled-doc',
            allowScriptedContent: true,
            script: 'https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js'
          });
          
          // Load table of contents
          loadTableOfContents();
          
          // Display first page
          return rendition.display();
        }).then(function() {
          // Update title and show modal
          contentTitle.textContent = epubPath.split('/').pop();
          document.getElementById('contentModal').style.display = 'flex';
          
          // Update progress
          updateEpubProgress();
          
          // Set up location changed listener for progress updates
          rendition.on('relocated', function(location) {
            updateEpubProgress();
            highlightCurrentTocItem(location);
          });
        }).catch(function(error) {
          console.error('Error loading EPUB:', error);
          alert('Error loading EPUB file: ' + error.message);
        });
        
      } catch (error) {
        console.error('Error opening EPUB:', error);
        alert('Error opening EPUB file');
      }
    }
    
    function loadTableOfContents() {
      if (!currentEpub) return;
      
      currentEpub.loaded.navigation.then(function(nav) {
        const tocContainer = document.getElementById('epubToc');
        tocContainer.innerHTML = '';
        
        function renderTocItem(tocItem, level = 0) {
          if (!tocItem || !tocItem.label) {
            console.warn('Invalid TOC item:', tocItem);
            return;
          }
          
          const li = document.createElement('li');
          li.textContent = tocItem.label.trim();
          if (level > 0) {
            li.classList.add('nested');
          }
          if (tocItem.href) {
            li.dataset.href = tocItem.href;
          }
          
          // Add click handler to navigate to chapter
          li.addEventListener('click', function() {
            if (rendition && tocItem.href) {
              try {
                rendition.display(tocItem.href);
                // Remove active class from all items
                tocContainer.querySelectorAll('li').forEach(item => item.classList.remove('active'));
                // Add active class to clicked item
                li.classList.add('active');
              } catch (error) {
                console.error('Error navigating to chapter:', error);
              }
            }
          });
          
          tocContainer.appendChild(li);
          
          // Render nested items
          if (tocItem.subitems && tocItem.subitems.length > 0) {
            tocItem.subitems.forEach(subitem => renderTocItem(subitem, level + 1));
          }
        }
        
        // Render table of contents
        if (nav && nav.toc && nav.toc.length > 0) {
          nav.toc.forEach(tocItem => renderTocItem(tocItem));
        } else {
          // Fallback: show a message if no TOC is available
          const li = document.createElement('li');
          li.textContent = 'Table of contents not available';
          li.style.fontStyle = 'italic';
          li.style.color = '#666';
          tocContainer.appendChild(li);
        }
      }).catch(function(error) {
        console.error('Error loading table of contents:', error);
        // Show error message in TOC
        const tocContainer = document.getElementById('epubToc');
        const li = document.createElement('li');
        li.textContent = 'Error loading table of contents';
        li.style.fontStyle = 'italic';
        li.style.color = '#d32f2f';
        tocContainer.appendChild(li);
      });
    }
    
    function highlightCurrentTocItem(location) {
      if (!location || !location.start) return;
      
      const tocItems = document.querySelectorAll('#epubToc li');
      tocItems.forEach(item => item.classList.remove('active'));
      
      // Find the most relevant TOC item based on current location
      let currentItem = null;
      tocItems.forEach(item => {
        const href = item.dataset.href;
        if (href && location.start.href && location.start.href.includes(href.split('#')[0])) {
          currentItem = item;
        }
      });
      
      if (currentItem) {
        currentItem.classList.add('active');
      }
    }
    
    function toggleTableOfContents() {
      const sidebar = document.getElementById('epubSidebar');
      const button = document.getElementById('toggleToc');
      
      if (tocVisible) {
        sidebar.style.display = 'none';
        button.textContent = 'üìö Show TOC';
        tocVisible = false;
      } else {
        sidebar.style.display = 'block';
        button.textContent = 'üìö TOC';
        tocVisible = true;
      }
    }
    
    function updateEpubProgress() {
      if (currentEpub && rendition) {
        const location = rendition.currentLocation();
        if (location && location.start) {
          const progress = Math.round(location.start.percentage * 100);
          document.getElementById('epubProgress').textContent = `${progress}%`;
        }
      }
    }
    
    function closeContent() {
      const imageViewer = document.getElementById('imageViewer');
      const textViewer = document.getElementById('textViewer');
      const pdfViewer = document.getElementById('pdfViewer');
      const epubViewer = document.getElementById('epubViewer');
      const contentTitle = document.getElementById('contentTitle');
      
      // Clean up EPUB
      if (rendition) {
        rendition.destroy();
        rendition = null;
      }
      if (currentEpub) {
        currentEpub.destroy();
        currentEpub = null;
      }
      
      imageViewer.src = '';
      textViewer.textContent = '';
      pdfViewer.src = '';
      document.getElementById('epubReader').innerHTML = '';
      contentTitle.textContent = '';
      imageViewer.style.display = 'none';
      textViewer.style.display = 'none';
      pdfViewer.style.display = 'none';
      epubViewer.style.display = 'none';
      document.getElementById('contentModal').style.display = 'none';
    }

    // Metadata modal event handlers
    document.getElementById('metadataModal').addEventListener('click', function(event) {
      if (event.target === this) {
        closeMetadataModal();
      }
    });

    document.getElementById('metadataContainer').addEventListener('click', function(event) {
      event.stopPropagation();
    });

    document.getElementById('metadataCloseButton').addEventListener('click', closeMetadataModal);
    document.getElementById('cancelMetadata').addEventListener('click', closeMetadataModal);

    // Image paste area handlers
    document.getElementById('imagePasteArea').addEventListener('click', function() {
      document.getElementById('imageFileInput').click();
    });

    document.getElementById('imageFileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        handleImagePaste(file);
      }
    });

    // Drag and drop support
    const pasteArea = document.getElementById('imagePasteArea');
    pasteArea.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.stopPropagation();
      pasteArea.classList.add('dragover');
    });

    pasteArea.addEventListener('dragleave', function(e) {
      e.preventDefault();
      e.stopPropagation();
      pasteArea.classList.remove('dragover');
    });

    pasteArea.addEventListener('drop', function(e) {
      e.preventDefault();
      e.stopPropagation();
      pasteArea.classList.remove('dragover');
      
      const files = e.dataTransfer.files;
      if (files.length > 0 && files[0].type.startsWith('image/')) {
        handleImagePaste(files[0]);
      }
    });

    // Save metadata handler
    document.getElementById('saveMetadata').addEventListener('click', async function() {
      if (!currentMetadataItem || !currentMetadataPath) return;
      
      const text = document.getElementById('metadataText').value.trim();
      
      try {
        // First, get existing metadata to preserve image info
        const existingMetadata = await fetchMetadata(currentMetadataPath, currentMetadataItem);
        
        let hasImage = false;
        let imageExtension = null;
        
        // If there's a new image file, use that
        if (metadataImageFile) {
          hasImage = true;
          imageExtension = '.png';
        } 
        // Otherwise, preserve existing image info
        else if (existingMetadata && existingMetadata.hasImage) {
          hasImage = existingMetadata.hasImage;
          imageExtension = existingMetadata.imageExtension;
        }
        
        // Save metadata first
        const result = await saveMetadata(currentMetadataPath, currentMetadataItem, text, hasImage, imageExtension);
        
        if (result.success) {
          // Upload new image if provided
          if (metadataImageFile) {
            const imageResult = await uploadMetadataImage(currentMetadataPath, currentMetadataItem, metadataImageFile, imageExtension);
            if (!imageResult.success) {
              console.error('Error uploading image:', imageResult.error);
              alert('Metadata saved but image upload failed: ' + imageResult.error);
            }
          }
          
          console.log('Metadata saved successfully');
          closeMetadataModal();
          loadFolder(currentPath); // Refresh to show metadata indicators
        } else {
          console.error('Error saving metadata:', result.error);
          alert('Error saving metadata: ' + result.error);
        }
      } catch (error) {
        console.error('Error saving metadata:', error);
        alert('Error saving metadata: ' + error.message);
      }
    });

    // Delete metadata handler
    document.getElementById('deleteMetadata').addEventListener('click', async function() {
      if (!currentMetadataItem || !currentMetadataPath) return;
      
      if (confirm(`Are you sure you want to delete metadata for "${currentMetadataItem}"?`)) {
        try {
          const result = await deleteMetadata(currentMetadataPath, currentMetadataItem);
          if (result.success) {
            console.log('Metadata deleted successfully');
            closeMetadataModal();
            loadFolder(currentPath); // Refresh to remove metadata indicators
          } else {
            console.error('Error deleting metadata:', result.error);
            alert('Error deleting metadata: ' + result.error);
          }
        } catch (error) {
          console.error('Error deleting metadata:', error);
          alert('Error deleting metadata: ' + error.message);
        }
      }
    });

    // Global paste handler for Ctrl+V
    document.addEventListener('paste', function(e) {
      if (document.getElementById('metadataModal').style.display === 'flex') {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.startsWith('image/')) {
            handleImagePaste(items[i].getAsFile());
            e.preventDefault();
            break;
          }
        }
      }
    });

    // Hide tooltip when clicking anywhere
    document.addEventListener('click', hideMetadataTooltip);

    document.getElementById('videoModal').addEventListener('click', function(event) {
      if (event.target === this) {
        closeVideo();
      }
    });

    document.getElementById('videoContainer').addEventListener('click', function(event) {
      event.stopPropagation();
    });

    document.getElementById('closeButton').addEventListener('click', closeVideo);

    // Content modal event listeners
    document.getElementById('contentModal').addEventListener('click', function(event) {
      if (event.target === this) {
        closeContent();
      }
    });

    document.getElementById('contentContainer').addEventListener('click', function(event) {
      event.stopPropagation();
    });

    document.getElementById('contentCloseButton').addEventListener('click', closeContent);

    // EPUB controls event listeners
    document.getElementById('epubPrev').addEventListener('click', function() {
      if (rendition) {
        rendition.prev().then(updateEpubProgress);
      }
    });

    document.getElementById('epubNext').addEventListener('click', function() {
      if (rendition) {
        rendition.next().then(updateEpubProgress);
      }
    });
    
    document.getElementById('toggleToc').addEventListener('click', toggleTableOfContents);

    // Add keyboard navigation for EPUB
    document.addEventListener('keydown', function(event) {
      if (document.getElementById('epubViewer').style.display === 'flex') {
        if (event.key === 'ArrowLeft' && rendition) {
          event.preventDefault();
          rendition.prev().then(updateEpubProgress);
        } else if (event.key === 'ArrowRight' && rendition) {
          event.preventDefault();
          rendition.next().then(updateEpubProgress);
        }
      }
    });

    function closeVideo() {
      const videoPlayer = document.getElementById('videoPlayer');
      videoPlayer.pause();
      videoPlayer.currentTime = 0;
      videoPlayer.src = '';
      document.getElementById('videoModal').style.display = 'none';

      const bgAudio = document.getElementById('backgroundAudio');
      bgAudio.pause();
      bgAudio.currentTime = 0;
    }

    document.querySelectorAll('.speed-button').forEach(function(button) {
      button.addEventListener('click', function() {
        const speed = parseFloat(this.dataset.speed);
        const videoPlayer = document.getElementById('videoPlayer');
        videoPlayer.playbackRate = speed;
        console.log(`Playback speed set to ${speed}x`);
      });
    });

    // When the page loads, check for a folder param in the URL.
    window.addEventListener('DOMContentLoaded', function() {
      const urlParams = new URLSearchParams(window.location.search);
      const folderParam = urlParams.get('folder');
      if (folderParam) {
        document.getElementById('folderPath').value = folderParam;
        loadFolder(folderParam);
      } else {
        loadFolder();
      }
    });
  </script>
</body>
</html>